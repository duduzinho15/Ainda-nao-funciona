"""
Bot do Telegram Garimpeiro Geek

Este bot busca ofertas em v√°rias lojas online e as publica em um canal do Telegram.
Suporta postagem manual de ofertas e busca autom√°tica em lojas parceiras.
"""
import logging
import asyncio
import os
import sys
import json
from datetime import datetime, time, timedelta
from typing import List, Dict, Any, Optional, Union

from telegram import Update, BotCommand
from telegram.constants import ParseMode
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackContext, JobQueue, Updater, MessageHandler, filters

import config
import database
# Importa√ß√µes de m√≥dulos locais
from telegram_poster import comando_oferta

# Importa√ß√µes das melhorias t√©cnicas
from cache_system import cache, cached, http_cache, scraper_cache
from rate_limiter import rate_limiter, rate_limited, check_rate_limit
from health_monitor import health_monitor, start_health_monitoring, add_scraper_health_check
from performance_metrics import performance_metrics, start_metrics_collection, track_performance

# Desativando a integra√ß√£o com a Amazon temporariamente
# from amazon_integration import agendar_verificacoes_amazon, PALAVRAS_CHAVE_AMAZON
from aliexpress_integration import agendar_verificacoes_aliexpress, PALAVRAS_CHAVE_ALIEXPRESS

# Integra√ß√£o com Awin
try:
    from awin_api import verificar_ofertas_awin_periodicamente, atualizar_ids_lojas_awin
    AWIN_INTEGRATION_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Integra√ß√£o Awin n√£o dispon√≠vel: {e}")
    AWIN_INTEGRATION_AVAILABLE = False

# Sistema de Notifica√ß√µes
try:
    from notification_system import (
        register_user, update_user_preferences, add_user_category, 
        add_favorite_store, notify_users_about_offer, get_user_notification_stats
    )
    NOTIFICATION_SYSTEM_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Sistema de notifica√ß√µes n√£o dispon√≠vel: {e}")
    NOTIFICATION_SYSTEM_AVAILABLE = False

# Sistema de Reviews
try:
    from product_reviews import (
        review_manager, add_product_review, get_product_reviews,
        get_user_reviews, update_review_status, get_review_stats,
        get_pending_reviews, get_product_average_rating
    )
    REVIEW_SYSTEM_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Sistema de reviews n√£o dispon√≠vel: {e}")
    REVIEW_SYSTEM_AVAILABLE = False

# Sistema de Categorias de Usu√°rios
try:
    from user_categories import category_manager
    USER_CATEGORIES_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Sistema de categorias de usu√°rios n√£o dispon√≠vel: {e}")
    USER_CATEGORIES_AVAILABLE = False

def is_admin(user_id: int) -> bool:
    """
    Verifica se um usu√°rio √© administrador.
    """
    if user_id is None:
        return False
    
    admin_id = os.getenv('ADMIN_USER_ID')
    if not admin_id:
        return False
    
    return str(user_id) == admin_id

def is_valid_update(update: Update) -> bool:
    """
    Verifica se o update √© v√°lido e cont√©m os dados necess√°rios.
    """
    if update is None:
        return False
    
    if not hasattr(update, 'effective_user') or update.effective_user is None:
        return False
    
    if not hasattr(update, 'message') or update.message is None:
        return False
    
    # Verifica se o usu√°rio tem ID v√°lido
    user = update.effective_user
    if not hasattr(user, 'id') or user.id is None:
        return False
    
    # Verifica se a mensagem tem texto
    message = update.message
    if not hasattr(message, 'text') or message.text is None:
        return False
    
    return True

async def executar_verificacao_inicial_awin():
    """
    Executa uma verifica√ß√£o inicial para configurar os IDs das lojas Awin
    antes de iniciar o ciclo normal de verifica√ß√µes.
    """
    try:
        logger.info("üîß Executando verifica√ß√£o inicial da Awin para configurar IDs das lojas...")
        
        import aiohttp
        async with aiohttp.ClientSession() as session:
            await atualizar_ids_lojas_awin(session)
        
        logger.info("‚úÖ Verifica√ß√£o inicial da Awin conclu√≠da com sucesso!")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na verifica√ß√£o inicial da Awin: {e}", exc_info=True)

# Carrega vari√°veis de ambiente do arquivo .env
from dotenv import load_dotenv
load_dotenv()

# Configura√ß√£o de comandos do bot
BOT_COMMANDS = [
    BotCommand("start", "Inicia o bot e exibe ajuda"),
    BotCommand("buscar", "For√ßa uma busca por ofertas (apenas admin)"),
    BotCommand("oferta", "Publica uma oferta manualmente (apenas admin)"),
    BotCommand("status", "Mostra status do sistema (apenas admin)"),
    BotCommand("metrics", "Mostra m√©tricas de performance (apenas admin)"),
    BotCommand("cache", "Gerencia sistema de cache (apenas admin)"),
    BotCommand("health", "Mostra sa√∫de dos servi√ßos (apenas admin)"),
    BotCommand("notificacoes", "Configurar notifica√ß√µes personalizadas"),
    BotCommand("favoritos", "Gerenciar lojas favoritas"),
    BotCommand("categorias", "Configurar categorias de interesse"),
    BotCommand("review", "Adicionar review de produto"),
    BotCommand("reviews", "Ver reviews de um produto"),
    BotCommand("minhas_reviews", "Ver suas reviews"),
    BotCommand("moderar_review", "Moderar reviews (apenas admin)")
]

def setup_logging():
    """Configura o sistema de logging para o bot."""
    try:
        # Cria o diret√≥rio de logs se n√£o existir
        logs_dir = os.path.join(os.getcwd(), 'logs')
        os.makedirs(logs_dir, exist_ok=True)
        
        # Configura o formato dos logs
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        date_format = '%Y-%m-%d %H:%M:%S'
        
        # Cria um logger simples
        logger = logging.getLogger('garimpeiro_bot')
        
        # Remove handlers existentes para evitar duplica√ß√£o
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)
            
        # Configura o n√≠vel de log
        logger.setLevel(logging.DEBUG)
        
        # Cria um handler para o console
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_formatter = logging.Formatter(log_format, datefmt=date_format)
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)
        
        # Cria um handler para o arquivo de log
        log_file = os.path.join(logs_dir, f'bot_{datetime.now().strftime("%Y%m%d")}.log')
        try:
            file_handler = logging.FileHandler(log_file, encoding='utf-8', mode='a')
            file_handler.setLevel(logging.DEBUG)
            file_formatter = logging.Formatter(log_format, datefmt=date_format)
            file_handler.setFormatter(file_formatter)
            logger.addHandler(file_handler)
            logger.info(f"Arquivo de log criado em: {os.path.abspath(log_file)}")
        except Exception as e:
            logger.error(f"Erro ao configurar o arquivo de log: {e}")
        
        # Configura o logger raiz
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.WARNING)
        
        # Configura o n√≠vel de log para bibliotecas de terceiros
        logging.getLogger('httpx').setLevel(logging.WARNING)
        logging.getLogger('telegram').setLevel(logging.INFO)
        logging.getLogger('apscheduler').setLevel(logging.INFO)
        logging.getLogger('httpcore').setLevel(logging.WARNING)
        logging.getLogger('asyncio').setLevel(logging.INFO)
        
        logger.info("Logging configurado com sucesso!")
        return logger
        
    except Exception as e:
        print(f"ERRO CR√çTICO ao configurar logging: {e}", file=sys.stderr)
        raise

# Inicializa o logger
logger = setup_logging()

# Vari√°vel global para a aplica√ß√£o do bot
application = None

async def agendar_tarefas(application: Application) -> None:
    """
    Agenda as tarefas peri√≥dicas do bot.
    
    Esta fun√ß√£o configura os jobs recorrentes, como a busca autom√°tica de ofertas.
    """
    logger.info("Configurando tarefas agendadas...")
    
    try:
        # Agenda a busca autom√°tica de ofertas a cada 6 horas
        job_queue = application.job_queue
        
        if job_queue:
            # Remove jobs antigos para evitar duplica√ß√£o
            for job in job_queue.jobs():
                if job.name in ['buscar_ofertas', 'verificar_awin', 'verificar_aliexpress', 'cleanup_cache', 'backup_metrics']:
                    job.schedule_removal()
            
            # Agenda a busca autom√°tica
            job_queue.run_repeating(
                buscar_e_publicar_ofertas,
                interval=21600,  # 6 horas em segundos
                first=10,  # Primeira execu√ß√£o em 10 segundos
                name='buscar_ofertas'
            )
            logger.info("Busca autom√°tica de ofertas agendada para executar a cada 6 horas.")
        
        # Agenda a verifica√ß√£o de ofertas do AliExpress
        try:
            from aliexpress_integration import agendar_verificacoes_aliexpress
            agendar_verificacoes_aliexpress(application)
            logger.info("Verifica√ß√µes do AliExpress agendadas com sucesso!")
        except Exception as e:
            logger.error(f"Erro ao agendar verifica√ß√µes do AliExpress: {e}", exc_info=True)
        
        # Agenda a verifica√ß√£o de ofertas da Awin
        if AWIN_INTEGRATION_AVAILABLE and job_queue:
            try:
                job_queue.run_repeating(
                    verificar_ofertas_awin_periodicamente,
                    interval=7200,  # 2 horas em segundos
                    first=30,  # Primeira execu√ß√£o em 30 segundos
                    name='verificar_awin'
                )
                logger.info("Verifica√ß√µes da Awin agendadas com sucesso!")
                
                # Executa uma verifica√ß√£o inicial para configurar os IDs das lojas
                logger.info("Executando verifica√ß√£o inicial para configurar IDs das lojas Awin...")
                asyncio.create_task(executar_verificacao_inicial_awin())
                
            except Exception as e:
                logger.error(f"Erro ao agendar verifica√ß√µes da Awin: {e}", exc_info=True)
        else:
            if not job_queue:
                logger.warning("Job queue n√£o dispon√≠vel - verifica√ß√µes da Awin n√£o agendadas")
            else:
                logger.warning("Integra√ß√£o com Awin n√£o dispon√≠vel - verifica√ß√µes n√£o agendadas")
        
        # Agenda limpeza de cache
        if job_queue:
            job_queue.run_repeating(
                cleanup_cache_job, 
                interval=timedelta(hours=6), 
                first=timedelta(minutes=15),
                name='cleanup_cache'
            )
        
        # Agenda backup de m√©tricas
        if job_queue:
            job_queue.run_repeating(
                backup_metrics_job, 
                interval=timedelta(hours=12), 
                first=timedelta(minutes=20),
                name='backup_metrics'
            )
        
        logger.info("Todas as tarefas foram agendadas com sucesso!")
        
    except Exception as e:
        logger.error(f"Erro ao agendar tarefas: {e}", exc_info=True)
        raise

# Fun√ß√µes auxiliares para melhorias t√©cnicas
def handle_health_alert(health_check: Any):
    """Callback para alertas de sa√∫de."""
    try:
        if not health_check or not hasattr(health_check, 'service_name') or not hasattr(health_check, 'status'):
            logger.warning("Alerta de sa√∫de inv√°lido recebido")
            return
            
        logger.warning(f"üö® Alerta de sa√∫de: {health_check.service_name} - {health_check.status.value}")
        if hasattr(health_check, 'error_message') and health_check.error_message:
            logger.warning(f"   Erro: {health_check.error_message}")
        
        # Envia notifica√ß√£o para admin se cr√≠tico
        if hasattr(health_check.status, 'value') and health_check.status.value == "critical":
            try:
                from telegram import Bot
                
                # Por enquanto, apenas registra o alerta no log
                # A notifica√ß√£o ser√° implementada quando o sistema de notifica√ß√µes estiver funcionando
                logger.warning(f"üö® ALERTA CR√çTICO - Servi√ßo: {health_check.service_name}")
                logger.warning(f"   Status: {health_check.status.value}")
                if hasattr(health_check, 'error_message') and health_check.error_message:
                    logger.warning(f"   Erro: {health_check.error_message}")
                
                # TODO: Implementar notifica√ß√£o ass√≠ncrona para admin
                # Esta funcionalidade ser√° implementada quando o sistema de notifica√ß√µes estiver funcionando
                
            except Exception as e:
                logger.error(f"Erro ao processar alerta de sa√∫de: {e}")
    except Exception as e:
        logger.error(f"Erro ao processar alerta de sa√∫de: {e}")

def handle_performance_anomaly(metric_name, last_value, mean, std_dev, z_score):
    """Callback para anomalias de performance."""
    try:
        if not metric_name:
            logger.warning("Anomalia de performance com nome inv√°lido")
            return
            
        logger.warning(f"üìä Anomalia de performance detectada: {metric_name}")
        logger.warning(f"   Valor: {last_value:.2f}, M√©dia: {mean:.2f}, Z-score: {z_score:.2f}")
        
        # Registra m√©trica de anomalia
        # TODO: Implementar registro de m√©trica quando o sistema estiver dispon√≠vel
    except Exception as e:
        logger.error(f"Erro ao processar anomalia de performance: {e}")

async def cleanup_cache_job(context: ContextTypes.DEFAULT_TYPE):
    """Job para limpeza de cache."""
    try:
        logger.info("üßπ Executando limpeza de cache...")
        
        # Limpa caches antigos
        try:
            cache_stats_before = cache.get_stats()
            scraper_cache_stats_before = scraper_cache.get_stats()
        except Exception as e:
            logger.warning(f"Erro ao obter estat√≠sticas do cache: {e}")
            cache_stats_before = {'current_size': 0}
            scraper_cache_stats_before = {'current_size': 0}
        
        # For√ßa limpeza
        try:
            cache._cleanup_expired()
            scraper_cache._cleanup_expired()
        except Exception as e:
            logger.warning(f"Erro ao limpar cache: {e}")
        
        # Obt√©m estat√≠sticas ap√≥s limpeza
        try:
            cache_stats_after = cache.get_stats()
            scraper_cache_stats_after = scraper_cache.get_stats()
        except Exception as e:
            logger.warning(f"Erro ao obter estat√≠sticas do cache ap√≥s limpeza: {e}")
            cache_stats_after = {'current_size': 0}
            scraper_cache_stats_after = {'current_size': 0}
        
        logger.info(f"‚úÖ Cache limpo - Principal: {cache_stats_before.get('current_size', 0)} ‚Üí {cache_stats_after.get('current_size', 0)}")
        logger.info(f"‚úÖ Cache de scrapers limpo - {scraper_cache_stats_before.get('current_size', 0)} ‚Üí {scraper_cache_stats_after.get('current_size', 0)}")
        
    except Exception as e:
        logger.error(f"‚ùå Erro na limpeza de cache: {e}")

async def backup_metrics_job(context: ContextTypes.DEFAULT_TYPE):
    """Job para backup de m√©tricas."""
    try:
        logger.info("üíæ Executando backup de m√©tricas...")
        
        # Persiste m√©tricas
        try:
            performance_metrics._persist_metrics()
        except Exception as e:
            logger.warning(f"Erro ao persistir m√©tricas: {e}")
        
        # Obt√©m dashboard atual
        try:
            dashboard = performance_metrics.get_metrics_dashboard()
            total_metrics = dashboard.get('total_metrics', 0) if dashboard else 0
        except Exception as e:
            logger.warning(f"Erro ao obter dashboard de m√©tricas: {e}")
            total_metrics = 0
        
        logger.info(f"‚úÖ Backup de m√©tricas conclu√≠do - {total_metrics} m√©tricas ativas")
        
    except Exception as e:
        logger.error(f"‚ùå Erro no backup de m√©tricas: {e}")

# Comandos para melhorias t√©cnicas
async def comando_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para mostrar status do sistema."""
    try:
        # Verifica se √© admin
        if not is_valid_update(update):
            logger.warning("Update inv√°lido em comando_status")
            return
            
        user = update.effective_user
        if not user or not user.id:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
            return
            
        if not is_admin(user.id):
            await update.message.reply_text("‚ùå Apenas administradores podem usar este comando.")
            return
        
        # Obt√©m status de sa√∫de
        try:
            health_summary = health_monitor.get_health_summary()
        except Exception as e:
            logger.warning(f"Erro ao obter status de sa√∫de: {e}")
            health_summary = {}
        
        # Obt√©m m√©tricas de cache
        try:
            cache_stats = cache.get_stats()
        except Exception as e:
            logger.warning(f"Erro ao obter estat√≠sticas do cache: {e}")
            cache_stats = {}
        
        # Obt√©m m√©tricas de rate limiting
        try:
            rate_limiter_stats = rate_limiter.get_stats()
        except Exception as e:
            logger.warning(f"Erro ao obter estat√≠sticas de rate limiting: {e}")
            rate_limiter_stats = {}
        
        # Formata mensagem
        status_msg = "üìä **Status do Sistema**\n\n"
        
        # Status de sa√∫de
        status_msg += f"üè• **Sa√∫de do Sistema:** {health_summary.get('status', 'unknown')}\n"
        status_msg += f"   ‚Ä¢ Servi√ßos saud√°veis: {health_summary.get('healthy_services', 0)}\n"
        status_msg += f"   ‚Ä¢ Servi√ßos com aviso: {health_summary.get('warning_services', 0)}\n"
        status_msg += f"   ‚Ä¢ Servi√ßos cr√≠ticos: {health_summary.get('critical_services', 0)}\n"
        status_msg += f"   ‚Ä¢ Uptime m√©dio: {health_summary.get('average_uptime_percentage', 0):.1f}%\n\n"
        
        # Status do cache
        status_msg += f"üíæ **Cache:**\n"
        status_msg += f"   ‚Ä¢ Hit rate: {cache_stats.get('hit_rate', 0):.1f}%\n"
        status_msg += f"   ‚Ä¢ Uso: {cache_stats.get('usage_percentage', 0):.1f}%\n"
        status_msg += f"   ‚Ä¢ Total de requisi√ß√µes: {cache_stats.get('total_requests', 0)}\n\n"
        
        # Status do rate limiting
        status_msg += f"üö¶ **Rate Limiting:**\n"
        status_msg += f"   ‚Ä¢ Taxa de sucesso: {rate_limiter_stats.get('success_rate_percent', 0):.1f}%\n"
        status_msg += f"   ‚Ä¢ Taxa de bloqueio: {rate_limiter_stats.get('block_rate_percent', 0):.1f}%\n"
        status_msg += f"   ‚Ä¢ Dom√≠nios bloqueados: {rate_limiter_stats.get('blocked_domains_count', 0)}\n"
        
        await update.message.reply_text(status_msg, parse_mode=ParseMode.MARKDOWN)
        
    except Exception as e:
        logger.error(f"Erro no comando status: {e}")
        await update.message.reply_text("‚ùå Erro ao obter status do sistema.")

async def comando_metrics(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para mostrar m√©tricas de performance."""
    try:
        # Verifica se √© admin
        if not is_valid_update(update):
            logger.warning("Update inv√°lido em comando_metrics")
            return
            
        user = update.effective_user
        if not user or not user.id:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
            return
            
        if not is_admin(user.id):
            await update.message.reply_text("‚ùå Apenas administradores podem usar este comando.")
            return
        
        # Obt√©m dashboard de m√©tricas
        try:
            dashboard = performance_metrics.get_metrics_dashboard()
        except Exception as e:
            logger.warning(f"Erro ao obter dashboard de m√©tricas: {e}")
            dashboard = {'error': 'Erro ao obter m√©tricas'}
        
        if 'error' in dashboard:
            await update.message.reply_text(f"‚ùå Erro ao obter m√©tricas: {dashboard['error']}")
            return
        
        # Formata mensagem
        metrics_msg = "üìà **M√©tricas de Performance**\n\n"
        
        # M√©tricas do sistema
        metrics_msg += f"üñ•Ô∏è **Sistema:**\n"
        for metric in dashboard.get('system_metrics', []):
            try:
                if isinstance(metric, dict):
                    name = metric.get('name', 'Unknown').replace('system.', '').replace('_', ' ').title()
                    value = metric.get('last_value', 0)
                    unit = metric.get('unit', '')
                    metrics_msg += f"   ‚Ä¢ {name}: {value:.1f} {unit}\n"
                else:
                    logger.warning(f"M√©trica do sistema n√£o √© um dicion√°rio: {type(metric)}")
                    continue
            except Exception as e:
                logger.warning(f"Erro ao processar m√©trica do sistema: {e}")
                continue
        
        metrics_msg += f"\nüì± **Aplica√ß√£o:**\n"
        for metric in dashboard.get('app_metrics', []):
            try:
                if isinstance(metric, dict):
                    name = metric.get('name', 'Unknown').replace('app.', '').replace('_', ' ').title()
                    value = metric.get('last_value', 0)
                    unit = metric.get('unit', '')
                    metrics_msg += f"   ‚Ä¢ {name}: {value:.1f} {unit}\n"
                else:
                    logger.warning(f"M√©trica da aplica√ß√£o n√£o √© um dicion√°rio: {type(metric)}")
                    continue
            except Exception as e:
                logger.warning(f"Erro ao processar m√©trica da aplica√ß√£o: {e}")
                continue
        
        # M√©tricas cr√≠ticas
        critical_metrics = dashboard.get('critical_metrics', [])
        if critical_metrics:
            metrics_msg += f"\nüö® **M√©tricas Cr√≠ticas:**\n"
            for metric in critical_metrics:
                try:
                    if isinstance(metric, dict):
                        metrics_msg += f"   ‚Ä¢ {metric.get('name', 'Unknown')}: {metric.get('value', 0):.1f} {metric.get('unit', '')} (limite: {metric.get('threshold', 0)}%)\n"
                    else:
                        logger.warning(f"M√©trica cr√≠tica n√£o √© um dicion√°rio: {type(metric)}")
                        continue
                except Exception as e:
                    logger.warning(f"Erro ao processar m√©trica cr√≠tica: {e}")
                    continue
        
        await update.message.reply_text(metrics_msg, parse_mode=ParseMode.MARKDOWN)
        
    except Exception as e:
        logger.error(f"Erro no comando metrics: {e}")
        await update.message.reply_text("‚ùå Erro ao obter m√©tricas.")

async def comando_cache(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para gerenciar cache."""
    try:
        # Verifica se √© admin
        if not is_valid_update(update):
            logger.warning("Update inv√°lido em comando_cache")
            return
            
        user = update.effective_user
        if not user or not user.id:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
            return
            
        if not is_admin(user.id):
            await update.message.reply_text("‚ùå Apenas administradores podem usar este comando.")
            return
        
        # Obt√©m argumentos
        args = context.args
        if not args:
            # Mostra estat√≠sticas do cache
            try:
                cache_stats = cache.get_stats()
            except Exception as e:
                logger.warning(f"Erro ao obter estat√≠sticas do cache principal: {e}")
                cache_stats = {}
                
            try:
                scraper_cache_stats = scraper_cache.get_stats()
            except Exception as e:
                logger.warning(f"Erro ao obter estat√≠sticas do cache de scrapers: {e}")
                scraper_cache_stats = {}
            
            cache_msg = "üíæ **Estat√≠sticas do Cache**\n\n"
            cache_msg += f"**Cache Principal:**\n"
            cache_msg += f"   ‚Ä¢ Tamanho atual: {cache_stats.get('current_size', 0)}\n"
            cache_msg += f"   ‚Ä¢ Hit rate: {cache_stats.get('hit_rate', 0):.1f}%\n"
            cache_msg += f"   ‚Ä¢ Total de requisi√ß√µes: {cache_stats.get('total_requests', 0)}\n\n"
            
            cache_msg += f"**Cache de Scrapers:**\n"
            cache_msg += f"   ‚Ä¢ Tamanho atual: {scraper_cache_stats.get('current_size', 0)}\n"
            cache_msg += f"   ‚Ä¢ Hit rate: {scraper_cache_stats.get('hit_rate', 0):.1f}%\n"
            cache_msg += f"   ‚Ä¢ Total de requisi√ß√µes: {scraper_cache_stats.get('total_requests', 0)}\n"
            
            await update.message.reply_text(cache_msg, parse_mode=ParseMode.MARKDOWN)
            return
        
        action = args[0].lower()
        
        if action == "clear":
            # Limpa cache
            try:
                cache.clear()
                scraper_cache.clear()
                await update.message.reply_text("‚úÖ Cache limpo com sucesso!")
            except Exception as e:
                logger.error(f"Erro ao limpar cache: {e}")
                await update.message.reply_text("‚ùå Erro ao limpar cache.")
            
        elif action == "stats":
            # Mostra estat√≠sticas detalhadas
            try:
                cache_stats = cache.get_stats()
                await update.message.reply_text(f"üìä **Estat√≠sticas do Cache:**\n```\n{json.dumps(cache_stats, indent=2)}\n```", parse_mode=ParseMode.MARKDOWN)
            except Exception as e:
                logger.error(f"Erro ao obter estat√≠sticas detalhadas do cache: {e}")
                await update.message.reply_text("‚ùå Erro ao obter estat√≠sticas detalhadas do cache.")
            
        else:
            await update.message.reply_text("‚ùå A√ß√£o inv√°lida. Use: /cache [clear|stats]")
        
    except Exception as e:
        logger.error(f"Erro no comando cache: {e}")
        await update.message.reply_text("‚ùå Erro ao gerenciar cache.")

async def comando_health(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para mostrar sa√∫de dos servi√ßos."""
    try:
        # Verifica se √© admin
        if not is_valid_update(update):
            logger.warning("Update inv√°lido em comando_health")
            return
            
        user = update.effective_user
        if not user or not user.id:
            await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
            return
            
        if not is_admin(user.id):
            await update.message.reply_text("‚ùå Apenas administradores podem usar este comando.")
            return
        
        # Obt√©m sa√∫de de todos os servi√ßos
        try:
            services_health = health_monitor.get_all_services_health()
        except Exception as e:
            logger.warning(f"Erro ao obter sa√∫de dos servi√ßos: {e}")
            services_health = []
        
        if not services_health:
            await update.message.reply_text("‚ùå Nenhum servi√ßo monitorado encontrado.")
            return
        
        # Formata mensagem
        health_msg = "üè• **Sa√∫de dos Servi√ßos**\n\n"
        
        for service in services_health:
            try:
                # Emoji baseado no status
                status_emoji = {
                    'healthy': '‚úÖ',
                    'warning': '‚ö†Ô∏è',
                    'critical': '‚ùå',
                    'unknown': '‚ùì'
                }.get(service.status.value, '‚ùì')
                
                health_msg += f"{status_emoji} **{service.service_name}**\n"
                health_msg += f"   ‚Ä¢ Status: {service.status.value}\n"
                health_msg += f"   ‚Ä¢ √öltima verifica√ß√£o: {service.timestamp.strftime('%H:%M:%S')}\n"
                
                if hasattr(service, 'metadata') and service.metadata and 'consecutive_failures' in service.metadata:
                    health_msg += f"   ‚Ä¢ Falhas consecutivas: {service.metadata['consecutive_failures']}\n"
                
                health_msg += "\n"
            except Exception as e:
                logger.warning(f"Erro ao processar servi√ßo de sa√∫de: {e}")
                continue
        
        await update.message.reply_text(health_msg, parse_mode=ParseMode.MARKDOWN)
        
    except Exception as e:
        logger.error(f"Erro no comando health: {e}")
        await update.message.reply_text("‚ùå Erro ao obter sa√∫de dos servi√ßos.")

async def buscar_e_publicar_ofertas(context: CallbackContext) -> None:
    """
    Fun√ß√£o para buscar e publicar ofertas automaticamente.
    
    Esta fun√ß√£o √© executada periodicamente para buscar ofertas nas lojas parceiras
    e public√°-las no canal do Telegram.
    """
    logger.info("Iniciando busca autom√°tica por ofertas...")
    
    try:
        # Busca ofertas no AliExpress
        logger.info("Buscando ofertas no AliExpress...")
        ofertas_aliexpress = []
        
        # Por enquanto, apenas registra que a busca foi iniciada
        # TODO: Implementar busca real de ofertas
        logger.info("Sistema de busca autom√°tica em desenvolvimento")
        
        # Combina as ofertas (apenas AliExpress por enquanto)
        todas_as_ofertas = ofertas_aliexpress
        
        # Publica as ofertas
        if todas_as_ofertas:
            logger.info(f"Publicando {len(todas_as_ofertas)} ofertas no canal...")
            
            # TODO: Implementar publica√ß√£o real de ofertas
            logger.info("Sistema de publica√ß√£o em desenvolvimento")
            
            logger.info("Publica√ß√£o de ofertas conclu√≠da com sucesso!")
        else:
            logger.info("Nenhuma oferta encontrada para publica√ß√£o.")
            
    except Exception as e:
        logger.error(f"Erro ao buscar e publicar ofertas: {str(e)}")
        logger.exception("Detalhes do erro:")

async def comando_buscar(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    For√ßa uma busca por ofertas manualmente.
    
    Este comando √© restrito ao administrador e for√ßa uma busca imediata
    por ofertas, independente do agendamento autom√°tico.
    """
    # Verifica se o usu√°rio √© o administrador
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_buscar")
        return
        
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
        
    if not is_admin(user.id):
        await update.message.reply_text("‚ùå Acesso negado. Este comando √© restrito ao administrador.")
        return
    
    await update.message.reply_text("üîç Iniciando busca manual por ofertas...")
    
    try:
        # Executa a busca
        await buscar_e_publicar_ofertas(context)
        
        await update.message.reply_text("‚úÖ Busca conclu√≠da! As ofertas encontradas foram publicadas no canal.")
        
    except Exception as e:
        logger.error(f"Erro ao executar busca manual: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå Ocorreu um erro durante a busca: {str(e)}")

async def comando_iniciar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Manipulador do comando /iniciar.
    
    Exibe uma mensagem de boas-vindas e informa√ß√µes sobre como usar o bot.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_iniciar")
        return
        
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    # Verifica se o usu√°rio √© o administrador
    is_admin_user = is_admin(user.id)
    
    # Obt√©m o nome do usu√°rio de forma segura
    user_name = user.first_name or user.username or "Usu√°rio"
    
    # Mensagem de boas-vindas
    mensagem = (
        f"üëã Ol√°, {user_name}!\n\n"
        "ü§ñ *Bem-vindo ao Garimpeiro Geek!*\n\n"
        "üîç Eu sou um bot que ajuda a encontrar as melhores ofertas em produtos de tecnologia, "
        "eletr√¥nicos e muito mais!\n\n"
        "üìå *Comandos dispon√≠veis:*\n"
        "/start - Mostra esta mensagem de ajuda\n"
        "/buscar - For√ßa uma busca por ofertas (apenas admin)\n"
        "/oferta - Publica uma oferta manualmente (apenas admin)\n"
        "/status - Mostra status do sistema (apenas admin)\n"
        "/metrics - Mostra m√©tricas de performance (apenas admin)\n"
        "/cache - Gerencia sistema de cache (apenas admin)\n"
        "/health - Mostra sa√∫de dos servi√ßos (apenas admin)\n"
        "/notificacoes - Configurar notifica√ß√µes personalizadas\n"
        "/favoritos - Gerenciar lojas favoritas\n"
        "/categorias - Configurar categorias de interesse\n\n"
        "üîî *Funcionalidades autom√°ticas:*\n"
        "‚Ä¢ Busca autom√°tica de ofertas a cada 6 horas\n"
        "‚Ä¢ Notifica√ß√µes de promo√ß√µes em tempo real\n"
        "‚Ä¢ An√°lise de hist√≥rico de pre√ßos\n"
        "‚Ä¢ Sistema de notifica√ß√µes personalizadas\n\n"
        "üìä *Lojas parceiras:*\n"
        "‚Ä¢ AliExpress\n"
        "‚Ä¢ Amazon (se configurada)\n"
        "‚Ä¢ Awin (Kabum!, Dell, Lenovo, etc.)\n\n"
        f"üí° *Dica:* Voc√™ pode me enviar o link de um produto que eu vou verificar se est√° com um bom pre√ßo!"
    )
    
    # Adiciona instru√ß√µes adicionais para o administrador
    if is_admin_user:
        mensagem += "\n\nüëë *Modo Administrador Ativado*\n"
        mensagem += "‚Ä¢ Use /buscar para for√ßar uma busca por ofertas\n"
        mensagem += "‚Ä¢ Use /oferta para publicar uma oferta manualmente"
    
    # Envia a mensagem de boas-vindas
    await update.message.reply_text(
        mensagem,
        parse_mode=ParseMode.MARKDOWN,
        disable_web_page_preview=True
    )
    
    # Registra o usu√°rio no sistema de notifica√ß√µes se dispon√≠vel
    if NOTIFICATION_SYSTEM_AVAILABLE:
        try:
            user_id = user.id
            if user_id is not None:
                # Obt√©m os dados do usu√°rio de forma segura
                username = user.username or user.first_name or "usu√°rio"
                first_name = user.first_name or user.username or "Usu√°rio"
                last_name = user.last_name or ""
                
                register_user(
                    user_id,
                    username=username,
                    first_name=first_name,
                    last_name=last_name
                )
                logger.info(f"‚úÖ Usu√°rio {user_id} registrado no sistema de notifica√ß√µes")
        except Exception as e:
            logger.error(f"‚ùå Erro ao registrar usu√°rio: {e}")
    
    logger.info(f"Usu√°rio {user.id} ({user_name}) iniciou o bot.")

async def comando_notificacoes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para configurar notifica√ß√µes personalizadas.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_notificacoes")
        return
        
    if not NOTIFICATION_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de notifica√ß√µes n√£o est√° dispon√≠vel no momento."
        )
        return
    
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    # Obt√©m estat√≠sticas do usu√°rio
    try:
        stats = get_user_notification_stats(user.id)
    except Exception as e:
        logger.warning(f"Erro ao obter estat√≠sticas do usu√°rio: {e}")
        stats = None
    
    if not stats:
        # Registra o usu√°rio se n√£o existir
        try:
            # Obt√©m os dados do usu√°rio de forma segura
            username = user.username or user.first_name or "usu√°rio"
            first_name = user.first_name or user.username or "Usu√°rio"
            
            register_user(user.id, username=username, first_name=first_name)
            stats = get_user_notification_stats(user.id)
        except Exception as e:
            logger.error(f"Erro ao registrar usu√°rio: {e}")
            await update.message.reply_text("‚ùå Erro ao configurar notifica√ß√µes. Tente novamente.")
            return
    
    # Obt√©m o nome do usu√°rio de forma segura
    user_name = user.first_name or user.username or "Usu√°rio"
    
    # Cria mensagem com configura√ß√µes atuais
    try:
        mensagem = (
            f"üîî *Configura√ß√µes de Notifica√ß√µes*\n\n"
            f"üë§ *Usu√°rio:* {user_name}\n"
            f"üìä *Total de notifica√ß√µes:* {stats.get('total_notifications', 0)}\n"
            f"‚úÖ *Notifica√ß√µes enviadas:* {stats.get('successful_notifications', 0)}\n"
            f"‚ùå *Falhas:* {stats.get('failed_notifications', 0)}\n\n"
            f"‚öôÔ∏è *Configura√ß√µes Atuais:*\n"
            f"‚Ä¢ Desconto m√≠nimo: {stats.get('preferences', {}).get('min_discount', 0)}%\n"
            f"‚Ä¢ Pre√ßo m√°ximo: R$ {stats.get('preferences', {}).get('max_price', 'Sem limite') if stats.get('preferences', {}).get('max_price') else 'Sem limite'}\n"
            f"‚Ä¢ Frequ√™ncia: {stats.get('preferences', {}).get('notification_frequency', 'Padr√£o')}\n\n"
            f"üéØ *Categorias:* {', '.join(stats.get('preferences', {}).get('categories', [])) if stats.get('preferences', {}).get('categories') else 'Nenhuma configurada'}\n"
            f"‚≠ê *Lojas favoritas:* {', '.join(stats.get('preferences', {}).get('favorite_stores', [])) if stats.get('preferences', {}).get('favorite_stores') else 'Nenhuma configurada'}\n\n"
            f"üí° *Para configurar:*\n"
            f"‚Ä¢ Use /categorias para adicionar categorias de interesse\n"
            f"‚Ä¢ Use /favoritos para adicionar lojas favoritas\n"
            "‚Ä¢ Envie uma mensagem com 'desconto X' para alterar o desconto m√≠nimo\n"
            "‚Ä¢ Envie uma mensagem com 'preco X' para alterar o pre√ßo m√°ximo"
        )
        
        await update.message.reply_text(
            mensagem,
            parse_mode=ParseMode.MARKDOWN
        )
    except Exception as e:
        logger.error(f"Erro ao criar mensagem de notifica√ß√µes: {e}")
        await update.message.reply_text("‚ùå Erro ao configurar notifica√ß√µes. Tente novamente.")

async def comando_favoritos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para gerenciar lojas favoritas.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_favoritos")
        return
        
    if not NOTIFICATION_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de notifica√ß√µes n√£o est√° dispon√≠vel no momento."
        )
        return
    
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    # Obt√©m estat√≠sticas do usu√°rio
    try:
        stats = get_user_notification_stats(user.id)
    except Exception as e:
        logger.warning(f"Erro ao obter estat√≠sticas do usu√°rio: {e}")
        stats = None
    
    if not stats:
        # Registra o usu√°rio se n√£o existir
        try:
            # Obt√©m os dados do usu√°rio de forma segura
            username = user.username or user.first_name or "usu√°rio"
            first_name = user.first_name or user.username or "Usu√°rio"
            
            register_user(user.id, username=username, first_name=first_name)
            stats = get_user_notification_stats(user.id)
        except Exception as e:
            logger.error(f"Erro ao registrar usu√°rio: {e}")
            await update.message.reply_text("‚ùå Erro ao configurar favoritos. Tente novamente.")
            return
    
    # Lista de lojas dispon√≠veis
    lojas_disponiveis = [
        "Kabum!", "Dell", "Lenovo", "Acer", "ASUS", "Trocafy", 
        "Samsung", "Casa Bahia", "Magazine Luiza", "Amazon", 
        "Shopee", "AliExpress", "Mercado Livre", "Zoom", "Pelando"
    ]
    
    # Cria mensagem com lojas favoritas
    try:
        lojas_favoritas = stats.get('preferences', {}).get('favorite_stores', [])
        
        mensagem = (
            f"‚≠ê *Lojas Favoritas*\n\n"
            f"üè™ *Suas lojas favoritas:*\n"
        )
        
        if lojas_favoritas:
            for loja in lojas_favoritas:
                mensagem += f"‚Ä¢ {loja}\n"
        else:
            mensagem += "Nenhuma loja favorita configurada\n"
        
        mensagem += (
            f"\nüè™ *Lojas dispon√≠veis:*\n"
            f"{', '.join(lojas_disponiveis)}\n\n"
            f"üí° *Para adicionar:* Envie 'favorita NOME_DA_LOJA'\n"
            f"üí° *Para remover:* Envie 'remover NOME_DA_LOJA'\n"
            f"üí° *Exemplo:* 'favorita Kabum!'"
        )
        
        await update.message.reply_text(
            mensagem,
            parse_mode=ParseMode.MARKDOWN
        )
    except Exception as e:
        logger.error(f"Erro ao criar mensagem de favoritos: {e}")
        await update.message.reply_text("‚ùå Erro ao configurar favoritos. Tente novamente.")

async def comando_categorias(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para configurar categorias de interesse.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_categorias")
        return
        
    if not NOTIFICATION_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de notifica√ß√µes n√£o est√° dispon√≠vel no momento."
        )
        return
    
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    # Obt√©m estat√≠sticas do usu√°rio
    try:
        stats = get_user_notification_stats(user.id)
    except Exception as e:
        logger.warning(f"Erro ao obter estat√≠sticas do usu√°rio: {e}")
        stats = None
    
    if not stats:
        # Registra o usu√°rio se n√£o existir
        try:
            # Obt√©m os dados do usu√°rio de forma segura
            username = user.username or user.first_name or "usu√°rio"
            first_name = user.first_name or user.username or "Usu√°rio"
            
            register_user(user.id, username=username, first_name=first_name)
            stats = get_user_notification_stats(user.id)
        except Exception as e:
            logger.error(f"Erro ao registrar usu√°rio: {e}")
            await update.message.reply_text("‚ùå Erro ao configurar categorias. Tente novamente.")
            return
    
    # Lista de categorias dispon√≠veis
    categorias_disponiveis = [
        "gaming", "tecnologia", "smartphones", "notebooks", "desktops",
        "perifericos", "consoles", "jogos", "audio", "video", "casa",
        "fitness", "livros", "brinquedos", "moda", "beleza"
    ]
    
    # Cria mensagem com categorias configuradas
    try:
        categorias_configuradas = stats.get('preferences', {}).get('categories', [])
        
        mensagem = (
            f"üéØ *Categorias de Interesse*\n\n"
            f"üìÇ *Suas categorias:*\n"
        )
        
        if categorias_configuradas:
            for categoria in categorias_configuradas:
                mensagem += f"‚Ä¢ {categoria.title()}\n"
        else:
            mensagem += "Nenhuma categoria configurada\n"
        
        mensagem += (
            f"\nüìÇ *Categorias dispon√≠veis:*\n"
            f"{', '.join([cat.title() for cat in categorias_disponiveis])}\n\n"
            f"üí° *Para adicionar:* Envie 'categoria NOME_DA_CATEGORIA'\n"
            f"üí° *Para remover:* Envie 'remover NOME_DA_CATEGORIA'\n"
            f"üí° *Exemplo:* 'categoria gaming'"
        )
        
        await update.message.reply_text(
            mensagem,
            parse_mode=ParseMode.MARKDOWN
        )
    except Exception as e:
        logger.error(f"Erro ao criar mensagem de categorias: {e}")
        await update.message.reply_text("‚ùå Erro ao configurar categorias. Tente novamente.")

async def comando_review(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para adicionar uma avalia√ß√£o a um produto.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_review")
        return
        
    if not REVIEW_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de reviews n√£o est√° dispon√≠vel no momento."
        )
        return
    
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    # Verifica se h√° argumentos
    if not context.args:
        await update.message.reply_text(
            "üìù *Como usar o comando /review:*\n\n"
            "üîó *Formato:* /review [link_do_produto] [nota] [coment√°rio]\n\n"
            "üìä *Notas:* 1 (ruim) a 5 (excelente)\n\n"
            "üí° *Exemplos:*\n"
            "‚Ä¢ /review https://amazon.com/produto 5 Produto incr√≠vel!\n"
            "‚Ä¢ /review https://magalu.com/item 3 Bom, mas poderia ser melhor\n\n"
            "‚ö†Ô∏è *Importante:* O link deve ser de um produto v√°lido",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    # Extrai argumentos
    if len(context.args) < 3:
        await update.message.reply_text(
            "‚ùå *Formato inv√°lido!*\n\n"
            "üîó Use: /review [link] [nota] [coment√°rio]\n"
            "üìä Nota: 1-5\n\n"
            "üí° *Exemplo:* /review https://amazon.com/produto 5 Excelente produto!",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    try:
        link = context.args[0]
        nota = int(context.args[1])
        comentario = ' '.join(context.args[2:])
        
        # Valida nota
        if not 1 <= nota <= 5:
            await update.message.reply_text(
                "‚ùå *Nota inv√°lida!*\n\n"
                "üìä A nota deve estar entre 1 e 5\n"
                "‚Ä¢ 1 = Ruim\n"
                "‚Ä¢ 2 = Regular\n"
                "‚Ä¢ 3 = Bom\n"
                "‚Ä¢ 4 = Muito bom\n"
                "‚Ä¢ 5 = Excelente"
            )
            return
        
        # Adiciona review
        # Obt√©m o username de forma segura
        username = user.username or user.first_name or "usu√°rio"
        
        try:
            success = await add_product_review(
                user_id=user.id,
                product_url=link,
                rating=nota,
                comment=comentario,
                username=username
            )
        except Exception as e:
            logger.error(f"Erro ao adicionar review: {e}")
            await update.message.reply_text("‚ùå Erro ao adicionar review. Tente novamente.")
            return
        
        if success:
            await update.message.reply_text(
                f"‚úÖ *Review adicionada com sucesso!*\n\n"
                f"üìä *Nota:* {nota}/5\n"
                f"üí¨ *Coment√°rio:* {comentario}\n"
                f"üîó *Produto:* {link}\n\n"
                f"üí° Use /reviews [link] para ver todas as avalia√ß√µes deste produto"
            )
        else:
            await update.message.reply_text(
                "‚ùå *Erro ao adicionar review!*\n\n"
                "üîç Verifique se o link √© v√°lido e tente novamente."
            )
            
    except ValueError:
        await update.message.reply_text(
            "‚ùå *Formato inv√°lido!*\n\n"
            "üìä A nota deve ser um n√∫mero entre 1 e 5\n\n"
            "üí° *Exemplo:* /review https://amazon.com/produto 5 Excelente produto!"
        )
    except Exception as e:
        logger.error(f"Erro inesperado no comando review: {e}")
        await update.message.reply_text(
            f"‚ùå *Erro inesperado:* {str(e)}\n\n"
            "üîç Tente novamente ou contate o administrador."
        )

async def comando_reviews(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para ver avalia√ß√µes de um produto.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_reviews")
        return
        
    if not REVIEW_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de reviews n√£o est√° dispon√≠vel no momento."
        )
        return
    
    # Verifica se h√° argumentos
    if not context.args:
        await update.message.reply_text(
            "üîç *Como usar o comando /reviews:*\n\n"
            "üîó *Formato:* /reviews [link_do_produto]\n\n"
            "üí° *Exemplo:* /reviews https://amazon.com/produto\n\n"
            "‚ö†Ô∏è *Importante:* O link deve ser de um produto v√°lido",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    try:
        link = context.args[0]
        
        # Obt√©m reviews do produto
        try:
            reviews = await get_product_reviews(link)
        except Exception as e:
            logger.error(f"Erro ao obter reviews do produto: {e}")
            await update.message.reply_text("‚ùå Erro ao buscar reviews. Tente novamente.")
            return
        
        if not reviews:
            await update.message.reply_text(
                "üìù *Nenhuma avalia√ß√£o encontrada para este produto.*\n\n"
                f"üîó *Produto:* {link}\n\n"
                "üí° Seja o primeiro a avaliar! Use /review [link] [nota] [coment√°rio]"
            )
            return
        
        # Calcula m√©dia das notas
        try:
            notas = [r.get('rating', 0) for r in reviews if isinstance(r, dict)]
            media = sum(notas) / len(notas) if notas else 0
        except Exception as e:
            logger.warning(f"Erro ao calcular m√©dia das notas: {e}")
            media = 0
        
        # Cria mensagem com reviews
        mensagem = (
            f"üìä *Avalia√ß√µes do Produto*\n\n"
            f"üîó *Produto:* {link}\n"
            f"‚≠ê *M√©dia:* {media:.1f}/5 ({len(reviews)} avalia√ß√µes)\n\n"
        )
        
        # Adiciona reviews (m√°ximo 5 para n√£o sobrecarregar)
        for i, review in enumerate(reviews[:5]):
            try:
                if isinstance(review, dict):
                    status_emoji = "‚úÖ" if review.get('status') == 'approved' else "‚è≥" if review.get('status') == 'pending' else "‚ùå"
                    mensagem += (
                        f"{status_emoji} *{review.get('username', 'Usu√°rio')}* - {review.get('rating', 0)}/5\n"
                        f"üí¨ {review.get('comment', 'Sem coment√°rio')}\n"
                        f"üìÖ {review.get('created_at', 'Data desconhecida')}\n\n"
                    )
                else:
                    logger.warning(f"Review n√£o √© um dicion√°rio: {type(review)}")
                    continue
            except Exception as e:
                logger.warning(f"Erro ao processar review: {e}")
                continue
        
        if len(reviews) > 5:
            mensagem += f"üìÑ *Mostrando 5 de {len(reviews)} avalia√ß√µes*\n\n"
        
        mensagem += "üí° Use /review [link] [nota] [coment√°rio] para adicionar sua avalia√ß√£o"
        
        await update.message.reply_text(
            mensagem,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Erro inesperado no comando reviews: {e}")
        await update.message.reply_text(
            f"‚ùå *Erro ao buscar reviews:* {str(e)}\n\n"
            "üîç Verifique se o link √© v√°lido e tente novamente."
        )

async def comando_minhas_reviews(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para ver as avalia√ß√µes do usu√°rio.
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_minhas_reviews")
        return
        
    if not REVIEW_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de reviews n√£o est√° dispon√≠vel no momento."
        )
        return
    
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text("‚ùå Usu√°rio n√£o encontrado ou ID inv√°lido.")
        return
    
    try:
        # Obt√©m reviews do usu√°rio
        try:
            reviews = await get_user_reviews(user.id)
        except Exception as e:
            logger.error(f"Erro ao obter reviews do usu√°rio: {e}")
            await update.message.reply_text("‚ùå Erro ao buscar suas reviews. Tente novamente.")
            return
        
        if not reviews:
            await update.message.reply_text(
                "üìù *Voc√™ ainda n√£o fez nenhuma avalia√ß√£o.*\n\n"
                "üí° Use /review [link] [nota] [coment√°rio] para avaliar um produto!"
            )
            return
        
        # Obt√©m o nome do usu√°rio de forma segura
        user_name = user.first_name or user.username or "Usu√°rio"
        
        # Cria mensagem com reviews do usu√°rio
        mensagem = (
            f"üìù *Suas Avalia√ß√µes*\n\n"
            f"üë§ *Usu√°rio:* {user_name}\n"
            f"üìä *Total:* {len(reviews)} avalia√ß√µes\n\n"
        )
        
        # Adiciona reviews (m√°ximo 5)
        for i, review in enumerate(reviews[:5]):
            try:
                if isinstance(review, dict):
                    status_emoji = "‚úÖ" if review.get('status') == 'approved' else "‚è≥" if review.get('status') == 'pending' else "‚ùå"
                    product_url = review.get('product_url', 'Link desconhecido')
                    mensagem += (
                        f"{status_emoji} *{review.get('rating', 0)}/5* - {product_url[:50]}...\n"
                        f"üí¨ {review.get('comment', 'Sem coment√°rio')}\n"
                        f"üìÖ {review.get('created_at', 'Data desconhecida')}\n\n"
                    )
                else:
                    logger.warning(f"Review n√£o √© um dicion√°rio: {type(review)}")
                    continue
            except Exception as e:
                logger.warning(f"Erro ao processar review do usu√°rio: {e}")
                continue
        
        if len(reviews) > 5:
            mensagem += f"üìÑ *Mostrando 5 de {len(reviews)} avalia√ß√µes*\n\n"
        
        mensagem += "üí° Use /reviews [link] para ver todas as avalia√ß√µes de um produto"
        
        await update.message.reply_text(
            mensagem,
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"Erro inesperado no comando minhas_reviews: {e}")
        await update.message.reply_text(
            f"‚ùå *Erro ao buscar suas reviews:* {str(e)}\n\n"
            "üîç Tente novamente ou contate o administrador."
        )

async def comando_moderar_review(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando para moderar avalia√ß√µes (apenas administradores).
    """
    if not is_valid_update(update):
        logger.warning("Update inv√°lido em comando_moderar_review")
        return
        
    if not REVIEW_SYSTEM_AVAILABLE:
        await update.message.reply_text(
            "‚ùå Sistema de reviews n√£o est√° dispon√≠vel no momento."
        )
        return
    
    # Verifica se √© administrador
    user = update.effective_user
    if not user or not user.id:
        await update.message.reply_text(
            "‚ùå *Acesso negado!*\n\n"
            "üîí Este comando √© restrito a administradores."
        )
        return
    
    # Verifica se √© administrador
    if not is_admin(user.id):
        await update.message.reply_text(
            "‚ùå *Acesso negado!*\n\n"
            "üîí Este comando √© restrito a administradores."
        )
        return
    
    # Verifica se h√° argumentos
    if not context.args:
        await update.message.reply_text(
            "üîß *Como usar o comando /moderar_review:*\n\n"
            "üîó *Formato:* /moderar_review [review_id] [acao]\n\n"
            "üìã *A√ß√µes dispon√≠veis:*\n"
            "‚Ä¢ aprovar - Aprova a review\n"
            "‚Ä¢ rejeitar - Rejeita a review\n"
            "‚Ä¢ spam - Marca como spam\n\n"
            "üí° *Exemplo:* /moderar_review 123 aprovar\n\n"
            "üìä Use /moderar_review pendentes para ver reviews pendentes",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    try:
        if context.args[0] == 'pendentes':
            # Mostra reviews pendentes
            try:
                pending_reviews = await get_pending_reviews()
            except Exception as e:
                logger.error(f"Erro ao obter reviews pendentes: {e}")
                await update.message.reply_text("‚ùå Erro ao buscar reviews pendentes. Tente novamente.")
                return
            
            if not pending_reviews:
                await update.message.reply_text(
                    "‚úÖ *Nenhuma review pendente para modera√ß√£o.*"
                )
                return
            
            mensagem = (
                f"üìã *Reviews Pendentes para Modera√ß√£o*\n\n"
                f"üìä *Total:* {len(pending_reviews)} reviews\n\n"
            )
            
            # Mostra reviews pendentes (m√°ximo 5)
            for i, review in enumerate(pending_reviews[:5]):
                try:
                    if isinstance(review, dict):
                        mensagem += (
                            f"üÜî *ID:* {review.get('id', 'N/A')}\n"
                            f"üë§ *Usu√°rio:* {review.get('username', 'Usu√°rio')}\n"
                            f"‚≠ê *Nota:* {review.get('rating', 0)}/5\n"
                            f"üí¨ *Coment√°rio:* {review.get('comment', 'Sem coment√°rio')[:100]}...\n"
                            f"üîó *Produto:* {review.get('product_url', 'Link desconhecido')[:50]}...\n"
                            f"üìÖ *Data:* {review.get('created_at', 'Data desconhecida')}\n\n"
                        )
                    else:
                        logger.warning(f"Review pendente n√£o √© um dicion√°rio: {type(review)}")
                        continue
                except Exception as e:
                    logger.warning(f"Erro ao processar review pendente: {e}")
                    continue
            
            if len(pending_reviews) > 5:
                mensagem += f"üìÑ *Mostrando 5 de {len(pending_reviews)} reviews*\n\n"
            
            mensagem += "üí° Use /moderar_review [id] [acao] para moderar"
            
            await update.message.reply_text(
                mensagem,
                parse_mode=ParseMode.MARKDOWN
            )
            return
        
        # Processa a√ß√£o de modera√ß√£o
        if len(context.args) < 2:
            await update.message.reply_text(
                "‚ùå *Formato inv√°lido!*\n\n"
                "üîó Use: /moderar_review [review_id] [acao]\n"
                "üìã A√ß√µes: aprovar, rejeitar, spam"
            )
            return
        
        try:
            review_id = int(context.args[0])
        except ValueError:
            await update.message.reply_text(
                "‚ùå *ID inv√°lido!*\n\n"
                "üÜî O ID da review deve ser um n√∫mero\n\n"
                "üí° *Exemplo:* /moderar_review 123 aprovar"
            )
            return
            
        acao = context.args[1].lower()
        
        # Valida a√ß√£o
        if acao not in ['aprovar', 'rejeitar', 'spam']:
            await update.message.reply_text(
                "‚ùå *A√ß√£o inv√°lida!*\n\n"
                "üìã A√ß√µes dispon√≠veis:\n"
                "‚Ä¢ aprovar\n"
                "‚Ä¢ rejeitar\n"
                "‚Ä¢ spam"
            )
            return
        
        # Executa modera√ß√£o
        try:
            success = await update_review_status(review_id, acao)
        except Exception as e:
            logger.error(f"Erro ao moderar review: {e}")
            await update.message.reply_text("‚ùå Erro ao moderar review. Tente novamente.")
            return
        
        if success:
            status_emoji = "‚úÖ" if acao == 'aprovar' else "‚ùå" if acao == 'rejeitar' else "üö´"
            await update.message.reply_text(
                f"{status_emoji} *Review moderada com sucesso!*\n\n"
                f"üÜî *ID:* {review_id}\n"
                f"üìã *A√ß√£o:* {acao.title()}\n\n"
                f"üí° Use /moderar_review pendentes para ver outras reviews pendentes"
            )
        else:
            await update.message.reply_text(
                "‚ùå *Erro ao moderar review!*\n\n"
                "üîç Verifique se o ID √© v√°lido e tente novamente."
            )
            
    except Exception as e:
        logger.error(f"Erro inesperado no comando moderar_review: {e}")
        await update.message.reply_text(
            f"‚ùå *Erro inesperado:* {str(e)}\n\n"
            "üîç Tente novamente ou contate o administrador."
        )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Manipula mensagens de texto recebidas.
    """
    # Verifica se update e update.message existem
    if not update or not update.message:
        logger.warning("Update ou message √© None em handle_message")
        return
    
    # Verifica se update.message tem os atributos necess√°rios
    if not hasattr(update.message, 'text') or not update.message.text:
        logger.warning("Texto da mensagem n√£o encontrado em handle_message")
        return
    
    user = update.effective_user
    if not user or not user.id:
        logger.warning("Usu√°rio n√£o encontrado ou ID inv√°lido em handle_message")
        return
        
    message_text = update.message.text.lower().strip()
    
    # Verifica se a mensagem √© um comando (come√ßa com /)
    if message_text.startswith('/'):
        return  # Comandos s√£o tratados por seus pr√≥prios manipuladores
    
    # Verifica se a mensagem √© um link
    if 'http' in message_text or 'www.' in message_text:
        # Aqui voc√™ pode adicionar l√≥gica para processar links de produtos
        await update.message.reply_text(
            "üîç Analisando o link do produto...\n\n"
            "Em breve voc√™ receber√° informa√ß√µes detalhadas sobre este produto!"
        )
        
        # Simula uma an√°lise do produto (substitua por uma chamada real ao seu sistema de an√°lise)
        await asyncio.sleep(2)
        
        await update.message.reply_text(
            "üìä *An√°lise do Produto*\n\n"
            "üîó *Link:* [Clique aqui para ver o produto]()\n"
            "üè∑Ô∏è *Pre√ßo atual:* R$ 999,99\n"
            "üìâ *Menor pre√ßo hist√≥rico:* R$ 899,99\n"
            "üìà *M√©dia de pre√ßo:* R$ 950,00\n\n"
            "üí° *Recomenda√ß√£o:* Aguardar uma promo√ß√£o melhor\n"
            "üîî *Alerta de pre√ßo:* Posso te avisar quando o pre√ßo baixar para R$ 850,00?"
            " (Sim/N√£o)",
            parse_mode=ParseMode.MARKDOWN,
            disable_web_page_preview=False
        )
        return
    
    # Processa comandos de configura√ß√£o do sistema de notifica√ß√µes
    if NOTIFICATION_SYSTEM_AVAILABLE:
        # Comando para adicionar categoria
        if message_text.startswith('categoria '):
            categoria = message_text.replace('categoria ', '').strip()
            if categoria:
                try:
                    success = add_user_category(user.id, categoria)
                    if success:
                        await update.message.reply_text(
                            f"‚úÖ Categoria '{categoria.title()}' adicionada com sucesso!\n\n"
                            f"Use /categorias para ver suas categorias configuradas."
                        )
                    else:
                        await update.message.reply_text(
                            "‚ùå Erro ao adicionar categoria. Tente novamente."
                        )
                except Exception as e:
                    logger.error(f"Erro ao adicionar categoria: {e}")
                    await update.message.reply_text("‚ùå Erro ao adicionar categoria. Tente novamente.")
            return
        
        # Comando para adicionar loja favorita
        elif message_text.startswith('favorita '):
            loja = message_text.replace('favorita ', '').strip()
            if loja:
                try:
                    success = add_favorite_store(user.id, loja)
                    if success:
                        await update.message.reply_text(
                            f"‚≠ê Loja '{loja}' adicionada aos favoritos!\n\n"
                            f"Use /favoritos para ver suas lojas favoritas."
                        )
                    else:
                        await update.message.reply_text(
                            "‚ùå Erro ao adicionar loja favorita. Tente novamente."
                        )
                except Exception as e:
                    logger.error(f"Erro ao adicionar loja favorita: {e}")
                    await update.message.reply_text("‚ùå Erro ao adicionar loja favorita. Tente novamente.")
            return
        
        # Comando para configurar desconto m√≠nimo
        elif message_text.startswith('desconto '):
            try:
                desconto = int(message_text.replace('desconto ', '').strip())
                if 0 <= desconto <= 100:
                    try:
                        success = update_user_preferences(user.id, min_discount=desconto)
                        if success:
                            await update.message.reply_text(
                                f"‚úÖ Desconto m√≠nimo configurado para {desconto}%!\n\n"
                                f"Voc√™ receber√° notifica√ß√µes apenas para ofertas com desconto maior ou igual a {desconto}%."
                            )
                        else:
                            await update.message.reply_text(
                                "‚ùå Erro ao configurar desconto. Tente novamente."
                            )
                    except Exception as e:
                        logger.error(f"Erro ao configurar desconto: {e}")
                        await update.message.reply_text("‚ùå Erro ao configurar desconto. Tente novamente.")
                else:
                    await update.message.reply_text(
                        "‚ùå Desconto deve estar entre 0% e 100%."
                    )
            except ValueError:
                await update.message.reply_text(
                    "‚ùå Formato inv√°lido. Use: 'desconto X' (ex: 'desconto 25')"
                )
            return
        
        # Comando para configurar pre√ßo m√°ximo
        elif message_text.startswith('preco '):
            try:
                preco = float(message_text.replace('preco ', '').strip())
                if preco > 0:
                    try:
                        success = update_user_preferences(user.id, max_price=preco)
                        if success:
                            await update.message.reply_text(
                                f"‚úÖ Pre√ßo m√°ximo configurado para R$ {preco:.2f}!\n\n"
                                f"Voc√™ receber√° notifica√ß√µes apenas para ofertas com pre√ßo menor ou igual a R$ {preco:.2f}."
                            )
                        else:
                            await update.message.reply_text(
                                "‚ùå Erro ao configurar pre√ßo. Tente novamente."
                            )
                    except Exception as e:
                        logger.error(f"Erro ao configurar pre√ßo: {e}")
                        await update.message.reply_text("‚ùå Erro ao configurar pre√ßo. Tente novamente.")
                else:
                    await update.message.reply_text(
                        "‚ùå Pre√ßo deve ser maior que zero."
                    )
            except ValueError:
                await update.message.reply_text(
                    "‚ùå Formato inv√°lido. Use: 'preco X' (ex: 'preco 1500')"
                )
            return
    
    # Resposta padr√£o para mensagens de texto que n√£o s√£o comandos ou links
    await update.message.reply_text(
        "ü§ñ *Ol√°!*\n\n"
        "Para come√ßar, voc√™ pode:\n"
        "‚Ä¢ Enviar um link de produto para eu analisar\n"
        "‚Ä¢ Usar /start para ver as op√ß√µes dispon√≠veis\n"
        "‚Ä¢ Usar /notificacoes para configurar alertas personalizados\n"
        "‚Ä¢ Usar /categorias para configurar categorias de interesse\n"
        "‚Ä¢ Usar /favoritos para configurar lojas favoritas\n"
        "‚Ä¢ Se for administrador, use /buscar para for√ßar uma busca por ofertas",
        parse_mode=ParseMode.MARKDOWN
    )

async def setup_bot_commands(application: Application) -> None:
    """Configura os comandos do bot no Telegram."""
    await application.bot.set_my_commands(BOT_COMMANDS)
    logger.info("Comandos do bot configurados com sucesso")

async def main_async():
    """Fun√ß√£o ass√≠ncrona principal para inicializa√ß√£o do bot."""
    global application
    
    logger.info("Iniciando o Garimpeiro Geek...")
    
    try:
        # Configura o token do bot
        token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not token:
            logger.error("Token do bot n√£o encontrado. Verifique a vari√°vel de ambiente TELEGRAM_BOT_TOKEN.")
            return
        
        # Cria a aplica√ß√£o
        application = Application.builder().token(token).build()
        
        # Configura os manipuladores de comandos
        application.add_handler(CommandHandler("start", comando_iniciar))
        application.add_handler(CommandHandler("buscar", comando_buscar))
        application.add_handler(CommandHandler("oferta", comando_oferta))
        
        # Adiciona handlers para melhorias t√©cnicas
        application.add_handler(CommandHandler("status", comando_status))
        application.add_handler(CommandHandler("metrics", comando_metrics))
        application.add_handler(CommandHandler("cache", comando_cache))
        application.add_handler(CommandHandler("health", comando_health))
        
        # Adiciona handlers para o sistema de notifica√ß√µes
        if NOTIFICATION_SYSTEM_AVAILABLE:
            application.add_handler(CommandHandler("notificacoes", comando_notificacoes))
            application.add_handler(CommandHandler("favoritos", comando_favoritos))
            application.add_handler(CommandHandler("categorias", comando_categorias))
            logger.info("‚úÖ Handlers do sistema de notifica√ß√µes configurados")
        else:
            logger.warning("‚ö†Ô∏è Sistema de notifica√ß√µes n√£o dispon√≠vel - handlers n√£o configurados")
        
        # Adiciona handlers para o sistema de reviews
        if REVIEW_SYSTEM_AVAILABLE:
            application.add_handler(CommandHandler("review", comando_review))
            application.add_handler(CommandHandler("reviews", comando_reviews))
            application.add_handler(CommandHandler("minhas_reviews", comando_minhas_reviews))
            application.add_handler(CommandHandler("moderar_review", comando_moderar_review))
            logger.info("‚úÖ Handlers do sistema de reviews configurados")
        else:
            logger.warning("‚ö†Ô∏è Sistema de reviews n√£o dispon√≠vel - handlers n√£o configurados")
        
        # Adiciona manipulador para mensagens de texto
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        
        # Configura o manipulador de erros
        application.add_error_handler(error_handler)
        
        # Configura os comandos do bot no Telegram
        await setup_bot_commands(application)
        
        # Inicializa sistemas de melhorias t√©cnicas
        logger.info("üöÄ Inicializando sistemas de melhorias t√©cnicas...")
        
        try:
            # Inicia monitoramento de sa√∫de
            start_health_monitoring()
            logger.info("‚úÖ Monitoramento de sa√∫de iniciado")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro ao iniciar monitoramento de sa√∫de: {e}")
        
        try:
            # Inicia coleta de m√©tricas
            start_metrics_collection()
            logger.info("‚úÖ Coleta de m√©tricas iniciada")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro ao iniciar coleta de m√©tricas: {e}")
        
        try:
            # Adiciona verificadores de sa√∫de para scrapers
            add_scraper_health_check("amazon_scraper", lambda: True, 300)
            add_scraper_health_check("aliexpress_scraper", lambda: True, 300)
            add_scraper_health_check("magalu_scraper", lambda: True, 300)
            add_scraper_health_check("promobit_scraper", lambda: True, 300)
            add_scraper_health_check("awin_api", lambda: True, 120)
            logger.info("‚úÖ Verificadores de sa√∫de dos scrapers configurados")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro ao configurar verificadores de sa√∫de: {e}")
        
        try:
            # Configura callbacks de alerta
            health_monitor.add_alert_callback(handle_health_alert)
            performance_metrics.add_anomaly_callback(handle_performance_anomaly)
            logger.info("‚úÖ Callbacks de alerta configurados")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Erro ao configurar callbacks de alerta: {e}")
        
        # Agenda as tarefas peri√≥dicas
        await agendar_tarefas(application)
        
        # Inicializa o bot
        logger.info("Inicializando o bot...")
        
        # Remove qualquer webhook existente
        logger.info("Removendo webhooks existentes...")
        await application.bot.delete_webhook(drop_pending_updates=True)
        logger.info("Webhook removido com sucesso!")
        
        # Inicia o bot com polling
        logger.info("Iniciando o bot com polling...")
        
        # Usando run_polling() diretamente, que j√° gerencia o loop de eventos
        try:
            # Inicia o polling em background
            application.run_polling(drop_pending_updates=True)
        except Exception as e:
            logger.error(f"Erro durante execu√ß√£o do bot: {e}")
            raise
        
        logger.info("Bot em execu√ß√£o! Pressione Ctrl+C para encerrar.")
        
        # O loop de eventos √© gerenciado internamente pelo application.run_polling()
            
    except asyncio.CancelledError:
        logger.info("Recebido sinal de cancelamento. Encerrando...")
        if 'application' in globals() and application:
            await application.stop()
            await application.shutdown()
        raise
    except Exception as e:
        logger.error(f"Erro na fun√ß√£o main_async: {e}", exc_info=True)
        if 'application' in globals() and application:
            await application.stop()
            await application.shutdown()
        raise

def main() -> None:
    """Ponto de entrada principal do bot."""
    logger.info("Iniciando fun√ß√£o main()")
    
    # Configura o loop de eventos
    try:
        # Cria um novo loop de eventos
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Executa a fun√ß√£o main_async at√© a conclus√£o
        loop.run_until_complete(main_async())
        
    except KeyboardInterrupt:
        logger.info("Bot interrompido pelo usu√°rio.")
    except Exception as e:
        logger.error(f"Erro fatal: {e}", exc_info=True)
    finally:
        # Garante que o loop seja fechado corretamente
        try:
            if 'loop' in locals() and loop is not None:
                if loop.is_running():
                    loop.stop()
                if not loop.is_closed():
                    loop.close()
            logger.info("Aplica√ß√£o finalizada com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao finalizar o loop de eventos: {e}", exc_info=True)
        
        # Encerra o processo para garantir que n√£o haja tarefas pendentes
        try:
            import os
            os._exit(0)
        except Exception as e:
            logger.error(f"Erro ao encerrar o processo: {e}", exc_info=True)
            # For√ßa o encerramento
            import sys
            sys.exit(1)

def add_user_category(user_id: int, category: str) -> bool:
    """
    Adiciona uma categoria de interesse para um usu√°rio.
    """
    try:
        if not user_id or not category:
            logger.warning("user_id ou category inv√°lidos em add_user_category")
            return False
            
        if USER_CATEGORIES_AVAILABLE:
            try:
                return category_manager.add_user_category(user_id, category)
            except Exception as e:
                logger.error(f"Erro ao adicionar categoria via category_manager: {e}")
                return False
        return False
    except Exception as e:
        logger.error(f"Erro ao adicionar categoria: {e}")
        return False

def add_favorite_store(user_id: int, store: str) -> bool:
    """
    Adiciona uma loja favorita para um usu√°rio.
    """
    try:
        if NOTIFICATION_SYSTEM_AVAILABLE:
            # Aqui voc√™ pode implementar a l√≥gica para adicionar loja favorita
            # Por enquanto, retorna True para simular sucesso
            return True
        return False
    except Exception as e:
        logger.error(f"Erro ao adicionar loja favorita: {e}")
        return False

def update_user_preferences(user_id: int, **kwargs) -> bool:
    """
    Atualiza as prefer√™ncias de um usu√°rio.
    """
    try:
        if NOTIFICATION_SYSTEM_AVAILABLE:
            # Aqui voc√™ pode implementar a l√≥gica para atualizar prefer√™ncias
            # Por enquanto, retorna True para simular sucesso
            return True
        return False
    except Exception as e:
        logger.error(f"Erro ao atualizar prefer√™ncias: {e}")
        return False

async def error_handler(update: Any, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Manipulador de erros global.
    
    Captura e registra erros n√£o tratados que ocorrem durante o processamento
    de atualiza√ß√µes e callbacks.
    """
    # Log detalhado do erro
    try:
        if context and hasattr(context, 'error'):
            logger.error("=== ERRO NO BOT ===", exc_info=context.error)
        else:
            logger.error("=== ERRO NO BOT ===", exc_info=True)
    except Exception as e:
        logger.error(f"Erro ao registrar erro: {e}")
    
    # Tenta obter informa√ß√µes adicionais sobre o update
    update_info = {}
    try:
        if update is not None:
            # Verifica se √© um Update v√°lido
            if hasattr(update, 'update_id'):
                update_info['update_id'] = update.update_id
            if hasattr(update, 'effective_user') and update.effective_user:
                user = update.effective_user
                if user and hasattr(user, 'id') and user.id:
                    update_info['user_id'] = user.id
                if user and hasattr(user, 'username') and user.username:
                    update_info['username'] = user.username
            if hasattr(update, 'effective_chat') and update.effective_chat:
                chat = update.effective_chat
                if chat and hasattr(chat, 'id') and chat.id:
                    update_info['chat_id'] = chat.id
                if chat and hasattr(chat, 'type') and chat.type:
                    update_info['chat_type'] = chat.type
            if hasattr(update, 'message') and update.message and hasattr(update.message, 'text'):
                message = update.message
                if message and hasattr(message, 'text') and message.text:
                    update_info['message_text'] = message.text[:100]  # Limita o tamanho
    except Exception as e:
        logger.error(f"Erro ao obter informa√ß√µes do update: {e}")
    
    logger.error(f"Informa√ß√µes do update: {update_info}")
    
    # Tenta notificar o administrador em caso de erro
    admin_id = os.getenv('ADMIN_USER_ID')
    if admin_id and context and hasattr(context, 'bot') and context.bot:
        try:
            error_message = (
                f"‚ö†Ô∏è *ERRO NO BOT*\n\n"
                f"*Tipo:* `{type(context.error).__name__ if context and hasattr(context, 'error') else 'Unknown'}`\n"
                f"*Mensagem:* `{str(context.error)[:1000] if context and hasattr(context, 'error') else 'Erro desconhecido'}`\n\n"
                f"*Update:* `{update_info}`"
            )
            
            await context.bot.send_message(
                chat_id=admin_id,
                text=error_message,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True
            )
        except Exception as admin_error:
            logger.error(f"Erro ao notificar administrador: {admin_error}", exc_info=True)

    # Tenta notificar o usu√°rio que causou o erro
    try:
        if update and hasattr(update, 'message') and update.message:
            message = update.message
            if message and hasattr(message, 'reply_text'):
                # Mensagem mais amig√°vel para o usu√°rio
                user_message = (
                    "‚ùå *Ocorreu um erro ao processar sua solicita√ß√£o.*\n\n"
                    "O administrador foi notificado e o problema ser√° resolvido em breve.\n"
                    "Por favor, tente novamente mais tarde."
                )
                
                # Tenta responder √† mensagem original
                await message.reply_text(
                    user_message,
                    parse_mode=ParseMode.MARKDOWN,
                    disable_web_page_preview=True
                )
    except Exception as user_error:
        logger.error(f"Erro ao notificar usu√°rio: {user_error}", exc_info=True)
    
    # Log final
    logger.error("=== FIM DO REGISTRO DE ERRO ===\n")

if __name__ == '__main__':
    main()