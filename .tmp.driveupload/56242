"""
Sistema de Histórico de Preços para Análise de Tendências

Este módulo implementa:
- Rastreamento de preços ao longo do tempo
- Análise de tendências de preços
- Detecção de variações significativas
- Alertas de mudanças de preço
- Estatísticas históricas de preços
"""

import sqlite3
import logging
import statistics
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum

logger = logging.getLogger(__name__)


class PriceChangeType(Enum):
    """Tipos de mudança de preço."""

    INCREASE = "increase"
    DECREASE = "decrease"
    STABLE = "stable"
    FLUCTUATING = "fluctuating"


@dataclass
class PricePoint:
    """Ponto individual de preço no histórico."""

    product_id: str
    store: str
    price: float
    original_price: Optional[float]
    discount_percent: Optional[float]
    currency: str
    timestamp: datetime
    source: str  # scraper, api, manual

    def to_dict(self) -> Dict:
        """Converte para dicionário."""
        data = asdict(self)
        data["timestamp"] = self.timestamp.isoformat()
        return data


@dataclass
class PriceTrend:
    """Análise de tendência de preços."""

    product_id: str
    store: str
    trend_type: PriceChangeType
    current_price: float
    price_change: float
    price_change_percent: float
    avg_price_30d: float
    min_price_30d: float
    max_price_30d: float
    volatility: float  # Desvio padrão
    last_update: datetime
    confidence: float  # 0-1, confiança na tendência

    def to_dict(self) -> Dict:
        """Converte para dicionário."""
        data = asdict(self)
        data["last_update"] = self.last_update.isoformat()
        data["trend_type"] = self.trend_type.value
        return data


@dataclass
class PriceAlert:
    """Alerta de mudança de preço."""

    product_id: str
    store: str
    alert_type: str  # significant_drop, significant_increase, new_low, new_high
    old_price: float
    new_price: float
    change_percent: float
    threshold: float
    timestamp: datetime
    processed: bool

    def to_dict(self) -> Dict:
        """Converte para dicionário."""
        data = asdict(self)
        data["timestamp"] = self.timestamp.isoformat()
        return data


class PriceHistoryManager:
    """Gerenciador de histórico de preços."""

    def __init__(self, db_path: str = "price_history.db"):
        self.db_path = db_path
        self._init_database()
        self.alert_thresholds = {
            "significant_drop": 10.0,  # 10% de queda
            "significant_increase": 15.0,  # 15% de aumento
            "new_low": 5.0,  # 5% abaixo do mínimo histórico
            "new_high": 10.0,  # 10% acima do máximo histórico
        }

    def _init_database(self):
        """Inicializa banco de dados."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                # Tabela de pontos de preço
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS price_points (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        product_id TEXT NOT NULL,
                        store TEXT NOT NULL,
                        price REAL NOT NULL,
                        original_price REAL,
                        discount_percent REAL,
                        currency TEXT DEFAULT 'BRL',
                        timestamp TEXT NOT NULL,
                        source TEXT NOT NULL
                    )
                """)

                # Tabela de tendências de preço
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS price_trends (
                        product_id TEXT NOT NULL,
                        store TEXT NOT NULL,
                        trend_type TEXT NOT NULL,
                        current_price REAL NOT NULL,
                        price_change REAL NOT NULL,
                        price_change_percent REAL NOT NULL,
                        avg_price_30d REAL NOT NULL,
                        min_price_30d REAL NOT NULL,
                        max_price_30d REAL NOT NULL,
                        volatility REAL NOT NULL,
                        last_update TEXT NOT NULL,
                        confidence REAL NOT NULL,
                        PRIMARY KEY (product_id, store)
                    )
                """)

                # Tabela de alertas de preço
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS price_alerts (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        product_id TEXT NOT NULL,
                        store TEXT NOT NULL,
                        alert_type TEXT NOT NULL,
                        old_price REAL NOT NULL,
                        new_price REAL NOT NULL,
                        change_percent REAL NOT NULL,
                        threshold REAL NOT NULL,
                        timestamp TEXT NOT NULL,
                        processed BOOLEAN DEFAULT 0
                    )
                """)

                # Tabela de estatísticas de preço
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS price_stats (
                        product_id TEXT NOT NULL,
                        store TEXT NOT NULL,
                        total_points INTEGER DEFAULT 0,
                        first_price REAL,
                        last_price REAL,
                        min_price REAL,
                        max_price REAL,
                        avg_price REAL,
                        price_variance REAL,
                        last_calculated TEXT,
                        PRIMARY KEY (product_id, store)
                    )
                """)

                # Índices para performance
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_points_product ON price_points(product_id)"
                )
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_points_store ON price_points(store)"
                )
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_points_timestamp ON price_points(timestamp)"
                )
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_trends_product ON price_trends(product_id)"
                )
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_alerts_product ON price_alerts(product_id)"
                )
                conn.execute(
                    "CREATE INDEX IF NOT EXISTS idx_price_alerts_processed ON price_alerts(processed)"
                )

                conn.commit()
                logger.info("Banco de dados de histórico de preços inicializado")
        except Exception as e:
            logger.error(f"Erro ao inicializar banco de dados: {e}")

    def add_price_point(
        self,
        product_id: str,
        store: str,
        price: float,
        original_price: Optional[float] = None,
        discount_percent: Optional[float] = None,
        currency: str = "BRL",
        source: str = "scraper",
    ) -> bool:
        """Adiciona um novo ponto de preço ao histórico."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                now = datetime.now()

                # Insere ponto de preço
                conn.execute(
                    """
                    INSERT INTO price_points 
                    (product_id, store, price, original_price, discount_percent, currency, timestamp, source)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """,
                    (
                        product_id,
                        store,
                        price,
                        original_price,
                        discount_percent,
                        currency,
                        now.isoformat(),
                        source,
                    ),
                )

                # Atualiza estatísticas
                self._update_price_stats(conn, product_id, store)

                # Analisa tendência
                self._analyze_price_trend(conn, product_id, store)

                # Verifica alertas
                self._check_price_alerts(conn, product_id, store, price)

                conn.commit()
                logger.info(
                    f"Ponto de preço adicionado: {product_id} em {store} - R$ {price}"
                )
                return True

        except Exception as e:
            logger.error(f"Erro ao adicionar ponto de preço: {e}")
            return False

    def get_price_history(
        self, product_id: str, store: str, days: int = 30
    ) -> List[PricePoint]:
        """Obtém histórico de preços de um produto."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cutoff_date = datetime.now() - timedelta(days=days)

                cursor = conn.execute(
                    """
                    SELECT product_id, store, price, original_price, discount_percent, currency, timestamp, source
                    FROM price_points 
                    WHERE product_id = ? AND store = ? AND timestamp >= ?
                    ORDER BY timestamp ASC
                """,
                    (product_id, store, cutoff_date.isoformat()),
                )

                points = []
                for row in cursor.fetchall():
                    point = PricePoint(
                        product_id=row[0],
                        store=row[1],
                        price=row[2],
                        original_price=row[3],
                        discount_percent=row[4],
                        currency=row[5],
                        timestamp=datetime.fromisoformat(row[6]),
                        source=row[7],
                    )
                    points.append(point)

                return points

        except Exception as e:
            logger.error(f"Erro ao obter histórico de preços: {e}")
            return []

    def get_price_trend(self, product_id: str, store: str) -> Optional[PriceTrend]:
        """Obtém tendência de preço atual de um produto."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    """
                    SELECT product_id, store, trend_type, current_price, price_change, price_change_percent,
                           avg_price_30d, min_price_30d, max_price_30d, volatility, last_update, confidence
                    FROM price_trends 
                    WHERE product_id = ? AND store = ?
                """,
                    (product_id, store),
                )

                row = cursor.fetchone()
                if row:
                    trend = PriceTrend(
                        product_id=row[0],
                        store=row[1],
                        trend_type=PriceChangeType(row[2]),
                        current_price=row[3],
                        price_change=row[4],
                        price_change_percent=row[5],
                        avg_price_30d=row[6],
                        min_price_30d=row[7],
                        max_price_30d=row[8],
                        volatility=row[9],
                        last_update=datetime.fromisoformat(row[10]),
                        confidence=row[11],
                    )
                    return trend

                return None

        except Exception as e:
            logger.error(f"Erro ao obter tendência de preço: {e}")
            return None

    def get_all_price_trends(self, limit: int = 100) -> List[PriceTrend]:
        """Obtém todas as tendências de preço."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    """
                    SELECT product_id, store, trend_type, current_price, price_change, price_change_percent,
                           avg_price_30d, min_price_30d, max_price_30d, volatility, last_update, confidence
                    FROM price_trends 
                    ORDER BY last_update DESC
                    LIMIT ?
                """,
                    (limit,),
                )

                trends = []
                for row in cursor.fetchall():
                    trend = PriceTrend(
                        product_id=row[0],
                        store=row[1],
                        trend_type=PriceChangeType(row[2]),
                        current_price=row[3],
                        price_change=row[4],
                        price_change_percent=row[5],
                        avg_price_30d=row[6],
                        min_price_30d=row[7],
                        max_price_30d=row[8],
                        volatility=row[9],
                        last_update=datetime.fromisoformat(row[10]),
                        confidence=row[11],
                    )
                    trends.append(trend)

                return trends

        except Exception as e:
            logger.error(f"Erro ao obter tendências de preço: {e}")
            return []

    def get_unprocessed_alerts(self, limit: int = 50) -> List[PriceAlert]:
        """Obtém alertas não processados."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    """
                    SELECT product_id, store, alert_type, old_price, new_price, change_percent, threshold, timestamp, processed
                    FROM price_alerts 
                    WHERE processed = 0
                    ORDER BY timestamp DESC
                    LIMIT ?
                """,
                    (limit,),
                )

                alerts = []
                for row in cursor.fetchall():
                    alert = PriceAlert(
                        product_id=row[0],
                        store=row[1],
                        alert_type=row[2],
                        old_price=row[3],
                        new_price=row[4],
                        change_percent=row[5],
                        threshold=row[6],
                        timestamp=datetime.fromisoformat(row[7]),
                        processed=bool(row[8]),
                    )
                    alerts.append(alert)

                return alerts

        except Exception as e:
            logger.error(f"Erro ao obter alertas: {e}")
            return []

    def mark_alert_processed(self, alert_id: int) -> bool:
        """Marca um alerta como processado."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    "UPDATE price_alerts SET processed = 1 WHERE id = ?", (alert_id,)
                )
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"Erro ao marcar alerta como processado: {e}")
            return False

    def _update_price_stats(
        self, conn: sqlite3.Connection, product_id: str, store: str
    ):
        """Atualiza estatísticas de preço de um produto."""
        try:
            # Obtém todos os pontos de preço
            cursor = conn.execute(
                """
                SELECT price FROM price_points 
                WHERE product_id = ? AND store = ?
                ORDER BY timestamp DESC
            """,
                (product_id, store),
            )

            prices = [row[0] for row in cursor.fetchall()]

            if not prices:
                return

            # Calcula estatísticas
            total_points = len(prices)
            first_price = prices[-1]  # Primeiro preço (mais antigo)
            last_price = prices[0]  # Último preço (mais recente)
            min_price = min(prices)
            max_price = max(prices)
            avg_price = statistics.mean(prices)

            # Calcula variância
            if len(prices) > 1:
                price_variance = statistics.variance(prices)
            else:
                price_variance = 0.0

            # Insere ou atualiza estatísticas
            conn.execute(
                """
                INSERT OR REPLACE INTO price_stats 
                (product_id, store, total_points, first_price, last_price, min_price, max_price, avg_price, price_variance, last_calculated)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    product_id,
                    store,
                    total_points,
                    first_price,
                    last_price,
                    min_price,
                    max_price,
                    avg_price,
                    price_variance,
                    datetime.now().isoformat(),
                ),
            )

        except Exception as e:
            logger.error(f"Erro ao atualizar estatísticas de preço: {e}")

    def _analyze_price_trend(
        self, conn: sqlite3.Connection, product_id: str, store: str
    ):
        """Analisa tendência de preço de um produto."""
        try:
            # Obtém preços dos últimos 30 dias
            cutoff_date = datetime.now() - timedelta(days=30)

            cursor = conn.execute(
                """
                SELECT price, timestamp FROM price_points 
                WHERE product_id = ? AND store = ? AND timestamp >= ?
                ORDER BY timestamp ASC
            """,
                (product_id, store, cutoff_date.isoformat()),
            )

            price_data = [
                (row[0], datetime.fromisoformat(row[1])) for row in cursor.fetchall()
            ]

            if len(price_data) < 2:
                return

            # Separa preços e timestamps
            prices = [p[0] for p in price_data]
            timestamps = [p[1] for p in price_data]

            # Calcula estatísticas
            current_price = prices[-1]
            avg_price_30d = statistics.mean(prices)
            min_price_30d = min(prices)
            max_price_30d = max(prices)

            # Calcula mudança de preço
            price_change = current_price - prices[0]
            price_change_percent = (
                ((current_price - prices[0]) / prices[0]) * 100 if prices[0] > 0 else 0
            )

            # Calcula volatilidade (desvio padrão)
            volatility = statistics.stdev(prices) if len(prices) > 1 else 0.0

            # Determina tipo de tendência
            if price_change_percent > 5:
                trend_type = PriceChangeType.INCREASE
            elif price_change_percent < -5:
                trend_type = PriceChangeType.DECREASE
            elif volatility > avg_price_30d * 0.1:  # 10% de volatilidade
                trend_type = PriceChangeType.FLUCTUATING
            else:
                trend_type = PriceChangeType.STABLE

            # Calcula confiança baseada na quantidade de dados
            confidence = min(1.0, len(prices) / 30.0)

            # Insere ou atualiza tendência
            conn.execute(
                """
                INSERT OR REPLACE INTO price_trends 
                (product_id, store, trend_type, current_price, price_change, price_change_percent,
                 avg_price_30d, min_price_30d, max_price_30d, volatility, last_update, confidence)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    product_id,
                    store,
                    trend_type.value,
                    current_price,
                    price_change,
                    price_change_percent,
                    avg_price_30d,
                    min_price_30d,
                    max_price_30d,
                    volatility,
                    datetime.now().isoformat(),
                    confidence,
                ),
            )

        except Exception as e:
            logger.error(f"Erro ao analisar tendência de preço: {e}")

    def _check_price_alerts(
        self, conn: sqlite3.Connection, product_id: str, store: str, new_price: float
    ):
        """Verifica se há alertas de preço para disparar."""
        try:
            # Obtém último preço anterior
            cursor = conn.execute(
                """
                SELECT price FROM price_points 
                WHERE product_id = ? AND store = ? AND timestamp < ?
                ORDER BY timestamp DESC
                LIMIT 1
            """,
                (product_id, store, datetime.now().isoformat()),
            )

            last_price_row = cursor.fetchone()
            if not last_price_row:
                return

            old_price = last_price_row[0]
            change_percent = (
                ((new_price - old_price) / old_price) * 100 if old_price > 0 else 0
            )

            # Verifica alertas
            alerts_to_create = []

            # Queda significativa
            if change_percent <= -self.alert_thresholds["significant_drop"]:
                alerts_to_create.append(
                    (
                        "significant_drop",
                        change_percent,
                        self.alert_thresholds["significant_drop"],
                    )
                )

            # Aumento significativo
            if change_percent >= self.alert_thresholds["significant_increase"]:
                alerts_to_create.append(
                    (
                        "significant_increase",
                        change_percent,
                        self.alert_thresholds["significant_increase"],
                    )
                )

            # Novo mínimo histórico
            cursor = conn.execute(
                "SELECT min_price FROM price_stats WHERE product_id = ? AND store = ?",
                (product_id, store),
            )
            min_price_row = cursor.fetchone()
            if min_price_row and new_price < min_price_row[0]:
                min_change = ((new_price - min_price_row[0]) / min_price_row[0]) * 100
                if min_change <= -self.alert_thresholds["new_low"]:
                    alerts_to_create.append(
                        ("new_low", min_change, self.alert_thresholds["new_low"])
                    )

            # Novo máximo histórico
            cursor = conn.execute(
                "SELECT max_price FROM price_stats WHERE product_id = ? AND store = ?",
                (product_id, store),
            )
            max_price_row = cursor.fetchone()
            if max_price_row and new_price > max_price_row[0]:
                max_change = ((new_price - max_price_row[0]) / max_price_row[0]) * 100
                if max_change >= self.alert_thresholds["new_high"]:
                    alerts_to_create.append(
                        ("new_high", max_change, self.alert_thresholds["new_high"])
                    )

            # Cria alertas
            for alert_type, change, threshold in alerts_to_create:
                conn.execute(
                    """
                    INSERT INTO price_alerts 
                    (product_id, store, alert_type, old_price, new_price, change_percent, threshold, timestamp, processed)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0)
                """,
                    (
                        product_id,
                        store,
                        alert_type,
                        old_price,
                        new_price,
                        change,
                        threshold,
                        datetime.now().isoformat(),
                    ),
                )

        except Exception as e:
            logger.error(f"Erro ao verificar alertas de preço: {e}")

    def get_price_analysis(
        self, product_id: str, store: str, days: int = 30
    ) -> Dict[str, Any]:
        """Obtém análise completa de preços de um produto."""
        try:
            # Obtém histórico
            history = self.get_price_history(product_id, store, days)

            # Obtém tendência
            trend = self.get_price_trend(product_id, store)

            # Obtém estatísticas
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute(
                    """
                    SELECT total_points, first_price, last_price, min_price, max_price, avg_price, price_variance
                    FROM price_stats WHERE product_id = ? AND store = ?
                """,
                    (product_id, store),
                )
                stats_row = cursor.fetchone()

                stats = {}
                if stats_row:
                    stats = {
                        "total_points": stats_row[0],
                        "first_price": stats_row[1],
                        "last_price": stats_row[2],
                        "min_price": stats_row[3],
                        "max_price": stats_row[4],
                        "avg_price": stats_row[5],
                        "price_variance": stats_row[6],
                    }

            # Calcula análise adicional
            analysis = {
                "product_id": product_id,
                "store": store,
                "analysis_period_days": days,
                "total_price_points": len(history),
                "price_history": [point.to_dict() for point in history],
                "trend": trend.to_dict() if trend else None,
                "statistics": stats,
                "price_range": {
                    "min": min([p.price for p in history]) if history else 0,
                    "max": max([p.price for p in history]) if history else 0,
                    "current": history[-1].price if history else 0,
                }
                if history
                else {},
                "volatility_analysis": self._calculate_volatility_analysis(history),
                "seasonal_patterns": self._detect_seasonal_patterns(history),
                "last_updated": datetime.now().isoformat(),
            }

            return analysis

        except Exception as e:
            logger.error(f"Erro ao obter análise de preços: {e}")
            return {"error": str(e)}

    def _calculate_volatility_analysis(
        self, history: List[PricePoint]
    ) -> Dict[str, Any]:
        """Calcula análise de volatilidade dos preços."""
        if len(history) < 2:
            return {"volatility": 0, "stability_score": 0, "price_swings": 0}

        prices = [p.price for p in history]

        # Calcula mudanças percentuais
        changes = []
        for i in range(1, len(prices)):
            change = ((prices[i] - prices[i - 1]) / prices[i - 1]) * 100
            changes.append(change)

        # Análise de volatilidade
        volatility = statistics.stdev(changes) if len(changes) > 1 else 0
        stability_score = max(0, 100 - (volatility * 10))  # Score de 0-100

        # Conta mudanças significativas (>5%)
        significant_changes = sum(1 for c in changes if abs(c) > 5)

        return {
            "volatility": round(volatility, 2),
            "stability_score": round(stability_score, 1),
            "price_swings": significant_changes,
            "avg_change": round(statistics.mean(changes), 2),
            "max_change": round(max(changes, key=abs), 2) if changes else 0,
        }

    def _detect_seasonal_patterns(self, history: List[PricePoint]) -> Dict[str, Any]:
        """Detecta padrões sazonais nos preços."""
        if len(history) < 30:  # Precisa de pelo menos 30 dias
            return {"has_seasonal_pattern": False, "confidence": 0}

        # Agrupa por dia da semana
        weekday_prices = {}
        for point in history:
            weekday = point.timestamp.weekday()
            if weekday not in weekday_prices:
                weekday_prices[weekday] = []
            weekday_prices[weekday].append(point.price)

        # Calcula preço médio por dia da semana
        weekday_avgs = {}
        for weekday, prices in weekday_prices.items():
            weekday_avgs[weekday] = statistics.mean(prices)

        # Verifica se há variação significativa entre dias
        if len(weekday_avgs) > 1:
            avg_price = statistics.mean(weekday_avgs.values())
            weekday_variance = (
                statistics.variance(weekday_avgs.values())
                if len(weekday_avgs) > 1
                else 0
            )
            weekday_volatility = (
                (weekday_variance**0.5) / avg_price if avg_price > 0 else 0
            )

            has_pattern = weekday_volatility > 0.05  # 5% de variação
            confidence = min(1.0, weekday_volatility * 20)  # Converte para 0-1

            return {
                "has_seasonal_pattern": has_pattern,
                "confidence": round(confidence, 2),
                "weekday_variation": round(weekday_volatility * 100, 1),
                "best_day_to_buy": min(weekday_avgs.items(), key=lambda x: x[1])[0],
                "worst_day_to_buy": max(weekday_avgs.items(), key=lambda x: x[1])[0],
            }

        return {"has_seasonal_pattern": False, "confidence": 0}

    def get_products_with_significant_changes(
        self, days: int = 7, min_change_percent: float = 10.0
    ) -> List[Dict[str, Any]]:
        """Obtém produtos com mudanças significativas de preço."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cutoff_date = datetime.now() - timedelta(days=days)

                cursor = conn.execute(
                    """
                    SELECT 
                        p1.product_id, p1.store, p1.price as current_price, p1.timestamp as current_time,
                        p2.price as previous_price, p2.timestamp as previous_time
                    FROM price_points p1
                    JOIN price_points p2 ON p1.product_id = p2.product_id AND p1.store = p2.store
                    WHERE p1.timestamp >= ? 
                    AND p2.timestamp < p1.timestamp
                    AND p2.timestamp = (
                        SELECT MAX(timestamp) FROM price_points p3 
                        WHERE p3.product_id = p1.product_id 
                        AND p3.store = p1.store 
                        AND p3.timestamp < p1.timestamp
                    )
                """,
                    (cutoff_date.isoformat(),),
                )

                significant_changes = []
                for row in cursor.fetchall():
                    change_percent = (
                        ((row[2] - row[4]) / row[4]) * 100 if row[4] > 0 else 0
                    )

                    if abs(change_percent) >= min_change_percent:
                        significant_changes.append(
                            {
                                "product_id": row[0],
                                "store": row[1],
                                "current_price": row[2],
                                "previous_price": row[4],
                                "change_percent": round(change_percent, 2),
                                "change_type": "increase"
                                if change_percent > 0
                                else "decrease",
                                "current_time": row[3],
                                "previous_time": row[5],
                            }
                        )

                # Ordena por mudança percentual
                significant_changes.sort(
                    key=lambda x: abs(x["change_percent"]), reverse=True
                )
                return significant_changes

        except Exception as e:
            logger.error(f"Erro ao obter produtos com mudanças significativas: {e}")
            return []


# Instância global do gerenciador
price_history_manager = PriceHistoryManager()


# Funções de conveniência
def add_price_point(product_id: str, store: str, price: float, **kwargs) -> bool:
    """Adiciona ponto de preço."""
    return price_history_manager.add_price_point(product_id, store, price, **kwargs)


def get_price_history(product_id: str, store: str, days: int = 30) -> List[PricePoint]:
    """Obtém histórico de preços."""
    return price_history_manager.get_price_history(product_id, store, days)


def get_price_trend(product_id: str, store: str) -> Optional[PriceTrend]:
    """Obtém tendência de preço."""
    return price_history_manager.get_price_trend(product_id, store)


def get_price_analysis(product_id: str, store: str, days: int = 30) -> Dict[str, Any]:
    """Obtém análise completa de preços."""
    return price_history_manager.get_price_analysis(product_id, store, days)


if __name__ == "__main__":
    # Teste do sistema de histórico de preços
    import logging

    logging.basicConfig(level=logging.INFO)

    print("Testando Sistema de Histórico de Preços...")

    # Testa adição de pontos de preço
    product_id = "test_product_123"
    store = "amazon"

    # Simula histórico de preços
    prices = [100, 95, 110, 105, 90, 85, 95, 100, 105, 110]
    for i, price in enumerate(prices):
        timestamp = datetime.now() - timedelta(days=len(prices) - i)
        add_price_point(product_id, store, price, source="test")

    # Obtém análise
    analysis = get_price_analysis(product_id, store, 30)
    print(f"Análise de preços: {analysis.get('total_price_points', 0)} pontos")

    # Obtém tendência
    trend = get_price_trend(product_id, store)
    if trend:
        print(
            f"Tendência: {trend.trend_type.value}, Mudança: {trend.price_change_percent:.1f}%"
        )

    print("Teste concluído!")
