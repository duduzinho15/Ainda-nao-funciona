#!/usr/bin/env python3
"""
Aplicativo Desktop Completo para Sistema Inteligente de Alertas Geek
Interface gr√°fica completa com controles visuais
"""

import sys
import os
import threading
import asyncio
import logging
from datetime import datetime
import tkinter as tk
from tkinter import messagebox, ttk, scrolledtext
import queue
import json

# Adiciona o diret√≥rio atual ao path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Importa o sistema inteligente
from intelligent_geek_alert_system import IntelligentGeekAlertSystem

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("geek_alert_desktop.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)


class GeekAlertDesktopApp:
    """Aplicativo Desktop Completo para Sistema Inteligente de Alertas"""

    def __init__(self):
        self.root = tk.Tk()
        self.setup_main_window()

        # Vari√°veis do sistema
        self.running = False
        self.alert_system = None
        self.alert_thread = None
        self.log_queue = queue.Queue()
        self.stats = {
            "total_alerts": 0,
            "total_products": 0,
            "search_cycles": 0,
            "last_alert": None,
            "status": "Parado",
        }

        # Configura√ß√µes
        self.config = self.load_config()

        # Cria interface
        self.create_widgets()

        # Atualiza logs periodicamente
        self.update_logs()

    def setup_main_window(self):
        """Configura a janela principal"""
        self.root.title("üöÄ Sistema Inteligente de Alertas Geek")
        self.root.geometry("900x700")
        self.root.resizable(True, True)

        # √çcone da janela (se dispon√≠vel)
        try:
            self.root.iconbitmap("geek_icon.ico")
        except:
            pass

        # Centraliza a janela
        self.center_window()

        # Configura grid principal
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(1, weight=1)

    def center_window(self):
        """Centraliza a janela na tela"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")

    def create_widgets(self):
        """Cria todos os widgets da interface"""
        # Frame lateral esquerdo
        self.create_left_panel()

        # Frame principal direito
        self.create_main_panel()

        # Barra de status
        self.create_status_bar()

    def create_left_panel(self):
        """Cria painel lateral esquerdo com controles"""
        left_frame = ttk.Frame(self.root, padding="10")
        left_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        left_frame.grid_rowconfigure(8, weight=1)

        # T√≠tulo
        title_label = tk.Label(
            left_frame, text="üéÆ CONTROLES", font=("Arial", 14, "bold")
        )
        title_label.grid(row=0, column=0, pady=(0, 20), sticky="ew")

        # Bot√£o Iniciar
        self.start_btn = tk.Button(
            left_frame,
            text="üöÄ INICIAR SISTEMA",
            command=self.start_system,
            font=("Arial", 12, "bold"),
            bg="green",
            fg="white",
            height=2,
        )
        self.start_btn.grid(row=1, column=0, pady=10, sticky="ew")

        # Bot√£o Parar
        self.stop_btn = tk.Button(
            left_frame,
            text="‚èπÔ∏è PARAR SISTEMA",
            command=self.stop_system,
            font=("Arial", 12, "bold"),
            bg="red",
            fg="white",
            height=2,
            state="disabled",
        )
        self.stop_btn.grid(row=2, column=0, pady=10, sticky="ew")

        # Separador
        separator1 = ttk.Separator(left_frame, orient="horizontal")
        separator1.grid(row=3, column=0, pady=20, sticky="ew")

        # Bot√£o Estat√≠sticas
        stats_btn = tk.Button(
            left_frame,
            text="üìä ESTAT√çSTICAS",
            command=self.show_stats_window,
            font=("Arial", 11),
            height=2,
        )
        stats_btn.grid(row=4, column=0, pady=5, sticky="ew")

        # Bot√£o Configura√ß√µes
        config_btn = tk.Button(
            left_frame,
            text="‚öôÔ∏è CONFIGURA√á√ïES",
            command=self.show_config_window,
            font=("Arial", 11),
            height=2,
        )
        config_btn.grid(row=5, column=0, pady=5, sticky="ew")

        # Bot√£o Limpar Logs
        clear_btn = tk.Button(
            left_frame,
            text="üßπ LIMPAR LOGS",
            command=self.clear_logs,
            font=("Arial", 11),
            height=2,
        )
        clear_btn.grid(row=6, column=0, pady=5, sticky="ew")

        # Separador
        separator2 = ttk.Separator(left_frame, orient="horizontal")
        separator2.grid(row=7, column=0, pady=20, sticky="ew")

        # Status do sistema
        status_frame = ttk.LabelFrame(
            left_frame, text="üì° Status do Sistema", padding="10"
        )
        status_frame.grid(row=8, column=0, sticky="ew", pady=10)

        self.status_label = tk.Label(
            status_frame, text="‚èπÔ∏è PARADO", font=("Arial", 12, "bold"), fg="red"
        )
        self.status_label.pack()

        # Informa√ß√µes r√°pidas
        info_frame = ttk.LabelFrame(left_frame, text="üìä Info R√°pida", padding="10")
        info_frame.grid(row=9, column=0, sticky="ew", pady=10)

        self.quick_stats_label = tk.Label(
            info_frame, text="Nenhuma atividade", font=("Arial", 9)
        )
        self.quick_stats_label.pack()

    def create_main_panel(self):
        """Cria painel principal direito"""
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        main_frame.grid_rowconfigure(1, weight=1)
        main_frame.grid_columnconfigure(0, weight=1)

        # T√≠tulo principal
        main_title = tk.Label(
            main_frame,
            text="üöÄ SISTEMA INTELIGENTE DE ALERTAS GEEK",
            font=("Arial", 16, "bold"),
        )
        main_title.grid(row=0, column=0, pady=(0, 20))

        # Notebook com abas
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, sticky="nsew")

        # Aba de Logs
        self.create_logs_tab()

        # Aba de Configura√ß√µes
        self.create_config_tab()

        # Aba de Estat√≠sticas
        self.create_stats_tab()

    def create_logs_tab(self):
        """Cria aba de logs"""
        logs_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(logs_frame, text="üìù Logs em Tempo Real")

        # Controles de log
        log_controls = ttk.Frame(logs_frame)
        log_controls.pack(fill="x", pady=(0, 10))

        # Checkbox para auto-scroll
        self.auto_scroll_var = tk.BooleanVar(value=True)
        auto_scroll_cb = ttk.Checkbutton(
            logs_frame, text="Auto-scroll", variable=self.auto_scroll_var
        )
        auto_scroll_cb.pack(side="left")

        # Bot√£o limpar logs
        clear_logs_btn = tk.Button(
            logs_frame, text="üßπ Limpar", command=self.clear_logs_display
        )
        clear_logs_btn.pack(side="right")

        # √Årea de logs
        self.logs_text = scrolledtext.ScrolledText(
            logs_frame, height=20, font=("Consolas", 9)
        )
        self.logs_text.pack(fill="both", expand=True)

        # Carrega logs existentes
        self.load_existing_logs()

    def create_config_tab(self):
        """Cria aba de configura√ß√µes"""
        config_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(config_frame, text="‚öôÔ∏è Configura√ß√µes")

        # Frame para configura√ß√µes
        config_inner = ttk.Frame(config_frame)
        config_inner.pack(fill="both", expand=True)

        # Configura√ß√µes principais
        config_data = [
            ("üîç Intervalo de Busca (minutos)", "search_interval", "5"),
            ("üí∞ Desconto M√≠nimo (%)", "discount_threshold", "15"),
            ("üí∏ Comiss√£o M√≠nima (%)", "commission_threshold", "10"),
            (
                "üì± Chat ID do Telegram",
                "telegram_chat_id",
                self.config.get("telegram_chat_id", ""),
            ),
            (
                "ü§ñ Token do Bot",
                "telegram_bot_token",
                self.config.get("telegram_bot_token", ""),
            ),
            ("üîÑ M√°ximo de Produtos por Busca", "max_products", "20"),
            ("‚è∞ Cooldown entre Alertas (horas)", "alert_cooldown", "6"),
        ]

        self.config_vars = {}
        for i, (label, key, default_value) in enumerate(config_data):
            row = i

            label_widget = tk.Label(
                config_inner, text=label, font=("Arial", 10, "bold")
            )
            label_widget.grid(row=row, column=0, sticky="w", padx=10, pady=5)

            var = tk.StringVar(value=default_value)
            self.config_vars[key] = var

            entry_widget = tk.Entry(
                config_inner, textvariable=var, font=("Arial", 10), width=30
            )
            entry_widget.grid(row=row, column=1, sticky="ew", padx=10, pady=5)

        # Configura grid
        config_inner.columnconfigure(1, weight=1)

        # Bot√µes
        button_frame = tk.Frame(config_frame)
        button_frame.pack(pady=20)

        save_btn = tk.Button(
            button_frame,
            text="üíæ Salvar Configura√ß√µes",
            command=self.save_config,
            font=("Arial", 12),
        )
        save_btn.pack(side="left", padx=10)

        reset_btn = tk.Button(
            button_frame,
            text="üîÑ Resetar",
            command=self.reset_config,
            font=("Arial", 12),
        )
        reset_btn.pack(side="left", padx=10)

    def create_stats_tab(self):
        """Cria aba de estat√≠sticas"""
        stats_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(stats_frame, text="üìä Estat√≠sticas")

        # Frame para estat√≠sticas
        stats_inner = ttk.Frame(stats_frame)
        stats_inner.pack(fill="both", expand=True)

        # Estat√≠sticas principais
        stats_data = [
            ("üöÄ Status do Sistema", "status"),
            ("üì¢ Total de Alertas", "total_alerts"),
            ("üîç Produtos Analisados", "total_products"),
            ("üîÑ Ciclos de Busca", "search_cycles"),
            ("‚è∞ √öltimo Alerta", "last_alert"),
            ("üí∞ Produtos com Desconto", "products_with_discount"),
            ("üí∏ Comiss√£o Total", "total_commission"),
        ]

        self.stats_vars = {}
        for i, (label, key) in enumerate(stats_data):
            row = i // 2
            col = i % 2

            label_widget = tk.Label(stats_inner, text=label, font=("Arial", 10, "bold"))
            label_widget.grid(row=row, column=col * 2, sticky="w", padx=10, pady=5)

            var = tk.StringVar(value="0")
            self.stats_vars[key] = var

            value_widget = tk.Label(stats_inner, textvariable=var, font=("Arial", 10))
            value_widget.grid(row=row, column=col * 2 + 1, sticky="w", padx=10, pady=5)

        # Configura grid
        stats_inner.columnconfigure(1, weight=1)
        stats_inner.columnconfigure(3, weight=1)

        # Bot√£o atualizar estat√≠sticas
        refresh_btn = tk.Button(
            stats_frame,
            text="üîÑ Atualizar Estat√≠sticas",
            command=self.refresh_stats,
            font=("Arial", 12),
        )
        refresh_btn.pack(pady=20)

    def create_status_bar(self):
        """Cria barra de status"""
        status_bar = ttk.Frame(self.root)
        status_bar.grid(row=1, column=0, columnspan=2, sticky="ew", padx=5, pady=2)

        # Status do sistema
        self.status_bar_label = tk.Label(
            status_bar, text="Sistema Parado", font=("Arial", 9)
        )
        self.status_bar_label.pack(side="left")

        # Tempo de execu√ß√£o
        self.uptime_label = tk.Label(status_bar, text="", font=("Arial", 9))
        self.uptime_label.pack(side="right")

        # Atualiza tempo de execu√ß√£o
        self.update_uptime()

    def start_system(self):
        """Inicia o sistema de alertas"""
        try:
            if self.running:
                messagebox.showinfo("Sistema", "Sistema j√° est√° rodando!")
                return

            logger.info("üöÄ Iniciando Sistema Inteligente de Alertas...")
            self.stats["status"] = "Rodando"

            # Atualiza interface
            self.status_label.config(text="üöÄ RODANDO", fg="green")
            self.status_bar_label.config(text="Sistema Rodando - Buscando ofertas...")
            self.start_btn.config(state="disabled")
            self.stop_btn.config(state="normal")

            # Inicia o sistema em thread separada
            self.alert_thread = threading.Thread(target=self.run_alert_system)
            self.alert_thread.daemon = True
            self.alert_thread.start()

            self.running = True
            self.start_time = datetime.now()

            # Mostra notifica√ß√£o
            messagebox.showinfo(
                "Sistema Iniciado", "Sistema de Alertas Geek est√° rodando!"
            )

            logger.info("‚úÖ Sistema iniciado com sucesso")

        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar sistema: {e}")
            messagebox.showerror("Erro", f"Erro ao iniciar sistema: {e}")

    def stop_system(self):
        """Para o sistema de alertas"""
        try:
            if not self.running:
                messagebox.showinfo("Sistema", "Sistema n√£o est√° rodando!")
                return

            logger.info("‚èπÔ∏è Parando Sistema Inteligente de Alertas...")
            self.stats["status"] = "Parado"

            # Para o sistema
            if self.alert_system:
                self.alert_system.stop()

            self.running = False

            # Atualiza interface
            self.status_label.config(text="‚èπÔ∏è PARADO", fg="red")
            self.status_bar_label.config(text="Sistema Parado")
            self.start_btn.config(state="normal")
            self.stop_btn.config(state="disabled")

            # Mostra notifica√ß√£o
            messagebox.showinfo("Sistema Parado", "Sistema de Alertas Geek foi parado!")

            logger.info("‚úÖ Sistema parado com sucesso")

        except Exception as e:
            logger.error(f"‚ùå Erro ao parar sistema: {e}")
            messagebox.showerror("Erro", f"Erro ao parar sistema: {e}")

    def run_alert_system(self):
        """Executa o sistema de alertas em thread separada"""
        try:
            logger.info("üéØ Executando Sistema Inteligente de Alertas...")

            # Cria e executa o sistema
            self.alert_system = IntelligentGeekAlertSystem()

            # Executa o sistema de forma s√≠ncrona
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            try:
                loop.run_until_complete(self.alert_system.run_continuous_search())
            finally:
                loop.close()

        except Exception as e:
            logger.error(f"‚ùå Erro no sistema de alertas: {e}")
            self.running = False
            self.stats["status"] = "Erro"

            # Atualiza interface na thread principal
            self.root.after(0, self.handle_system_error, str(e))

    def handle_system_error(self, error_msg):
        """Manipula erros do sistema na thread principal"""
        self.status_label.config(text="‚ùå ERRO", fg="red")
        self.status_bar_label.config(text=f"Erro: {error_msg}")
        self.start_btn.config(state="normal")
        self.stop_btn.config(state="disabled")
        messagebox.showerror("Erro do Sistema", f"Erro no sistema: {error_msg}")

    def show_stats_window(self):
        """Mostra janela de estat√≠sticas"""
        try:
            # Cria janela de estat√≠sticas
            stats_window = tk.Toplevel(self.root)
            stats_window.title("üìä Estat√≠sticas Detalhadas")
            stats_window.geometry("500x400")
            stats_window.resizable(False, False)

            # Centraliza a janela
            stats_window.transient(self.root)
            stats_window.grab_set()

            # T√≠tulo
            title_label = tk.Label(
                stats_window,
                text="üìä ESTAT√çSTICAS DETALHADAS",
                font=("Arial", 16, "bold"),
            )
            title_label.pack(pady=20)

            # Estat√≠sticas
            stats_text = scrolledtext.ScrolledText(
                stats_window, height=15, font=("Consolas", 10)
            )
            stats_text.pack(pady=20, padx=20, fill="both", expand=True)

            # Carrega estat√≠sticas
            stats_content = self.get_detailed_stats()
            stats_text.insert(tk.END, stats_content)

            # Bot√£o fechar
            close_btn = tk.Button(
                stats_window,
                text="‚ùå Fechar",
                command=stats_window.destroy,
                font=("Arial", 12),
            )
            close_btn.pack(pady=20)

        except Exception as e:
            logger.error(f"‚ùå Erro ao mostrar estat√≠sticas: {e}")
            messagebox.showerror("Erro", f"Erro ao mostrar estat√≠sticas: {e}")

    def show_config_window(self):
        """Mostra janela de configura√ß√µes"""
        # Seleciona a aba de configura√ß√µes
        self.notebook.select(1)

    def get_detailed_stats(self):
        """Obt√©m estat√≠sticas detalhadas"""
        try:
            stats = {
                "Status do Sistema": self.stats["status"],
                "Total de Alertas": self.stats["total_alerts"],
                "Produtos Analisados": self.stats["total_products"],
                "Ciclos de Busca": self.stats["search_cycles"],
                "√öltimo Alerta": str(self.stats["last_alert"])
                if self.stats["last_alert"]
                else "Nenhum",
                "Tempo de Execu√ß√£o": str(datetime.now() - self.start_time)
                if hasattr(self, "start_time")
                else "N/A",
            }

            content = "üìä ESTAT√çSTICAS DO SISTEMA\n"
            content += "=" * 40 + "\n\n"

            for key, value in stats.items():
                content += f"{key}: {value}\n"

            return content

        except Exception as e:
            return f"Erro ao obter estat√≠sticas: {e}"

    def refresh_stats(self):
        """Atualiza estat√≠sticas"""
        try:
            # Atualiza vari√°veis de estat√≠sticas
            for key, var in self.stats_vars.items():
                if key in self.stats:
                    var.set(str(self.stats[key]))
                else:
                    var.set("0")

            # Atualiza estat√≠sticas r√°pidas
            self.update_quick_stats()

        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar estat√≠sticas: {e}")

    def update_quick_stats(self):
        """Atualiza estat√≠sticas r√°pidas"""
        try:
            if self.running:
                status_text = f"üîÑ {self.stats['search_cycles']} ciclos ‚Ä¢ üì¢ {self.stats['total_alerts']} alertas"
            else:
                status_text = "Sistema parado"

            self.quick_stats_label.config(text=status_text)

        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar estat√≠sticas r√°pidas: {e}")

    def update_logs(self):
        """Atualiza logs em tempo real"""
        try:
            # Verifica se h√° novos logs
            try:
                with open("geek_alert_desktop.log", "r", encoding="utf-8") as f:
                    content = f.read()

                    # Atualiza apenas se o conte√∫do mudou
                    if (
                        hasattr(self, "last_log_content")
                        and self.last_log_content == content
                    ):
                        pass
                    else:
                        self.logs_text.delete(1.0, tk.END)
                        self.logs_text.insert(tk.END, content)

                        # Auto-scroll se habilitado
                        if self.auto_scroll_var.get():
                            self.logs_text.see(tk.END)

                        self.last_log_content = content

            except FileNotFoundError:
                pass

            # Atualiza estat√≠sticas
            self.refresh_stats()

            # Agenda pr√≥xima atualiza√ß√£o
            self.root.after(1000, self.update_logs)

        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar logs: {e}")

    def load_existing_logs(self):
        """Carrega logs existentes"""
        try:
            with open("geek_alert_desktop.log", "r", encoding="utf-8") as f:
                content = f.read()
                self.logs_text.insert(tk.END, content)
                self.logs_text.see(tk.END)
        except FileNotFoundError:
            self.logs_text.insert(tk.END, "Nenhum log encontrado ainda.\n")

    def clear_logs_display(self):
        """Limpa display de logs"""
        self.logs_text.delete(1.0, tk.END)
        self.logs_text.insert(tk.END, "Logs limpos.\n")

    def clear_logs(self):
        """Limpa arquivo de logs"""
        try:
            with open("geek_alert_desktop.log", "w", encoding="utf-8") as f:
                f.write("")

            self.clear_logs_display()
            messagebox.showinfo("Logs", "Logs limpos com sucesso!")

        except Exception as e:
            logger.error(f"‚ùå Erro ao limpar logs: {e}")
            messagebox.showerror("Erro", f"Erro ao limpar logs: {e}")

    def load_config(self):
        """Carrega configura√ß√µes do arquivo"""
        try:
            if os.path.exists("geek_alert_config.json"):
                with open("geek_alert_config.json", "r", encoding="utf-8") as f:
                    return json.load(f)
            else:
                return {}
        except Exception as e:
            logger.error(f"‚ùå Erro ao carregar configura√ß√µes: {e}")
            return {}

    def save_config(self):
        """Salva configura√ß√µes"""
        try:
            config = {}
            for key, var in self.config_vars.items():
                config[key] = var.get()

            with open("geek_alert_config.json", "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

            messagebox.showinfo("Configura√ß√µes", "Configura√ß√µes salvas com sucesso!")
            logger.info("‚úÖ Configura√ß√µes salvas")

        except Exception as e:
            logger.error(f"‚ùå Erro ao salvar configura√ß√µes: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar configura√ß√µes: {e}")

    def reset_config(self):
        """Reseta configura√ß√µes para padr√£o"""
        try:
            default_config = {
                "search_interval": "5",
                "discount_threshold": "15",
                "commission_threshold": "10",
                "telegram_chat_id": "",
                "telegram_bot_token": "",
                "max_products": "20",
                "alert_cooldown": "6",
            }

            for key, value in default_config.items():
                if key in self.config_vars:
                    self.config_vars[key].set(value)

            messagebox.showinfo("Configura√ß√µes", "Configura√ß√µes resetadas para padr√£o!")

        except Exception as e:
            logger.error(f"‚ùå Erro ao resetar configura√ß√µes: {e}")
            messagebox.showerror("Erro", f"Erro ao resetar configura√ß√µes: {e}")

    def update_uptime(self):
        """Atualiza tempo de execu√ß√£o"""
        try:
            if hasattr(self, "start_time") and self.running:
                uptime = datetime.now() - self.start_time
                hours, remainder = divmod(int(uptime.total_seconds()), 3600)
                minutes, seconds = divmod(remainder, 60)
                uptime_str = f"Executando: {hours:02d}:{minutes:02d}:{seconds:02d}"
                self.uptime_label.config(text=uptime_str)
            else:
                self.uptime_label.config(text="")

            # Agenda pr√≥xima atualiza√ß√£o
            self.root.after(1000, self.update_uptime)

        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar uptime: {e}")

    def run(self):
        """Executa o aplicativo"""
        try:
            logger.info("üöÄ Iniciando Aplicativo Desktop Geek Alert...")

            # Inicia o loop principal
            self.root.mainloop()

        except Exception as e:
            logger.error(f"‚ùå Erro no aplicativo: {e}")
            messagebox.showerror("Erro Fatal", f"Erro no aplicativo: {e}")


def main():
    """Fun√ß√£o principal"""
    try:
        # Cria e executa o aplicativo
        app = GeekAlertDesktopApp()
        app.run()

    except Exception as e:
        logger.error(f"‚ùå Erro no aplicativo: {e}")
        messagebox.showerror("Erro Fatal", f"Erro no aplicativo: {e}")


if __name__ == "__main__":
    main()
