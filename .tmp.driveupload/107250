# services/logs.py
import logging
from pathlib import Path
from typing import List
import subprocess
import platform

logger = logging.getLogger(__name__)


class LogService:
    def __init__(self, logs_dir: str = "logs"):
        self.logs_dir = Path(logs_dir)
        self.logs_dir.mkdir(exist_ok=True)
        self.dashboard_log = self.logs_dir / "dashboard.log"
        self.bot_log = self.logs_dir / "bot.log"

        # Callbacks para notificações
        self._log_callbacks = []
        self._monitoring = False

    def add_log_callback(self, callback):
        """Adiciona callback para novas linhas de log"""
        if callback not in self._log_callbacks:
            self._log_callbacks.append(callback)

    def remove_log_callback(self, callback):
        """Remove callback"""
        if callback in self._log_callbacks:
            self._log_callbacks.remove(callback)

    def read_text(self, path: str, max_bytes: int = 300_000) -> str:
        """Lê arquivo de log, retornando apenas o final se muito grande"""
        try:
            log_path = Path(path)
            if not log_path.exists():
                return "[INFO] Arquivo de log não encontrado"

            # Se arquivo é pequeno, lê tudo
            if log_path.stat().st_size <= max_bytes:
                with open(log_path, "r", encoding="utf-8", errors="ignore") as f:
                    return f.read()

            # Se é grande, lê apenas o final
            with open(log_path, "rb") as f:
                f.seek(-max_bytes, 2)  # Vai para o final
                data = f.read()
                # Tenta encontrar uma linha completa
                try:
                    first_newline = data.index(b"\n")
                    data = data[first_newline + 1 :]
                except ValueError:
                    pass
                return data.decode("utf-8", errors="ignore")

        except Exception as e:
            logger.error(f"Erro ao ler log {path}: {e}")
            return f"[ERRO] Não foi possível ler o arquivo: {e}"

    def clear(self, path: str) -> bool:
        """Limpa arquivo de log, criando cabeçalho"""
        try:
            log_path = Path(path)
            log_path.parent.mkdir(exist_ok=True)

            with open(log_path, "w", encoding="utf-8") as f:
                f.write(f"[INFO] Logs limpos em {Path().absolute()}\n")
                f.write("[INFO] Sistema iniciado\n")

            return True
        except Exception as e:
            logger.error(f"Erro ao limpar log {path}: {e}")
            return False

    def open_folder(self, path: str) -> bool:
        """Abre pasta de logs no explorador"""
        try:
            folder_path = Path(path).parent
            if not folder_path.exists():
                folder_path.mkdir(parents=True, exist_ok=True)

            if platform.system() == "Windows":
                subprocess.run(["explorer", str(folder_path.absolute())], check=True)
            elif platform.system() == "Darwin":  # macOS
                subprocess.run(["open", str(folder_path.absolute())], check=True)
            else:  # Linux
                subprocess.run(["xdg-open", str(folder_path.absolute())], check=True)

            return True
        except Exception as e:
            logger.error(f"Erro ao abrir pasta {path}: {e}")
            return False

    def get_recent_logs(self, limit: int = 20) -> List[str]:
        """Retorna linhas recentes do log principal"""
        try:
            if not self.dashboard_log.exists():
                return ["[INFO] Log iniciado"]

            with open(self.dashboard_log, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
                return lines[-limit:] if len(lines) > limit else lines

        except Exception as e:
            logger.error(f"Erro ao ler logs recentes: {e}")
            return [f"[ERRO] Erro ao ler logs: {e}"]

    def start_monitoring(self):
        """Inicia monitoramento de logs (simulado para compatibilidade)"""
        if not self._monitoring:
            self._monitoring = True
            logger.info("Monitoramento de logs iniciado")

    def stop_monitoring(self):
        """Para monitoramento de logs"""
        if self._monitoring:
            self._monitoring = False
            logger.info("Monitoramento de logs parado")

    def get_log_stats(self) -> dict:
        """Retorna estatísticas dos logs"""
        try:
            stats = {}
            for log_file in [self.dashboard_log, self.bot_log]:
                if log_file.exists():
                    size = log_file.stat().st_size
                    stats[log_file.name] = {
                        "size_mb": round(size / (1024 * 1024), 2),
                        "exists": True,
                    }
                else:
                    stats[log_file.name] = {"size_mb": 0, "exists": False}
            return stats
        except Exception as e:
            logger.error(f"Erro ao obter estatísticas: {e}")
            return {}


# Instância global
log_service = LogService()
