# services/log_service.py
import time
import threading
from pathlib import Path
from typing import List, Optional, Callable
from datetime import datetime


class LogService:
    def __init__(self, log_file: str = "logs/geek_alert_desktop.log"):
        self.log_file = Path(log_file)
        self.log_callbacks: List[Callable[[str], None]] = []
        self.monitoring = False
        self.monitor_thread: Optional[threading.Thread] = None
        self.stop_monitoring = threading.Event()
        self.last_position = 0

    def add_log_callback(self, callback: Callable[[str], None]):
        """Adiciona callback para novas linhas de log"""
        self.log_callbacks.append(callback)

    def get_recent_logs(self, lines: int = 50) -> List[str]:
        """Retorna as linhas mais recentes do log"""
        if not self.log_file.exists():
            return ["[INFO] Arquivo de log não encontrado. Sistema iniciando..."]

        try:
            with open(self.log_file, "r", encoding="utf-8", errors="ignore") as f:
                all_lines = f.readlines()
                recent_lines = (
                    all_lines[-lines:] if len(all_lines) > lines else all_lines
                )
                return [line.strip() for line in recent_lines if line.strip()]
        except Exception as e:
            return [f"[ERROR] Erro ao ler log: {e}"]

    def start_monitoring(self):
        """Inicia monitoramento do arquivo de log"""
        if self.monitoring:
            return

        self.monitoring = True
        self.stop_monitoring.clear()

        # Inicia thread de monitoramento
        self.monitor_thread = threading.Thread(
            target=self._monitor_log_file, daemon=True
        )
        self.monitor_thread.start()

    def stop_monitoring(self):
        """Para monitoramento do arquivo de log"""
        self.monitoring = False
        self.stop_monitoring.set()

        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=2.0)

    def _monitor_log_file(self):
        """Monitora mudanças no arquivo de log"""
        while not self.stop_monitoring.is_set():
            try:
                if not self.log_file.exists():
                    time.sleep(1)
                    continue

                # Verifica se o arquivo mudou
                current_size = self.log_file.stat().st_size

                if current_size > self.last_position:
                    # Lê novas linhas
                    with open(
                        self.log_file, "r", encoding="utf-8", errors="ignore"
                    ) as f:
                        f.seek(self.last_position)
                        new_lines = f.readlines()

                        for line in new_lines:
                            line = line.strip()
                            if line:
                                # Notifica callbacks
                                for callback in self.log_callbacks:
                                    try:
                                        callback(line)
                                    except Exception as e:
                                        print(f"Erro no callback de log: {e}")

                    self.last_position = current_size

                time.sleep(0.5)  # Verifica a cada 500ms

            except Exception as e:
                print(f"Erro no monitoramento de log: {e}")
                time.sleep(1)

    def get_log_stats(self) -> dict:
        """Retorna estatísticas do arquivo de log"""
        if not self.log_file.exists():
            return {"exists": False, "size": 0, "lines": 0, "last_modified": None}

        try:
            stat = self.log_file.stat()
            with open(self.log_file, "r", encoding="utf-8", errors="ignore") as f:
                lines = len(f.readlines())

            return {
                "exists": True,
                "size": stat.st_size,
                "lines": lines,
                "last_modified": datetime.fromtimestamp(stat.st_mtime),
            }
        except Exception as e:
            return {"exists": False, "error": str(e)}

    def clear_logs(self) -> bool:
        """Limpa o arquivo de log (cria backup)"""
        if not self.log_file.exists():
            return True

        try:
            # Cria backup
            backup_file = self.log_file.with_suffix(".log.backup")
            if self.log_file.exists():
                import shutil

                shutil.copy2(self.log_file, backup_file)

            # Limpa arquivo atual
            with open(self.log_file, "w", encoding="utf-8") as f:
                f.write(f"[INFO] Logs limpos em {datetime.now()}\n")

            self.last_position = 0
            return True

        except Exception as e:
            print(f"Erro ao limpar logs: {e}")
            return False


# Instância global
log_service = LogService()
