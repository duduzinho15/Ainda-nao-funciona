#!/usr/bin/env python3
"""
Cliente para API de Afiliados da Shopee - Vers√£o Melhorada
Implementa√ß√£o com tratamento espec√≠fico para erro 10035 e logs detalhados
"""

import hashlib
import json
import time
import requests
import logging
from typing import Dict, Any, Optional
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class ShopeeAffiliateAPIEnhanced:
    """
    Cliente para integra√ß√£o com a API de Afiliados da Shopee.
    Vers√£o melhorada com tratamento espec√≠fico para erro 10035.
    """

    def __init__(self, app_id: str, app_secret: str):
        """
        Inicializa o cliente da API.

        Args:
            app_id: ID da aplica√ß√£o Shopee
            app_secret: Chave secreta da aplica√ß√£o Shopee
        """
        self.app_id = app_id
        self.app_secret = app_secret
        self.base_url = "https://open-api.affiliate.shopee.com.br/graphql"

        # Configura√ß√£o de retry para erro 10035
        self.session = self._create_session_with_retry()

    def _create_session_with_retry(self) -> requests.Session:
        """Cria uma sess√£o com configura√ß√£o de retry para erro 10035"""
        session = requests.Session()

        # Estrat√©gia de retry espec√≠fica para erro 10035
        retry_strategy = Retry(
            total=3,  # Total de tentativas
            backoff_factor=1,  # Fator de backoff exponencial
            status_forcelist=[429, 500, 502, 503, 504],  # Status codes para retry
            allowed_methods=["POST", "GET"],  # M√©todos permitidos para retry
            respect_retry_after_header=True,  # Respeita header Retry-After
        )

        # Adiciona o adapter com retry
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)

        # Configura√ß√µes de timeout e headers
        session.timeout = (30, 60)  # (connect_timeout, read_timeout)

        return session

    def _generate_signature(self, timestamp: int, payload: str) -> str:
        """
        Gera a assinatura SHA256 no formato EXATO esperado pela Shopee.

        IMPORTANTE: A string base deve seguir o formato:
        app_id+timestamp+payload+app_secret

        Args:
            timestamp: Unix timestamp atual
            payload: JSON string do payload

        Returns:
            Assinatura SHA256 em hexadecimal lowercase
        """
        # CR√çTICO: A string base deve ser EXATAMENTE neste formato
        base_string = f"{self.app_id}{timestamp}{payload}{self.app_secret}"

        # Gera o hash SHA256
        signature = hashlib.sha256(base_string.encode("utf-8")).hexdigest()

        # Log detalhado para debug
        logger.info(f"üîê Gerando assinatura para timestamp: {timestamp}")
        logger.debug(f"üìù Base String (primeiros 50 chars): {base_string[:50]}...")
        logger.debug(f"üìù Base String (√∫ltimos 50 chars): ...{base_string[-50:]}")
        logger.debug(f"üîë Assinatura gerada: {signature}")

        return signature

    def _format_query(self, query: str) -> str:
        """
        Formata a query GraphQL removendo espa√ßos extras e quebras de linha.

        Args:
            query: Query GraphQL com formata√ß√£o

        Returns:
            Query compacta sem espa√ßos desnecess√°rios
        """
        import re

        # Remove quebras de linha e espa√ßos extras
        query = " ".join(query.split())

        # Remove espa√ßos ao redor de { } ( ) : ,
        query = re.sub(r"\s*([{}(),:.])\s*", r"\1", query)

        # Remove aspas duplas extras que podem causar problemas
        query = query.replace('""', '"')

        logger.debug(f"üìù Query formatada: {query[:100]}...")

        return query

    def _handle_error_10035(
        self, response: requests.Response, attempt: int = 1
    ) -> Dict[str, Any]:
        """
        Trata especificamente o erro 10035 da Shopee.

        Args:
            response: Resposta da requisi√ß√£o
            attempt: N√∫mero da tentativa atual

        Returns:
            Dados da resposta ou erro tratado
        """
        try:
            error_data = response.json()
            logger.warning(f"‚ö†Ô∏è Erro 10035 detectado na tentativa {attempt}")
            logger.warning(f"üìä Detalhes do erro: {json.dumps(error_data, indent=2)}")

            # Log espec√≠fico para erro 10035
            if "errors" in error_data:
                for error in error_data["errors"]:
                    if "extensions" in error and "code" in error["extensions"]:
                        code = error["extensions"]["code"]
                        if code == 10035:
                            logger.error(
                                f"üö® ERRO 10035: {error.get('message', 'Mensagem n√£o dispon√≠vel')}"
                            )
                            logger.error(f"üìã Extens√µes: {error.get('extensions', {})}")

                            # Tenta extrair informa√ß√µes √∫teis
                            if "extensions" in error:
                                ext = error["extensions"]
                                if "rateLimitInfo" in ext:
                                    logger.info(
                                        f"‚è±Ô∏è Rate Limit Info: {ext['rateLimitInfo']}"
                                    )
                                if "retryAfter" in ext:
                                    logger.info(
                                        f"üîÑ Retry After: {ext['retryAfter']} segundos"
                                    )

            return error_data

        except json.JSONDecodeError:
            logger.error("‚ùå Erro ao decodificar resposta JSON para erro 10035")
            return {"error": "Erro 10035 - Falha ao decodificar resposta"}

    def execute_query(
        self,
        query: str,
        variables: Optional[Dict[str, Any]] = None,
        max_retries: int = 3,
    ) -> Dict[str, Any]:
        """
        Executa uma query GraphQL na API da Shopee com tratamento espec√≠fico para erro 10035.

        Args:
            query: Query GraphQL a ser executada
            variables: Vari√°veis opcionais para a query
            max_retries: N√∫mero m√°ximo de tentativas para erro 10035

        Returns:
            Resposta da API em formato dict

        Raises:
            requests.RequestException: Erro na requisi√ß√£o HTTP
            ValueError: Erro ao processar resposta JSON
        """
        # Formata a query
        formatted_query = self._format_query(query)

        # Prepara o payload
        payload = {"query": formatted_query}

        if variables:
            payload["variables"] = variables

        # Converte para JSON string
        payload_str = json.dumps(payload, separators=(",", ":"))

        # Timestamp atual (em segundos)
        timestamp = int(time.time())

        # Gera a assinatura
        signature = self._generate_signature(timestamp, payload_str)

        # Headers da requisi√ß√£o
        headers = {
            "Content-Type": "application/json",
            "X-App-Id": self.app_id,
            "X-Timestamp": str(timestamp),
            "X-Signature": signature,
            "User-Agent": "ShopeeAffiliateAPI/1.0",
        }

        # Log da requisi√ß√£o
        logger.info("üöÄ Executando query GraphQL")
        logger.info(f"üì° URL: {self.base_url}")
        logger.info(f"üÜî App ID: {self.app_id}")
        logger.info(f"‚è∞ Timestamp: {timestamp}")
        logger.info(f"üîë Signature: {signature[:20]}...")
        logger.debug(f"üì¶ Payload: {payload_str[:200]}...")

        # Loop de tentativas para erro 10035
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"üîÑ Tentativa {attempt}/{max_retries}")

                # Faz a requisi√ß√£o
                response = self.session.post(
                    self.base_url, headers=headers, json=payload, timeout=(30, 60)
                )

                # Log da resposta
                logger.info(f"üì• Status Code: {response.status_code}")
                logger.info(f"üìä Headers da resposta: {dict(response.headers)}")

                # Verifica o status da resposta
                if response.status_code == 200:
                    try:
                        result = response.json()
                        logger.info("‚úÖ Query executada com sucesso")
                        return result
                    except json.JSONDecodeError as e:
                        logger.error(f"‚ùå Erro ao decodificar JSON da resposta: {e}")
                        logger.debug(
                            f"üìÑ Conte√∫do da resposta: {response.text[:500]}..."
                        )
                        raise ValueError(f"Resposta inv√°lida da API: {e}")

                elif response.status_code == 429:  # Rate Limit
                    logger.warning("‚ö†Ô∏è Rate limit atingido (429)")
                    retry_after = response.headers.get("Retry-After", 60)
                    logger.info(
                        f"‚è≥ Aguardando {retry_after} segundos antes de tentar novamente..."
                    )
                    time.sleep(int(retry_after))
                    continue

                elif response.status_code >= 500:  # Erro do servidor
                    logger.warning(f"‚ö†Ô∏è Erro do servidor ({response.status_code})")
                    if attempt < max_retries:
                        wait_time = 2**attempt  # Backoff exponencial
                        logger.info(
                            f"‚è≥ Aguardando {wait_time} segundos antes de tentar novamente..."
                        )
                        time.sleep(wait_time)
                        continue
                    else:
                        logger.error(f"‚ùå Falha ap√≥s {max_retries} tentativas")
                        response.raise_for_status()

                else:
                    # Outros c√≥digos de erro
                    logger.error(f"‚ùå Erro HTTP {response.status_code}")
                    logger.debug(f"üìÑ Conte√∫do da resposta: {response.text[:500]}...")

                    # Tenta tratar como erro 10035
                    try:
                        error_data = response.json()
                        if "errors" in error_data:
                            for error in error_data["errors"]:
                                if (
                                    "extensions" in error
                                    and "code" in error["extensions"]
                                ):
                                    if error["extensions"]["code"] == 10035:
                                        logger.warning(
                                            "üîÑ Erro 10035 detectado, tentando novamente..."
                                        )
                                        if attempt < max_retries:
                                            wait_time = 5 * attempt  # Wait progressivo
                                            logger.info(
                                                f"‚è≥ Aguardando {wait_time} segundos..."
                                            )
                                            time.sleep(wait_time)
                                            break
                                        else:
                                            logger.error(
                                                f"‚ùå Falha ap√≥s {max_retries} tentativas para erro 10035"
                                            )
                                            return self._handle_error_10035(
                                                response, attempt
                                            )
                    except:
                        pass

                    response.raise_for_status()

            except requests.exceptions.Timeout as e:
                logger.error(f"‚è∞ Timeout na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 5 * attempt
                    logger.info(
                        f"‚è≥ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

            except requests.exceptions.ConnectionError as e:
                logger.error(f"üîå Erro de conex√£o na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 10 * attempt
                    logger.info(
                        f"‚è≥ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

            except Exception as e:
                logger.error(f"‚ùå Erro inesperado na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 5 * attempt
                    logger.info(
                        f"‚è≥ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

        # Se chegou aqui, todas as tentativas falharam
        logger.error(f"‚ùå Todas as {max_retries} tentativas falharam")
        raise Exception(f"Falha ap√≥s {max_retries} tentativas")

    def get_product_offers(self, limit: int = 10) -> Dict[str, Any]:
        """
        Busca ofertas de produtos usando a API GraphQL.

        Args:
            limit: N√∫mero m√°ximo de produtos a retornar

        Returns:
            Dados das ofertas de produtos
        """
        query = """query ProductOfferQuery($limit: Int) {
            productOfferV2(limit: $limit) {
                nodes {
                    id
                    title
                    priceMin
                    priceMax
                    imageUrl
                    productUrl
                    categoryName
                    shopName
                    rating
                    reviewCount
                    soldCount
                    discountPercentage
                    originalPrice
                    currentPrice
                }
                pageInfo {
                    page
                    limit
                    hasNextPage
                }
            }
        }"""

        variables = {"limit": limit}

        logger.info(f"üîç Buscando {limit} ofertas de produtos")
        return self.execute_query(query, variables)

    def search_products(self, keyword: str, limit: int = 10) -> Dict[str, Any]:
        """
        Busca produtos por palavra-chave.

        Args:
            keyword: Palavra-chave para busca
            limit: N√∫mero m√°ximo de produtos a retornar

        Returns:
            Resultados da busca
        """
        query = """query SearchProducts($keyword: String!, $limit: Int) {
            searchProducts(keyword: $keyword, limit: $limit) {
                nodes {
                    id
                    title
                    priceMin
                    priceMax
                    imageUrl
                    productUrl
                    categoryName
                    shopName
                    rating
                    reviewCount
                    soldCount
                    discountPercentage
                    originalPrice
                    currentPrice
                }
                pageInfo {
                    page
                    limit
                    hasNextPage
                }
            }
        }"""

        variables = {"keyword": keyword, "limit": limit}

        logger.info(f"üîç Buscando produtos com palavra-chave: {keyword}")
        return self.execute_query(query, variables)

    def test_connection(self) -> bool:
        """
        Testa a conex√£o com a API da Shopee.

        Returns:
            True se a conex√£o estiver funcionando, False caso contr√°rio
        """
        try:
            logger.info("üß™ Testando conex√£o com a API da Shopee...")

            # Query simples para teste
            query = """query TestConnection {
                __schema {
                    types {
                        name
                    }
                }
            }"""

            result = self.execute_query(query)

            if "data" in result and "__schema" in result["data"]:
                logger.info("‚úÖ Conex√£o com a API da Shopee funcionando!")
                return True
            else:
                logger.warning("‚ö†Ô∏è Conex√£o funcionando mas resposta inesperada")
                logger.debug(f"üìä Resposta: {result}")
                return False

        except Exception as e:
            logger.error(f"‚ùå Falha na conex√£o com a API da Shopee: {e}")
            return False


def main():
    """Fun√ß√£o principal para teste da API melhorada"""
    print("üöÄ TESTANDO API DA SHOPEE - VERS√ÉO MELHORADA")
    print("=" * 60)

    # Solicita credenciais
    app_id = input("üîë Digite o App ID da Shopee: ").strip()
    app_secret = input("üîê Digite o App Secret da Shopee: ").strip()

    if not app_id or not app_secret:
        print("‚ùå App ID e App Secret s√£o obrigat√≥rios")
        return

    # Cria inst√¢ncia da API
    api = ShopeeAffiliateAPIEnhanced(app_id, app_secret)

    try:
        # Testa conex√£o
        print("\nüß™ Testando conex√£o...")
        if not api.test_connection():
            print("‚ùå Falha na conex√£o")
            return

        # Testa busca de ofertas
        print("\nüîç Testando busca de ofertas...")
        offers = api.get_product_offers(limit=5)

        if "data" in offers and "productOfferV2" in offers["data"]:
            products = offers["data"]["productOfferV2"]["nodes"]
            print(f"‚úÖ {len(products)} ofertas encontradas!")

            for i, product in enumerate(products, 1):
                print(f"\n{i}. {product.get('title', 'T√≠tulo n√£o dispon√≠vel')}")
                print(f"   üí∞ Pre√ßo: R$ {product.get('currentPrice', 'N/A')}")
                print(f"   üè™ Loja: {product.get('shopName', 'N/A')}")
                print(f"   üìÇ Categoria: {product.get('categoryName', 'N/A')}")
                if product.get("discountPercentage"):
                    print(f"   üè∑Ô∏è Desconto: {product['discountPercentage']}%")
        else:
            print("‚ö†Ô∏è Resposta inesperada da API")
            print(f"üìä Resposta: {json.dumps(offers, indent=2)}")

        # Testa busca por palavra-chave
        print("\nüîç Testando busca por palavra-chave...")
        search_results = api.search_products("smartphone", limit=3)

        if "data" in search_results and "searchProducts" in search_results["data"]:
            products = search_results["data"]["searchProducts"]["nodes"]
            print(f"‚úÖ {len(products)} produtos encontrados para 'smartphone'!")

            for i, product in enumerate(products, 1):
                print(f"\n{i}. {product.get('title', 'T√≠tulo n√£o dispon√≠vel')}")
                print(f"   üí∞ Pre√ßo: R$ {product.get('currentPrice', 'N/A')}")
                print(f"   üè™ Loja: {product.get('shopName', 'N/A')}")
        else:
            print("‚ö†Ô∏è Resposta inesperada na busca")
            print(f"üìä Resposta: {json.dumps(search_results, indent=2)}")

    except Exception as e:
        print(f"‚ùå Erro durante o teste: {e}")
        logger.error(f"Erro detalhado: {e}", exc_info=True)


if __name__ == "__main__":
    main()
