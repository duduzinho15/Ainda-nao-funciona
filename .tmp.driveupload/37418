"""
Script para executar migra√ß√µes do banco de dados.

Este script procura por arquivos de migra√ß√£o no diret√≥rio 'migrations' e os executa em ordem.
Cada migra√ß√£o s√≥ √© executada uma vez, e seu status √© armazenado na tabela 'migrations'.
"""

import os
import importlib.util
import sqlite3
import config
from typing import List


def ensure_migrations_table() -> bool:
    """
    Cria a tabela 'migrations' se ela n√£o existir.

    Returns:
        bool: True se a tabela foi criada ou j√° existia, False em caso de erro
    """
    try:
        conn = sqlite3.connect(config.DB_NAME)
        cursor = conn.cursor()

        cursor.execute("""
        CREATE TABLE IF NOT EXISTS migrations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            success BOOLEAN NOT NULL
        )
        """)

        conn.commit()
        return True

    except sqlite3.Error as e:
        print(f"‚ùå Erro ao criar tabela de migra√ß√µes: {e}")
        return False

    finally:
        if "conn" in locals():
            conn.close()


def get_applied_migrations() -> List[str]:
    """
    Obt√©m a lista de migra√ß√µes j√° aplicadas.

    Returns:
        List[str]: Lista de nomes de migra√ß√µes j√° aplicadas com sucesso
    """
    try:
        conn = sqlite3.connect(config.DB_NAME)
        cursor = conn.cursor()

        cursor.execute("""
        SELECT name FROM migrations 
        WHERE success = 1
        ORDER BY applied_at ASC
        """)

        return [row[0] for row in cursor.fetchall()]

    except sqlite3.Error as e:
        print(f"‚ùå Erro ao obter migra√ß√µes aplicadas: {e}")
        return []

    finally:
        if "conn" in locals():
            conn.close()


def log_migration(migration_name: str, success: bool) -> bool:
    """
    Registra uma migra√ß√£o no banco de dados.

    Args:
        migration_name: Nome do arquivo de migra√ß√£o
        success: Se a migra√ß√£o foi bem-sucedida

    Returns:
        bool: True se o registro foi bem-sucedido, False caso contr√°rio
    """
    try:
        conn = sqlite3.connect(config.DB_NAME)
        cursor = conn.cursor()

        cursor.execute(
            """
        INSERT INTO migrations (name, success)
        VALUES (?, ?)
        """,
            (migration_name, success),
        )

        conn.commit()
        return True

    except sqlite3.Error as e:
        print(f"‚ùå Erro ao registrar migra√ß√£o: {e}")
        return False

    finally:
        if "conn" in locals():
            conn.close()


def get_pending_migrations() -> List[str]:
    """
    Obt√©m a lista de migra√ß√µes pendentes.

    Returns:
        List[str]: Lista de nomes de arquivos de migra√ß√£o pendentes, ordenados
    """
    if not os.path.exists("migrations"):
        print("‚ùå Diret√≥rio 'migrations' n√£o encontrado!")
        return []

    # Lista todos os arquivos .py no diret√≥rio de migra√ß√µes
    all_migrations = [
        f
        for f in os.listdir("migrations")
        if f.endswith(".py") and f != "__init__.py" and not f.startswith("_")
    ]

    # Ordena as migra√ß√µes numericamente
    all_migrations.sort(key=lambda x: int(x.split("_")[0]))

    # Obt√©m as migra√ß√µes j√° aplicadas
    applied_migrations = get_applied_migrations()

    # Retorna apenas as migra√ß√µes pendentes
    return [m for m in all_migrations if m not in applied_migrations]


def run_migration(migration_file: str) -> bool:
    """
    Executa uma √∫nica migra√ß√£o.

    Args:
        migration_file: Nome do arquivo de migra√ß√£o (ex: '001_add_asin_column.py')

    Returns:
        bool: True se a migra√ß√£o foi bem-sucedida, False caso contr√°rio
    """
    print(f"\nüîß Executando migra√ß√£o: {migration_file}...")

    try:
        # Carrega o m√≥dulo de migra√ß√£o dinamicamente
        module_name = migration_file[:-3]  # Remove a extens√£o .py
        spec = importlib.util.spec_from_file_location(
            f"migrations.{module_name}", os.path.join("migrations", migration_file)
        )

        if spec is None or spec.loader is None:
            print(f"‚ùå N√£o foi poss√≠vel carregar a migra√ß√£o {migration_file}")
            return False

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Executa a fun√ß√£o run_migration do m√≥dulo
        if not hasattr(module, "run_migration"):
            print(f"‚ùå A migra√ß√£o {migration_file} n√£o cont√©m a fun√ß√£o 'run_migration'")
            return False

        success = module.run_migration()

        # Registra o resultado da migra√ß√£o
        log_migration(migration_file, success)

        if success:
            print(f"‚úÖ Migra√ß√£o {migration_file} conclu√≠da com sucesso!")
        else:
            print(f"‚ùå Falha na migra√ß√£o {migration_file}")

        return success

    except Exception as e:
        print(f"‚ùå Erro ao executar migra√ß√£o {migration_file}: {e}")
        log_migration(migration_file, False)
        return False


def main():
    """Fun√ß√£o principal que executa todas as migra√ß√µes pendentes."""
    print("""
    üöÄ Iniciando execu√ß√£o de migra√ß√µes do banco de dados...
    """)

    # Garante que a tabela de migra√ß√µes existe
    if not ensure_migrations_table():
        print("‚ùå N√£o foi poss√≠vel verificar/criar a tabela de migra√ß√µes.")
        return False

    # Obt√©m migra√ß√µes pendentes
    pending_migrations = get_pending_migrations()

    if not pending_migrations:
        print("‚úÖ Nenhuma migra√ß√£o pendente.")
        return True

    print(f"üîç {len(pending_migrations)} migra√ß√£o(√µes) pendente(s) encontrada(s).")

    # Executa cada migra√ß√£o pendente
    all_success = True
    for migration in pending_migrations:
        if not run_migration(migration):
            all_success = False
            break

    if all_success:
        print("\n‚ú® Todas as migra√ß√µes foram aplicadas com sucesso!")
    else:
        print(
            "\n‚ùå Algumas migra√ß√µes falharam. Verifique os logs acima para mais detalhes."
        )

    return all_success


if __name__ == "__main__":
    import sys

    sys.exit(0 if main() else 1)
