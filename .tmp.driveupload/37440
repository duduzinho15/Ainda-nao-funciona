"""
Scraper avan√ßado para o Zoom.com.br - Coleta hist√≥rico de pre√ßos
"""

import time
import logging
import re
from typing import Dict, Optional, List
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
)
from webdriver_manager.chrome import ChromeDriverManager
from bs4 import BeautifulSoup
import json

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ZoomScraper:
    """Scraper avan√ßado para o Zoom.com.br usando Selenium"""

    def __init__(self, headless: bool = True):
        """
        Inicializa o scraper do Zoom

        Args:
            headless: Se True, executa o navegador em modo headless (sem interface gr√°fica)
        """
        self.headless = headless
        self.driver = None
        self.base_url = "https://www.zoom.com.br"
        self.search_url = "https://www.zoom.com.br/search"

        # Configura√ß√µes do Chrome
        self.chrome_options = Options()
        if headless:
            self.chrome_options.add_argument("--headless")

        # Configura√ß√µes para evitar detec√ß√£o de bot
        self.chrome_options.add_argument("--no-sandbox")
        self.chrome_options.add_argument("--disable-dev-shm-usage")
        self.chrome_options.add_argument(
            "--disable-blink-features=AutomationControlled"
        )
        self.chrome_options.add_experimental_option(
            "excludeSwitches", ["enable-automation"]
        )
        self.chrome_options.add_experimental_option("useAutomationExtension", False)
        self.chrome_options.add_argument(
            "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        )

        # Timeout para esperas expl√≠citas
        self.timeout = 30

    def _setup_driver(self):
        """Configura e inicializa o driver do Chrome"""
        try:
            logger.info("Configurando driver do Chrome...")

            # Usa webdriver-manager para baixar automaticamente o driver correto
            service = Service(ChromeDriverManager().install())

            # Cria o driver
            self.driver = webdriver.Chrome(service=service, options=self.chrome_options)

            # Remove a flag de automa√ß√£o
            self.driver.execute_script(
                "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
            )

            # Define o tamanho da janela
            self.driver.set_window_size(1920, 1080)

            logger.info("Driver do Chrome configurado com sucesso")
            return True

        except Exception as e:
            logger.error(f"Erro ao configurar driver do Chrome: {e}")
            return False

    def _cleanup_driver(self):
        """Limpa e fecha o driver do Chrome"""
        if self.driver:
            try:
                self.driver.quit()
                logger.info("Driver do Chrome fechado")
            except Exception as e:
                logger.error(f"Erro ao fechar driver: {e}")
            finally:
                self.driver = None

    def _wait_for_element(
        self, by: By, value: str, timeout: int = None
    ) -> Optional[webdriver.remote.webelement.WebElement]:
        """Aguarda at√© que um elemento esteja presente na p√°gina"""
        timeout = timeout or self.timeout
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((by, value))
            )
            return element
        except TimeoutException:
            logger.warning(f"Timeout aguardando elemento: {value}")
            return None

    def _wait_for_element_visible(
        self, by: By, value: str, timeout: int = None
    ) -> Optional[webdriver.remote.webelement.WebElement]:
        """Aguarda at√© que um elemento esteja vis√≠vel na p√°gina"""
        timeout = timeout or self.timeout
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.visibility_of_element_located((by, value))
            )
            return element
        except TimeoutException:
            logger.warning(f"Timeout aguardando elemento vis√≠vel: {value}")
            return None

    def _search_product(self, nome_produto: str) -> bool:
        """
        Busca um produto no Zoom

        Args:
            nome_produto: Nome do produto a ser buscado

        Returns:
            bool: True se a busca foi bem-sucedida
        """
        try:
            logger.info(f"Buscando produto: {nome_produto}")

            # Constr√≥i a URL de busca
            search_params = {
                "q": nome_produto,
                "sort": "relevance",  # Ordena por relev√¢ncia
            }

            # Monta a URL com par√¢metros
            search_url = f"{self.search_url}?q={nome_produto}"

            # Navega para a p√°gina de busca
            self.driver.get(search_url)
            logger.info(f"Navegando para: {search_url}")

            # Aguarda a p√°gina carregar
            time.sleep(3)

            # Verifica se h√° resultados
            try:
                # Procura por produtos nos resultados
                produtos = self.driver.find_elements(
                    By.CSS_SELECTOR,
                    '[data-testid="product-card"], .product-card, .product-item',
                )

                if not produtos:
                    # Tenta outros seletores
                    produtos = self.driver.find_elements(
                        By.CSS_SELECTOR, '.product, .item, [class*="product"]'
                    )

                if produtos:
                    logger.info(f"Encontrados {len(produtos)} produtos na busca")
                    return True
                else:
                    logger.warning("Nenhum produto encontrado na busca")
                    return False

            except NoSuchElementException:
                logger.warning("N√£o foi poss√≠vel verificar os resultados da busca")
                return False

        except Exception as e:
            logger.error(f"Erro durante a busca: {e}")
            return False

    def _click_first_product(self) -> bool:
        """
        Clica no primeiro produto dos resultados de busca

        Returns:
            bool: True se conseguiu clicar no produto
        """
        try:
            logger.info("Procurando pelo primeiro produto...")

            # Procura por produtos nos resultados
            produtos = self.driver.find_elements(
                By.CSS_SELECTOR,
                '[data-testid="product-card"], .product-card, .product-item',
            )

            if not produtos:
                # Tenta outros seletores
                produtos = self.driver.find_elements(
                    By.CSS_SELECTOR, '.product, .item, [class*="product"]'
                )

            if not produtos:
                logger.warning("Nenhum produto encontrado para clicar")
                return False

            # Clica no primeiro produto
            primeiro_produto = produtos[0]

            # Procura por um link clic√°vel dentro do produto
            link = primeiro_produto.find_element(
                By.CSS_SELECTOR,
                'a[href*="/produto/"], a[href*="/p/"], a[href*="/item/"]',
            )

            if link:
                logger.info("Clicando no primeiro produto...")
                link.click()

                # Aguarda a p√°gina do produto carregar
                time.sleep(3)
                return True
            else:
                logger.warning("Link do produto n√£o encontrado")
                return False

        except Exception as e:
            logger.error(f"Erro ao clicar no primeiro produto: {e}")
            return False

    def _extract_price_history(self) -> Optional[Dict]:
        """
        Extrai o hist√≥rico de pre√ßos da p√°gina do produto

        Returns:
            Dict com o hist√≥rico de pre√ßos ou None se n√£o encontrado
        """
        try:
            logger.info("Extraindo hist√≥rico de pre√ßos...")

            # Aguarda a p√°gina carregar completamente
            time.sleep(5)

            # Procura pelo gr√°fico de hist√≥rico de pre√ßos
            price_chart = None

            # Tenta diferentes seletores para o gr√°fico
            selectors = [
                '[data-testid="price-chart"]',
                ".price-chart",
                ".price-history",
                '[class*="price-chart"]',
                '[class*="price-history"]',
                ".chart-container",
                ".price-graph",
            ]

            for selector in selectors:
                try:
                    price_chart = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if price_chart:
                        logger.info(
                            f"Gr√°fico de pre√ßos encontrado com seletor: {selector}"
                        )
                        break
                except NoSuchElementException:
                    continue

            if not price_chart:
                logger.warning("Gr√°fico de pre√ßos n√£o encontrado")
                return None

            # Procura por dados de pre√ßos no gr√°fico
            price_data = self._extract_price_data_from_chart(price_chart)

            if price_data:
                logger.info("Dados de pre√ßos extra√≠dos com sucesso")
                return price_data
            else:
                logger.warning("N√£o foi poss√≠vel extrair dados de pre√ßos do gr√°fico")
                return None

        except Exception as e:
            logger.error(f"Erro ao extrair hist√≥rico de pre√ßos: {e}")
            return None

    def _extract_price_data_from_chart(self, chart_element) -> Optional[Dict]:
        """
        Extrai dados de pre√ßos de um elemento de gr√°fico

        Args:
            chart_element: Elemento HTML do gr√°fico

        Returns:
            Dict com os dados de pre√ßos ou None
        """
        try:
            # Tenta extrair dados de diferentes formas

            # 1. Procura por dados em atributos data-*
            price_data = self._extract_from_data_attributes(chart_element)
            if price_data:
                return price_data

            # 2. Procura por dados em scripts JavaScript
            price_data = self._extract_from_scripts()
            if price_data:
                return price_data

            # 3. Procura por dados em elementos de texto
            price_data = self._extract_from_text_elements(chart_element)
            if price_data:
                return price_data

            # 4. Tenta extrair do HTML interno
            price_data = self._extract_from_html_content(chart_element)
            if price_data:
                return price_data

            return None

        except Exception as e:
            logger.error(f"Erro ao extrair dados do gr√°fico: {e}")
            return None

    def _extract_from_data_attributes(self, chart_element) -> Optional[Dict]:
        """Extrai dados de pre√ßos de atributos data-*"""
        try:
            # Procura por atributos que possam conter dados de pre√ßos
            data_attrs = [
                "data-prices",
                "data-price-history",
                "data-chart-data",
                "data-values",
            ]

            for attr in data_attrs:
                try:
                    data_value = chart_element.get_attribute(attr)
                    if data_value:
                        logger.info(f"Dados encontrados em {attr}")
                        return self._parse_price_data(data_value)
                except:
                    continue

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de atributos data-*: {e}")
            return None

    def _extract_from_scripts(self) -> Optional[Dict]:
        """Extrai dados de pre√ßos de scripts JavaScript na p√°gina"""
        try:
            # Procura por scripts que possam conter dados de pre√ßos
            scripts = self.driver.find_elements(By.TAG_NAME, "script")

            for script in scripts:
                try:
                    script_content = script.get_attribute("innerHTML")
                    if script_content and (
                        "price" in script_content.lower()
                        or "chart" in script_content.lower()
                    ):
                        # Procura por padr√µes de dados de pre√ßos
                        price_data = self._extract_price_from_script(script_content)
                        if price_data:
                            return price_data
                except:
                    continue

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de scripts: {e}")
            return None

    def _extract_price_from_script(self, script_content: str) -> Optional[Dict]:
        """Extrai dados de pre√ßos de um script JavaScript"""
        try:
            # Procura por padr√µes comuns de dados de pre√ßos
            patterns = [
                r"prices\s*:\s*\[([^\]]+)\]",
                r"priceHistory\s*:\s*\[([^\]]+)\]",
                r"chartData\s*:\s*\{([^}]+)\}",
                r"data\s*:\s*\[([^\]]+)\]",
            ]

            for pattern in patterns:
                match = re.search(pattern, script_content, re.IGNORECASE)
                if match:
                    data_str = match.group(1)
                    return self._parse_price_data(data_str)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair pre√ßos do script: {e}")
            return None

    def _extract_from_text_elements(self, chart_element) -> Optional[Dict]:
        """Extrai dados de pre√ßos de elementos de texto"""
        try:
            # Procura por elementos que contenham informa√ß√µes de pre√ßos
            price_elements = chart_element.find_elements(
                By.CSS_SELECTOR, ".price, .value, .data-point, .chart-label"
            )

            if price_elements:
                prices = []
                for elem in price_elements:
                    try:
                        text = elem.text.strip()
                        if text and re.search(r"[\d.,]+", text):
                            prices.append(text)
                    except:
                        continue

                if prices:
                    return self._create_price_summary(prices)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de elementos de texto: {e}")
            return None

    def _extract_from_html_content(self, chart_element) -> Optional[Dict]:
        """Extrai dados de pre√ßos do conte√∫do HTML do gr√°fico"""
        try:
            # Obt√©m o HTML interno do gr√°fico
            html_content = chart_element.get_attribute("innerHTML")

            if html_content:
                # Usa BeautifulSoup para analisar o HTML
                soup = BeautifulSoup(html_content, "html.parser")

                # Procura por elementos que possam conter pre√ßos
                price_elements = soup.find_all(
                    ["span", "div", "p"], class_=re.compile(r"price|value|data")
                )

                if price_elements:
                    prices = []
                    for elem in price_elements:
                        text = elem.get_text(strip=True)
                        if text and re.search(r"[\d.,]+", text):
                            prices.append(text)

                    if prices:
                        return self._create_price_summary(prices)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair do HTML: {e}")
            return None

    def _parse_price_data(self, data_str: str) -> Optional[Dict]:
        """Converte string de dados em dicion√°rio de pre√ßos"""
        try:
            # Tenta fazer parse como JSON
            if data_str.startswith("{") or data_str.startswith("["):
                data = json.loads(data_str)
                return self._process_json_price_data(data)

            # Tenta extrair n√∫meros da string
            numbers = re.findall(r"[\d.,]+", data_str)
            if numbers:
                return self._create_price_summary(numbers)

            return None

        except Exception as e:
            logger.debug(f"Erro ao fazer parse dos dados: {e}")
            return None

    def _process_json_price_data(self, data) -> Optional[Dict]:
        """Processa dados de pre√ßos em formato JSON"""
        try:
            if isinstance(data, list):
                # Lista de pre√ßos
                prices = [str(item) for item in data if item is not None]
                if prices:
                    return self._create_price_summary(prices)

            elif isinstance(data, dict):
                # Dicion√°rio com dados de pre√ßos
                if "prices" in data:
                    prices = data["prices"]
                    if isinstance(prices, list):
                        return self._create_price_summary(
                            [str(p) for p in prices if p is not None]
                        )

                # Procura por outras chaves que possam conter pre√ßos
                for key, value in data.items():
                    if "price" in key.lower() and isinstance(value, (list, dict)):
                        return self._process_json_price_data(value)

            return None

        except Exception as e:
            logger.debug(f"Erro ao processar dados JSON: {e}")
            return None

    def _create_price_summary(self, prices: List[str]) -> Dict:
        """
        Cria um resumo dos pre√ßos encontrados

        Args:
            prices: Lista de pre√ßos como strings

        Returns:
            Dict com resumo dos pre√ßos
        """
        try:
            # Converte pre√ßos para n√∫meros
            numeric_prices = []
            for price_str in prices:
                try:
                    # Remove caracteres n√£o num√©ricos e converte para float
                    clean_price = re.sub(r"[^\d.,]", "", price_str)
                    clean_price = clean_price.replace(",", ".")
                    if clean_price:
                        numeric_prices.append(float(clean_price))
                except:
                    continue

            if not numeric_prices:
                return {
                    "menor_preco_6m": 0.0,
                    "menor_preco_total": 0.0,
                    "precos_encontrados": len(prices),
                    "status": "sem_dados_numericos",
                }

            # Calcula estat√≠sticas
            menor_preco = min(numeric_prices)
            maior_preco = max(numeric_prices)
            preco_medio = sum(numeric_prices) / len(numeric_prices)

            return {
                "menor_preco_6m": menor_preco,
                "menor_preco_total": menor_preco,
                "maior_preco": maior_preco,
                "preco_medio": preco_medio,
                "precos_encontrados": len(numeric_prices),
                "status": "sucesso",
            }

        except Exception as e:
            logger.error(f"Erro ao criar resumo de pre√ßos: {e}")
            return {
                "menor_preco_6m": 0.0,
                "menor_preco_total": 0.0,
                "precos_encontrados": len(prices),
                "status": "erro",
            }

    def buscar_historico_zoom(self, nome_produto: str) -> Optional[Dict]:
        """
        Busca o hist√≥rico de pre√ßos de um produto no Zoom

        Args:
            nome_produto: Nome do produto a ser buscado

        Returns:
            Dict com o hist√≥rico de pre√ßos ou None se n√£o encontrado
        """
        try:
            logger.info(f"Iniciando busca de hist√≥rico para: {nome_produto}")

            # Configura o driver
            if not self._setup_driver():
                logger.error("Falha ao configurar driver do Chrome")
                return None

            try:
                # Busca o produto
                if not self._search_product(nome_produto):
                    logger.warning("Produto n√£o encontrado na busca")
                    return None

                # Clica no primeiro produto
                if not self._click_first_product():
                    logger.warning("Falha ao acessar p√°gina do produto")
                    return None

                # Extrai o hist√≥rico de pre√ßos
                price_history = self._extract_price_history()

                if price_history:
                    logger.info("Hist√≥rico de pre√ßos extra√≠do com sucesso")
                    return price_history
                else:
                    logger.warning("N√£o foi poss√≠vel extrair hist√≥rico de pre√ßos")
                    return None

            finally:
                # Sempre limpa o driver
                self._cleanup_driver()

        except Exception as e:
            logger.error(f"Erro durante busca de hist√≥rico: {e}")
            self._cleanup_driver()
            return None


def buscar_historico_zoom(nome_produto: str) -> Optional[Dict]:
    """
    Fun√ß√£o principal para buscar hist√≥rico de pre√ßos no Zoom

    Args:
        nome_produto: Nome do produto a ser buscado

    Returns:
        Dict com o hist√≥rico de pre√ßos ou None se n√£o encontrado
    """
    scraper = ZoomScraper(headless=True)
    return scraper.buscar_historico_zoom(nome_produto)


if __name__ == "__main__":
    print("üîç Testando scraper de hist√≥rico de pre√ßos do Zoom...")
    print("=" * 60)

    # Produto de teste
    produto_teste = "iPhone 15"

    try:
        print(f"üì± Buscando hist√≥rico de pre√ßos para: {produto_teste}")
        print("‚è≥ Isso pode levar alguns minutos...")

        historico = buscar_historico_zoom(produto_teste)

        if historico:
            print("\n‚úÖ Hist√≥rico encontrado!")
            print("\nüìä Dados do hist√≥rico:")
            print("-" * 40)

            for key, value in historico.items():
                if isinstance(value, float):
                    print(f"   {key}: R$ {value:.2f}")
                else:
                    print(f"   {key}: {value}")
        else:
            print("\n‚ùå Hist√≥rico n√£o encontrado")

    except Exception as e:
        print(f"\n‚ùå Erro durante o teste: {e}")
        import traceback

        traceback.print_exc()
