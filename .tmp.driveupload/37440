"""
Scraper avançado para o Zoom.com.br - Coleta histórico de preços
"""

import time
import logging
import re
from typing import Dict, Optional, List
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import (
    TimeoutException,
    NoSuchElementException,
)
from webdriver_manager.chrome import ChromeDriverManager
from bs4 import BeautifulSoup
import json

# Configuração de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ZoomScraper:
    """Scraper avançado para o Zoom.com.br usando Selenium"""

    def __init__(self, headless: bool = True):
        """
        Inicializa o scraper do Zoom

        Args:
            headless: Se True, executa o navegador em modo headless (sem interface gráfica)
        """
        self.headless = headless
        self.driver = None
        self.base_url = "https://www.zoom.com.br"
        self.search_url = "https://www.zoom.com.br/search"

        # Configurações do Chrome
        self.chrome_options = Options()
        if headless:
            self.chrome_options.add_argument("--headless")

        # Configurações para evitar detecção de bot
        self.chrome_options.add_argument("--no-sandbox")
        self.chrome_options.add_argument("--disable-dev-shm-usage")
        self.chrome_options.add_argument(
            "--disable-blink-features=AutomationControlled"
        )
        self.chrome_options.add_experimental_option(
            "excludeSwitches", ["enable-automation"]
        )
        self.chrome_options.add_experimental_option("useAutomationExtension", False)
        self.chrome_options.add_argument(
            "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        )

        # Timeout para esperas explícitas
        self.timeout = 30

    def _setup_driver(self):
        """Configura e inicializa o driver do Chrome"""
        try:
            logger.info("Configurando driver do Chrome...")

            # Usa webdriver-manager para baixar automaticamente o driver correto
            service = Service(ChromeDriverManager().install())

            # Cria o driver
            self.driver = webdriver.Chrome(service=service, options=self.chrome_options)

            # Remove a flag de automação
            self.driver.execute_script(
                "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
            )

            # Define o tamanho da janela
            self.driver.set_window_size(1920, 1080)

            logger.info("Driver do Chrome configurado com sucesso")
            return True

        except Exception as e:
            logger.error(f"Erro ao configurar driver do Chrome: {e}")
            return False

    def _cleanup_driver(self):
        """Limpa e fecha o driver do Chrome"""
        if self.driver:
            try:
                self.driver.quit()
                logger.info("Driver do Chrome fechado")
            except Exception as e:
                logger.error(f"Erro ao fechar driver: {e}")
            finally:
                self.driver = None

    def _wait_for_element(
        self, by: By, value: str, timeout: int = None
    ) -> Optional[webdriver.remote.webelement.WebElement]:
        """Aguarda até que um elemento esteja presente na página"""
        timeout = timeout or self.timeout
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((by, value))
            )
            return element
        except TimeoutException:
            logger.warning(f"Timeout aguardando elemento: {value}")
            return None

    def _wait_for_element_visible(
        self, by: By, value: str, timeout: int = None
    ) -> Optional[webdriver.remote.webelement.WebElement]:
        """Aguarda até que um elemento esteja visível na página"""
        timeout = timeout or self.timeout
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.visibility_of_element_located((by, value))
            )
            return element
        except TimeoutException:
            logger.warning(f"Timeout aguardando elemento visível: {value}")
            return None

    def _search_product(self, nome_produto: str) -> bool:
        """
        Busca um produto no Zoom

        Args:
            nome_produto: Nome do produto a ser buscado

        Returns:
            bool: True se a busca foi bem-sucedida
        """
        try:
            logger.info(f"Buscando produto: {nome_produto}")

            # Constrói a URL de busca
            search_params = {
                "q": nome_produto,
                "sort": "relevance",  # Ordena por relevância
            }

            # Monta a URL com parâmetros
            search_url = f"{self.search_url}?q={nome_produto}"

            # Navega para a página de busca
            self.driver.get(search_url)
            logger.info(f"Navegando para: {search_url}")

            # Aguarda a página carregar
            time.sleep(3)

            # Verifica se há resultados
            try:
                # Procura por produtos nos resultados
                produtos = self.driver.find_elements(
                    By.CSS_SELECTOR,
                    '[data-testid="product-card"], .product-card, .product-item',
                )

                if not produtos:
                    # Tenta outros seletores
                    produtos = self.driver.find_elements(
                        By.CSS_SELECTOR, '.product, .item, [class*="product"]'
                    )

                if produtos:
                    logger.info(f"Encontrados {len(produtos)} produtos na busca")
                    return True
                else:
                    logger.warning("Nenhum produto encontrado na busca")
                    return False

            except NoSuchElementException:
                logger.warning("Não foi possível verificar os resultados da busca")
                return False

        except Exception as e:
            logger.error(f"Erro durante a busca: {e}")
            return False

    def _click_first_product(self) -> bool:
        """
        Clica no primeiro produto dos resultados de busca

        Returns:
            bool: True se conseguiu clicar no produto
        """
        try:
            logger.info("Procurando pelo primeiro produto...")

            # Procura por produtos nos resultados
            produtos = self.driver.find_elements(
                By.CSS_SELECTOR,
                '[data-testid="product-card"], .product-card, .product-item',
            )

            if not produtos:
                # Tenta outros seletores
                produtos = self.driver.find_elements(
                    By.CSS_SELECTOR, '.product, .item, [class*="product"]'
                )

            if not produtos:
                logger.warning("Nenhum produto encontrado para clicar")
                return False

            # Clica no primeiro produto
            primeiro_produto = produtos[0]

            # Procura por um link clicável dentro do produto
            link = primeiro_produto.find_element(
                By.CSS_SELECTOR,
                'a[href*="/produto/"], a[href*="/p/"], a[href*="/item/"]',
            )

            if link:
                logger.info("Clicando no primeiro produto...")
                link.click()

                # Aguarda a página do produto carregar
                time.sleep(3)
                return True
            else:
                logger.warning("Link do produto não encontrado")
                return False

        except Exception as e:
            logger.error(f"Erro ao clicar no primeiro produto: {e}")
            return False

    def _extract_price_history(self) -> Optional[Dict]:
        """
        Extrai o histórico de preços da página do produto

        Returns:
            Dict com o histórico de preços ou None se não encontrado
        """
        try:
            logger.info("Extraindo histórico de preços...")

            # Aguarda a página carregar completamente
            time.sleep(5)

            # Procura pelo gráfico de histórico de preços
            price_chart = None

            # Tenta diferentes seletores para o gráfico
            selectors = [
                '[data-testid="price-chart"]',
                ".price-chart",
                ".price-history",
                '[class*="price-chart"]',
                '[class*="price-history"]',
                ".chart-container",
                ".price-graph",
            ]

            for selector in selectors:
                try:
                    price_chart = self.driver.find_element(By.CSS_SELECTOR, selector)
                    if price_chart:
                        logger.info(
                            f"Gráfico de preços encontrado com seletor: {selector}"
                        )
                        break
                except NoSuchElementException:
                    continue

            if not price_chart:
                logger.warning("Gráfico de preços não encontrado")
                return None

            # Procura por dados de preços no gráfico
            price_data = self._extract_price_data_from_chart(price_chart)

            if price_data:
                logger.info("Dados de preços extraídos com sucesso")
                return price_data
            else:
                logger.warning("Não foi possível extrair dados de preços do gráfico")
                return None

        except Exception as e:
            logger.error(f"Erro ao extrair histórico de preços: {e}")
            return None

    def _extract_price_data_from_chart(self, chart_element) -> Optional[Dict]:
        """
        Extrai dados de preços de um elemento de gráfico

        Args:
            chart_element: Elemento HTML do gráfico

        Returns:
            Dict com os dados de preços ou None
        """
        try:
            # Tenta extrair dados de diferentes formas

            # 1. Procura por dados em atributos data-*
            price_data = self._extract_from_data_attributes(chart_element)
            if price_data:
                return price_data

            # 2. Procura por dados em scripts JavaScript
            price_data = self._extract_from_scripts()
            if price_data:
                return price_data

            # 3. Procura por dados em elementos de texto
            price_data = self._extract_from_text_elements(chart_element)
            if price_data:
                return price_data

            # 4. Tenta extrair do HTML interno
            price_data = self._extract_from_html_content(chart_element)
            if price_data:
                return price_data

            return None

        except Exception as e:
            logger.error(f"Erro ao extrair dados do gráfico: {e}")
            return None

    def _extract_from_data_attributes(self, chart_element) -> Optional[Dict]:
        """Extrai dados de preços de atributos data-*"""
        try:
            # Procura por atributos que possam conter dados de preços
            data_attrs = [
                "data-prices",
                "data-price-history",
                "data-chart-data",
                "data-values",
            ]

            for attr in data_attrs:
                try:
                    data_value = chart_element.get_attribute(attr)
                    if data_value:
                        logger.info(f"Dados encontrados em {attr}")
                        return self._parse_price_data(data_value)
                except:
                    continue

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de atributos data-*: {e}")
            return None

    def _extract_from_scripts(self) -> Optional[Dict]:
        """Extrai dados de preços de scripts JavaScript na página"""
        try:
            # Procura por scripts que possam conter dados de preços
            scripts = self.driver.find_elements(By.TAG_NAME, "script")

            for script in scripts:
                try:
                    script_content = script.get_attribute("innerHTML")
                    if script_content and (
                        "price" in script_content.lower()
                        or "chart" in script_content.lower()
                    ):
                        # Procura por padrões de dados de preços
                        price_data = self._extract_price_from_script(script_content)
                        if price_data:
                            return price_data
                except:
                    continue

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de scripts: {e}")
            return None

    def _extract_price_from_script(self, script_content: str) -> Optional[Dict]:
        """Extrai dados de preços de um script JavaScript"""
        try:
            # Procura por padrões comuns de dados de preços
            patterns = [
                r"prices\s*:\s*\[([^\]]+)\]",
                r"priceHistory\s*:\s*\[([^\]]+)\]",
                r"chartData\s*:\s*\{([^}]+)\}",
                r"data\s*:\s*\[([^\]]+)\]",
            ]

            for pattern in patterns:
                match = re.search(pattern, script_content, re.IGNORECASE)
                if match:
                    data_str = match.group(1)
                    return self._parse_price_data(data_str)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair preços do script: {e}")
            return None

    def _extract_from_text_elements(self, chart_element) -> Optional[Dict]:
        """Extrai dados de preços de elementos de texto"""
        try:
            # Procura por elementos que contenham informações de preços
            price_elements = chart_element.find_elements(
                By.CSS_SELECTOR, ".price, .value, .data-point, .chart-label"
            )

            if price_elements:
                prices = []
                for elem in price_elements:
                    try:
                        text = elem.text.strip()
                        if text and re.search(r"[\d.,]+", text):
                            prices.append(text)
                    except:
                        continue

                if prices:
                    return self._create_price_summary(prices)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair de elementos de texto: {e}")
            return None

    def _extract_from_html_content(self, chart_element) -> Optional[Dict]:
        """Extrai dados de preços do conteúdo HTML do gráfico"""
        try:
            # Obtém o HTML interno do gráfico
            html_content = chart_element.get_attribute("innerHTML")

            if html_content:
                # Usa BeautifulSoup para analisar o HTML
                soup = BeautifulSoup(html_content, "html.parser")

                # Procura por elementos que possam conter preços
                price_elements = soup.find_all(
                    ["span", "div", "p"], class_=re.compile(r"price|value|data")
                )

                if price_elements:
                    prices = []
                    for elem in price_elements:
                        text = elem.get_text(strip=True)
                        if text and re.search(r"[\d.,]+", text):
                            prices.append(text)

                    if prices:
                        return self._create_price_summary(prices)

            return None

        except Exception as e:
            logger.debug(f"Erro ao extrair do HTML: {e}")
            return None

    def _parse_price_data(self, data_str: str) -> Optional[Dict]:
        """Converte string de dados em dicionário de preços"""
        try:
            # Tenta fazer parse como JSON
            if data_str.startswith("{") or data_str.startswith("["):
                data = json.loads(data_str)
                return self._process_json_price_data(data)

            # Tenta extrair números da string
            numbers = re.findall(r"[\d.,]+", data_str)
            if numbers:
                return self._create_price_summary(numbers)

            return None

        except Exception as e:
            logger.debug(f"Erro ao fazer parse dos dados: {e}")
            return None

    def _process_json_price_data(self, data) -> Optional[Dict]:
        """Processa dados de preços em formato JSON"""
        try:
            if isinstance(data, list):
                # Lista de preços
                prices = [str(item) for item in data if item is not None]
                if prices:
                    return self._create_price_summary(prices)

            elif isinstance(data, dict):
                # Dicionário com dados de preços
                if "prices" in data:
                    prices = data["prices"]
                    if isinstance(prices, list):
                        return self._create_price_summary(
                            [str(p) for p in prices if p is not None]
                        )

                # Procura por outras chaves que possam conter preços
                for key, value in data.items():
                    if "price" in key.lower() and isinstance(value, (list, dict)):
                        return self._process_json_price_data(value)

            return None

        except Exception as e:
            logger.debug(f"Erro ao processar dados JSON: {e}")
            return None

    def _create_price_summary(self, prices: List[str]) -> Dict:
        """
        Cria um resumo dos preços encontrados

        Args:
            prices: Lista de preços como strings

        Returns:
            Dict com resumo dos preços
        """
        try:
            # Converte preços para números
            numeric_prices = []
            for price_str in prices:
                try:
                    # Remove caracteres não numéricos e converte para float
                    clean_price = re.sub(r"[^\d.,]", "", price_str)
                    clean_price = clean_price.replace(",", ".")
                    if clean_price:
                        numeric_prices.append(float(clean_price))
                except:
                    continue

            if not numeric_prices:
                return {
                    "menor_preco_6m": 0.0,
                    "menor_preco_total": 0.0,
                    "precos_encontrados": len(prices),
                    "status": "sem_dados_numericos",
                }

            # Calcula estatísticas
            menor_preco = min(numeric_prices)
            maior_preco = max(numeric_prices)
            preco_medio = sum(numeric_prices) / len(numeric_prices)

            return {
                "menor_preco_6m": menor_preco,
                "menor_preco_total": menor_preco,
                "maior_preco": maior_preco,
                "preco_medio": preco_medio,
                "precos_encontrados": len(numeric_prices),
                "status": "sucesso",
            }

        except Exception as e:
            logger.error(f"Erro ao criar resumo de preços: {e}")
            return {
                "menor_preco_6m": 0.0,
                "menor_preco_total": 0.0,
                "precos_encontrados": len(prices),
                "status": "erro",
            }

    def buscar_historico_zoom(self, nome_produto: str) -> Optional[Dict]:
        """
        Busca o histórico de preços de um produto no Zoom

        Args:
            nome_produto: Nome do produto a ser buscado

        Returns:
            Dict com o histórico de preços ou None se não encontrado
        """
        try:
            logger.info(f"Iniciando busca de histórico para: {nome_produto}")

            # Configura o driver
            if not self._setup_driver():
                logger.error("Falha ao configurar driver do Chrome")
                return None

            try:
                # Busca o produto
                if not self._search_product(nome_produto):
                    logger.warning("Produto não encontrado na busca")
                    return None

                # Clica no primeiro produto
                if not self._click_first_product():
                    logger.warning("Falha ao acessar página do produto")
                    return None

                # Extrai o histórico de preços
                price_history = self._extract_price_history()

                if price_history:
                    logger.info("Histórico de preços extraído com sucesso")
                    return price_history
                else:
                    logger.warning("Não foi possível extrair histórico de preços")
                    return None

            finally:
                # Sempre limpa o driver
                self._cleanup_driver()

        except Exception as e:
            logger.error(f"Erro durante busca de histórico: {e}")
            self._cleanup_driver()
            return None


def buscar_historico_zoom(nome_produto: str) -> Optional[Dict]:
    """
    Função principal para buscar histórico de preços no Zoom

    Args:
        nome_produto: Nome do produto a ser buscado

    Returns:
        Dict com o histórico de preços ou None se não encontrado
    """
    scraper = ZoomScraper(headless=True)
    return scraper.buscar_historico_zoom(nome_produto)


if __name__ == "__main__":
    print("🔍 Testando scraper de histórico de preços do Zoom...")
    print("=" * 60)

    # Produto de teste
    produto_teste = "iPhone 15"

    try:
        print(f"📱 Buscando histórico de preços para: {produto_teste}")
        print("⏳ Isso pode levar alguns minutos...")

        historico = buscar_historico_zoom(produto_teste)

        if historico:
            print("\n✅ Histórico encontrado!")
            print("\n📊 Dados do histórico:")
            print("-" * 40)

            for key, value in historico.items():
                if isinstance(value, float):
                    print(f"   {key}: R$ {value:.2f}")
                else:
                    print(f"   {key}: {value}")
        else:
            print("\n❌ Histórico não encontrado")

    except Exception as e:
        print(f"\n❌ Erro durante o teste: {e}")
        import traceback

        traceback.print_exc()
