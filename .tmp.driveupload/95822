# utils/amazon_link.py
from __future__ import annotations
import re
import asyncio
import logging
from typing import Optional
from urllib.parse import urlparse, parse_qs, unquote
import aiohttp
import os

logger = logging.getLogger("amazon_link")

AMAZON_DOMS = {
    "amazon.com.br",
    "www.amazon.com.br",
    "amzn.to",
    "www.amzn.to",  # short
}

# ---- 1) Extra√ß√£o de ASIN diretamente da URL ----
_ASIN_PATTERNS = [
    r"/dp/(?P<asin>[A-Z0-9]{10})(?:[/?]|$)",
    r"/gp/product/(?P<asin>[A-Z0-9]{10})(?:[/?]|$)",
    r"/product/(?P<asin>[A-Z0-9]{10})(?:[/?]|$)",
    r"[?&]asin=(?P<asin>[A-Z0-9]{10})(?:[&#]|$)",
    r"/-/(?:pt_BR|pt)/dp/(?P<asin>[A-Z0-9]{10})(?:[/?]|$)",
]


def extract_asin_from_url(url: str) -> Optional[str]:
    """Extrai ASIN diretamente da URL usando regex"""
    if not url:
        return None

    for pat in _ASIN_PATTERNS:
        m = re.search(pat, url, flags=re.IGNORECASE)
        if m:
            asin = m.group("asin").upper()
            logger.debug(f"‚úÖ ASIN extra√≠do da URL: {asin}")
            return asin

    logger.debug(f"‚ùå ASIN n√£o encontrado na URL: {url[:100]}...")
    return None


# ---- 2) Expans√£o de shortlinks e wrappers (HEAD, baixo risco) ----
async def _expand_redirect(url: str, timeout: int = 8) -> Optional[str]:
    """
    Faz uma HEAD (com follow redirects) para resolver shortlinks

    Args:
        url: URL para expandir
        timeout: Timeout em segundos

    Returns:
        URL expandida ou None se falhar
    """
    try:
        from aiohttp import ClientTimeout

        timeout_obj = ClientTimeout(total=timeout)

        async with aiohttp.ClientSession(timeout=timeout_obj) as session:
            async with session.head(url, allow_redirects=True) as response:
                if response.status == 200:
                    final_url = str(response.url)
                    if final_url != url:
                        logger.info(f"‚úÖ Redirect expandido: {url} -> {final_url}")
                        return final_url
                    else:
                        return url
                else:
                    logger.warning(f"‚ö†Ô∏è Status {response.status} ao expandir: {url}")
                    return None

    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erro ao expandir redirect: {e}")
        return None


def _unwrap_redirect_params(url: str) -> Optional[str]:
    """
    Desembrulha par√¢metros de redirecionamento da URL

    Args:
        url: URL com par√¢metros de redirecionamento

    Returns:
        URL desembrulhada ou None se n√£o encontrar
    """
    try:
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)

        # Procura por par√¢metros de redirecionamento comuns
        redirect_params = ["redirect", "url", "target", "dest", "goto", "link"]

        for param in redirect_params:
            if param in query_params:
                redirect_url = query_params[param][0]
                if redirect_url.startswith("http"):
                    logger.info(
                        f"‚úÖ Par√¢metro de redirecionamento encontrado: {param}={redirect_url}"
                    )
                    return redirect_url

        return None

    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erro ao desembrulhar par√¢metros: {e}")
        return None


def _unwrap_embedded(url: str) -> Optional[str]:
    """
    Alguns links v√™m com ?url=HTTPS%3A%2F%2Fwww.amazon.com.br%2F...
    Tenta extrair a URL alvo sem fazer requisi√ß√£o.
    """
    try:
        qs = parse_qs(urlparse(url).query)
        for key in ("url", "u", "redirect", "ued"):  # ued √© comum em Awin
            if key in qs and qs[key]:
                unwrapped = unquote(qs[key][0])
                logger.debug(f"‚úÖ URL desembrulhada: {unwrapped}")
                return unwrapped
    except Exception as e:
        logger.debug(f"‚ö†Ô∏è Erro ao desembrulhar URL: {e}")
    return None


# ---- 3) Fallback Playwright opcional (s√≥ se realmente precisar) ----
async def _fetch_canonical_with_playwright(
    url: str, timeout_ms: int = 15000
) -> Optional[str]:
    """
    Abre a p√°gina, l√™ <link rel="canonical"> e tenta extrair o ASIN do can√¥nico.
    Evita baixar recursos pesados e n√£o faz intera√ß√µes.
    """
    try:
        from playwright.async_api import async_playwright
    except ImportError:
        logger.warning("‚ö†Ô∏è Playwright n√£o instalado, fallback desabilitado")
        return None

    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(
                headless=True,
                args=[
                    "--disable-dev-shm-usage",
                    "--no-sandbox",
                    "--disable-gpu",
                    "--disable-web-security",
                    "--disable-features=VizDisplayCompositor",
                ],
            )
            context = await browser.new_context(
                locale="pt-BR",
                user_agent=os.getenv(
                    "HTTP_UA",
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/124.0.0.0 Safari/537.36",
                ),
                viewport={"width": 1280, "height": 800},
            )
            page = await context.new_page()

            # Bloqueia imagens/fonte para reduzir pegada
            async def route_intercept(route):
                if route.request.resource_type in {
                    "image",
                    "media",
                    "font",
                    "stylesheet",
                }:
                    await route.abort()
                else:
                    await route.continue_()

            await context.route("**/*", route_intercept)

            try:
                await page.goto(url, wait_until="domcontentloaded", timeout=timeout_ms)

                # Tenta ler link can√¥nico
                canonical = await page.eval_on_selector(
                    'link[rel="canonical"]',
                    "el => el.href",
                )

                if not canonical:
                    # Fallback: tenta meta ASIN
                    meta_asin = await page.eval_on_selector(
                        'meta[name="ASIN"]',
                        "el => el.content",
                    )
                    if meta_asin:
                        canonical = f"https://www.amazon.com.br/dp/{meta_asin}"

                if canonical:
                    logger.debug(f"‚úÖ Canonical extra√≠do via Playwright: {canonical}")
                    return canonical

            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Erro ao ler canonical via Playwright: {e}")
            finally:
                await context.close()
                await browser.close()

    except Exception as e:
        logger.error(f"‚ùå Erro no Playwright: {e}")

    return None


# ---- 4) Fun√ß√£o principal: canonicaliza SEM tocar na p√°gina quando poss√≠vel ----
async def canonicalize_amazon(url: str, associate_tag: str) -> Optional[str]:
    """
    Canonicaliza URL da Amazon para formato de afiliado

    Args:
        url: URL da Amazon
        associate_tag: Tag de afiliado (ex: garimpeirogee-20)

    Returns:
        URL canonicalizada ou None se falhar
    """
    if not url:
        return None

    try:
        logger.info(f"üîç Canonicalizando URL Amazon: {url}")

        # 1Ô∏è‚É£ Tenta extrair ASIN diretamente da URL
        asin = extract_asin_from_url(url)
        if asin:
            canonical_url = f"https://www.amazon.com.br/dp/{asin}?tag={associate_tag}"
            logger.info(f"‚úÖ ASIN extra√≠do diretamente: {asin}")
            return canonical_url

        # 2Ô∏è‚É£ Se n√£o encontrou ASIN, tenta desembrulhar par√¢metros de redirecionamento
        unwrapped_url = _unwrap_redirect_params(url)
        if unwrapped_url and unwrapped_url != url:
            logger.info(f"‚úÖ URL desembrulhada: {unwrapped_url}")
            asin = extract_asin_from_url(unwrapped_url)
            if asin:
                canonical_url = (
                    f"https://www.amazon.com.br/dp/{asin}?tag={associate_tag}"
                )
                logger.info(f"‚úÖ ASIN extra√≠do da URL desembrulhada: {asin}")
                return canonical_url

        # 3Ô∏è‚É£ Tenta desembrulhar URLs embutidas
        unwrapped_url = _unwrap_embedded(url)
        if unwrapped_url and unwrapped_url != url:
            logger.info(f"‚úÖ URL desembrulhada: {unwrapped_url}")
            asin = extract_asin_from_url(unwrapped_url)
            if asin:
                canonical_url = (
                    f"https://www.amazon.com.br/dp/{asin}?tag={associate_tag}"
                )
                logger.info(f"‚úÖ ASIN extra√≠do da URL desembrulhada: {asin}")
                return canonical_url

        # 4Ô∏è‚É£ Se n√£o conseguiu extrair ASIN, adiciona tag na URL original
        if "amazon.com.br" in url:
            separator = "&" if "?" in url else "?"
            canonical_url = f"{url}{separator}tag={associate_tag}"
            logger.info("‚úÖ Tag de afiliado adicionada na URL original")
            return canonical_url

        logger.warning(f"‚ö†Ô∏è N√£o foi poss√≠vel canonicalizar: {url}")
        return None

    except Exception as e:
        logger.error(f"‚ùå Erro na canonicaliza√ß√£o: {e}")
        return None


# ---- 5) Fun√ß√£o s√≠ncrona para compatibilidade ----
def canonicalize_amazon_sync(url: str, associate_tag: str) -> Optional[str]:
    """Vers√£o s√≠ncrona para compatibilidade com c√≥digo existente"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # Se j√° estiver em um loop async, retorna None para usar vers√£o async
            logger.warning("‚ö†Ô∏è Loop async j√° rodando, use canonicalize_amazon()")
            return None
        else:
            return asyncio.run(canonicalize_amazon(url, associate_tag))
    except RuntimeError:
        # Se n√£o h√° loop, cria um novo
        return asyncio.run(canonicalize_amazon(url, associate_tag))
