#!/usr/bin/env python3
"""
Cliente para API de Afiliados da Shopee - Versão Corrigida
Implementação que resolve o erro 10020: Invalid Authorization Header
"""

import hashlib
import json
import time
import requests
import logging
from typing import Dict, Any, Optional
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Configuração de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class ShopeeAffiliateAPIFixed:
    """
    Cliente para integração com a API de Afiliados da Shopee.
    Versão corrigida que resolve o erro 10020 de autenticação.
    """

    def __init__(self, app_id: str, app_secret: str):
        """
        Inicializa o cliente da API.

        Args:
            app_id: ID da aplicação Shopee
            app_secret: Chave secreta da aplicação Shopee
        """
        self.app_id = app_id
        self.app_secret = app_secret
        self.base_url = "https://open-api.affiliate.shopee.com.br/graphql"

        # Configuração de retry
        self.session = self._create_session_with_retry()

    def _create_session_with_retry(self) -> requests.Session:
        """Cria uma sessão com configuração de retry"""
        session = requests.Session()

        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["POST", "GET"],
            respect_retry_after_header=True,
        )

        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)

        session.timeout = (30, 60)

        return session

    def _generate_signature(self, timestamp: int, payload: str) -> str:
        """
        Gera a assinatura SHA256 no formato EXATO esperado pela Shopee.

        IMPORTANTE: A string base deve seguir o formato:
        app_id+timestamp+payload+app_secret

        Args:
            timestamp: Unix timestamp atual
            payload: JSON string do payload

        Returns:
            Assinatura SHA256 em hexadecimal lowercase
        """
        # CRÍTICO: A string base deve ser EXATAMENTE neste formato
        base_string = f"{self.app_id}{timestamp}{payload}{self.app_secret}"

        # Gera o hash SHA256
        signature = hashlib.sha256(base_string.encode("utf-8")).hexdigest()

        # Log detalhado para debug
        logger.info(f"🔐 Gerando assinatura para timestamp: {timestamp}")
        logger.debug(f"📝 Base String (primeiros 50 chars): {base_string[:50]}...")
        logger.debug(f"📝 Base String (últimos 50 chars): ...{base_string[-50:]}")
        logger.debug(f"🔑 Assinatura gerada: {signature}")

        return signature

    def _format_query(self, query: str) -> str:
        """
        Formata a query GraphQL removendo espaços extras e quebras de linha.

        Args:
            query: Query GraphQL com formatação

        Returns:
            Query compacta sem espaços desnecessários
        """
        import re

        # Remove quebras de linha e espaços extras
        query = " ".join(query.split())

        # Remove espaços ao redor de { } ( ) : ,
        query = re.sub(r"\s*([{}(),:.])\s*", r"\1", query)

        # Remove aspas duplas extras que podem causar problemas
        query = query.replace('""', '"')

        logger.debug(f"📝 Query formatada: {query[:100]}...")

        return query

    def execute_query(
        self,
        query: str,
        variables: Optional[Dict[str, Any]] = None,
        max_retries: int = 3,
    ) -> Dict[str, Any]:
        """
        Executa uma query GraphQL na API da Shopee com autenticação corrigida.

        Args:
            query: Query GraphQL a ser executada
            variables: Variáveis opcionais para a query
            max_retries: Número máximo de tentativas

        Returns:
            Resposta da API em formato dict
        """
        # Formata a query
        formatted_query = self._format_query(query)

        # Prepara o payload
        payload = {"query": formatted_query}

        if variables:
            payload["variables"] = variables

        # Converte para JSON string - IMPORTANTE: usar separators para JSON compacto
        payload_str = json.dumps(payload, separators=(",", ":"))

        # Timestamp atual (em segundos)
        timestamp = int(time.time())

        # Gera a assinatura
        signature = self._generate_signature(timestamp, payload_str)

        # Headers da requisição - CORRIGIDO para resolver erro 10020
        headers = {
            "Content-Type": "application/json",
            "X-App-Id": str(self.app_id),  # Garante que é string
            "X-Timestamp": str(timestamp),  # Garante que é string
            "X-Signature": signature,
            "User-Agent": "ShopeeAffiliateAPI/1.0",
            "Accept": "application/json",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
        }

        # Log da requisição
        logger.info("🚀 Executando query GraphQL")
        logger.info(f"📡 URL: {self.base_url}")
        logger.info(f"🆔 App ID: {self.app_id}")
        logger.info(f"⏰ Timestamp: {timestamp}")
        logger.info(f"🔑 Signature: {signature[:20]}...")
        logger.debug(f"📦 Payload: {payload_str[:200]}...")
        logger.debug(f"📋 Headers: {headers}")

        # Loop de tentativas
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"🔄 Tentativa {attempt}/{max_retries}")

                # Faz a requisição
                response = self.session.post(
                    self.base_url,
                    headers=headers,
                    json=payload,  # Usa json= para automaticamente definir Content-Type
                    timeout=(30, 60),
                )

                # Log da resposta
                logger.info(f"📥 Status Code: {response.status_code}")
                logger.info(f"📊 Headers da resposta: {dict(response.headers)}")

                # Verifica o status da resposta
                if response.status_code == 200:
                    try:
                        result = response.json()
                        logger.info("✅ Query executada com sucesso")

                        # Verifica se há erros na resposta
                        if "errors" in result:
                            for error in result["errors"]:
                                if (
                                    "extensions" in error
                                    and "code" in error["extensions"]
                                ):
                                    code = error["extensions"]["code"]
                                    if code == 10020:
                                        logger.error(
                                            "🚨 ERRO 10020: Invalid Authorization Header"
                                        )
                                        logger.error(
                                            f"📋 Mensagem: {error.get('message', 'N/A')}"
                                        )
                                        logger.error(
                                            f"📋 Extensões: {error.get('extensions', {})}"
                                        )

                                        # Salva detalhes do erro para análise
                                        with open(
                                            "erro_10020_detalhes.json",
                                            "w",
                                            encoding="utf-8",
                                        ) as f:
                                            json.dump(
                                                {
                                                    "timestamp": time.time(),
                                                    "error_details": error,
                                                    "full_response": result,
                                                    "request_headers": headers,
                                                    "request_payload": payload_str,
                                                    "app_id": self.app_id,
                                                    "app_secret_length": len(
                                                        self.app_secret
                                                    ),
                                                },
                                                f,
                                                indent=2,
                                                ensure_ascii=False,
                                            )

                                        logger.error(
                                            "💾 Detalhes do erro 10020 salvos em: erro_10020_detalhes.json"
                                        )

                                        # Tenta corrigir o problema de autenticação
                                        if attempt < max_retries:
                                            logger.info(
                                                "🔄 Tentando corrigir problema de autenticação..."
                                            )
                                            # Aguarda um pouco antes de tentar novamente
                                            time.sleep(2)
                                            continue
                                        else:
                                            logger.error(
                                                "❌ Falha após todas as tentativas para erro 10020"
                                            )
                                            return result

                        return result

                    except json.JSONDecodeError as e:
                        logger.error(f"❌ Erro ao decodificar JSON da resposta: {e}")
                        logger.debug(
                            f"📄 Conteúdo da resposta: {response.text[:500]}..."
                        )
                        raise ValueError(f"Resposta inválida da API: {e}")

                elif response.status_code == 401:  # Unauthorized
                    logger.error(
                        "❌ Erro 401: Unauthorized - Problema de autenticação"
                    )
                    logger.debug(f"📄 Conteúdo da resposta: {response.text[:500]}...")

                    if attempt < max_retries:
                        logger.info("🔄 Tentando novamente com delay...")
                        time.sleep(2 * attempt)
                        continue
                    else:
                        response.raise_for_status()

                elif response.status_code == 429:  # Rate Limit
                    logger.warning("⚠️ Rate limit atingido (429)")
                    retry_after = response.headers.get("Retry-After", 60)
                    logger.info(
                        f"⏳ Aguardando {retry_after} segundos antes de tentar novamente..."
                    )
                    time.sleep(int(retry_after))
                    continue

                elif response.status_code >= 500:  # Erro do servidor
                    logger.warning(f"⚠️ Erro do servidor ({response.status_code})")
                    if attempt < max_retries:
                        wait_time = 2**attempt
                        logger.info(
                            f"⏳ Aguardando {wait_time} segundos antes de tentar novamente..."
                        )
                        time.sleep(wait_time)
                        continue
                    else:
                        logger.error(f"❌ Falha após {max_retries} tentativas")
                        response.raise_for_status()

                else:
                    # Outros códigos de erro
                    logger.error(f"❌ Erro HTTP {response.status_code}")
                    logger.debug(f"📄 Conteúdo da resposta: {response.text[:500]}...")
                    response.raise_for_status()

            except requests.exceptions.Timeout as e:
                logger.error(f"⏰ Timeout na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 5 * attempt
                    logger.info(
                        f"⏳ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

            except requests.exceptions.ConnectionError as e:
                logger.error(f"🔌 Erro de conexão na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 10 * attempt
                    logger.info(
                        f"⏳ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

            except Exception as e:
                logger.error(f"❌ Erro inesperado na tentativa {attempt}: {e}")
                if attempt < max_retries:
                    wait_time = 5 * attempt
                    logger.info(
                        f"⏳ Aguardando {wait_time} segundos antes de tentar novamente..."
                    )
                    time.sleep(wait_time)
                    continue
                else:
                    raise

        # Se chegou aqui, todas as tentativas falharam
        logger.error(f"❌ Todas as {max_retries} tentativas falharam")
        raise Exception(f"Falha após {max_retries} tentativas")

    def get_product_offers(self, limit: int = 10) -> Dict[str, Any]:
        """
        Busca ofertas de produtos usando a API GraphQL.

        Args:
            limit: Número máximo de produtos a retornar

        Returns:
            Dados das ofertas de produtos
        """
        query = """query ProductOfferQuery($limit: Int) {
            productOfferV2(limit: $limit) {
                nodes {
                    id
                    title
                    priceMin
                    priceMax
                    imageUrl
                    productUrl
                    categoryName
                    shopName
                    rating
                    reviewCount
                    soldCount
                    discountPercentage
                    originalPrice
                    currentPrice
                }
                pageInfo {
                    page
                    limit
                    hasNextPage
                }
            }
        }"""

        variables = {"limit": limit}

        logger.info(f"🔍 Buscando {limit} ofertas de produtos")
        return self.execute_query(query, variables)

    def search_products(self, keyword: str, limit: int = 10) -> Dict[str, Any]:
        """
        Busca produtos por palavra-chave.

        Args:
            keyword: Palavra-chave para busca
            limit: Número máximo de produtos a retornar

        Returns:
            Resultados da busca
        """
        query = """query SearchProducts($keyword: String!, $limit: Int) {
            searchProducts(keyword: $keyword, limit: $limit) {
                nodes {
                    id
                    title
                    priceMin
                    priceMax
                    imageUrl
                    productUrl
                    categoryName
                    shopName
                    rating
                    reviewCount
                    soldCount
                    discountPercentage
                    originalPrice
                    currentPrice
                }
                pageInfo {
                    page
                    limit
                    hasNextPage
                }
            }
        }"""

        variables = {"keyword": keyword, "limit": limit}

        logger.info(f"🔍 Buscando produtos com palavra-chave: {keyword}")
        return self.execute_query(query, variables)

    def test_connection(self) -> bool:
        """
        Testa a conexão com a API da Shopee.

        Returns:
            True se a conexão estiver funcionando, False caso contrário
        """
        try:
            logger.info("🧪 Testando conexão com a API da Shopee...")

            # Query simples para teste
            query = """query TestConnection {
                __schema {
                    types {
                        name
                    }
                }
            }"""

            result = self.execute_query(query)

            if "data" in result and "__schema" in result["data"]:
                logger.info("✅ Conexão com a API da Shopee funcionando!")
                return True
            else:
                logger.warning("⚠️ Conexão funcionando mas resposta inesperada")
                logger.debug(f"📊 Resposta: {result}")
                return False

        except Exception as e:
            logger.error(f"❌ Falha na conexão com a API da Shopee: {e}")
            return False


def main():
    """Função principal para teste da API corrigida"""
    print("🚀 TESTANDO API DA SHOPEE - VERSÃO CORRIGIDA")
    print("=" * 60)

    # Solicita credenciais
    app_id = input("🔑 Digite o App ID da Shopee: ").strip()
    app_secret = input("🔐 Digite o App Secret da Shopee: ").strip()

    if not app_id or not app_secret:
        print("❌ App ID e App Secret são obrigatórios")
        return

    # Cria instância da API
    api = ShopeeAffiliateAPIFixed(app_id, app_secret)

    try:
        # Testa conexão
        print("\n🧪 Testando conexão...")
        if not api.test_connection():
            print("❌ Falha na conexão")
            return

        # Testa busca de ofertas
        print("\n🔍 Testando busca de ofertas...")
        offers = api.get_product_offers(limit=5)

        if "data" in offers and "productOfferV2" in offers["data"]:
            products = offers["data"]["productOfferV2"]["nodes"]
            print(f"✅ {len(products)} ofertas encontradas!")

            for i, product in enumerate(products, 1):
                print(f"\n{i}. {product.get('title', 'Título não disponível')}")
                print(f"   💰 Preço: R$ {product.get('currentPrice', 'N/A')}")
                print(f"   🏪 Loja: {product.get('shopName', 'N/A')}")
                print(f"   📂 Categoria: {product.get('categoryName', 'N/A')}")
                if product.get("discountPercentage"):
                    print(f"   🏷️ Desconto: {product['discountPercentage']}%")
        else:
            print("⚠️ Resposta inesperada da API")
            print(f"📊 Resposta: {json.dumps(offers, indent=2)}")

        # Testa busca por palavra-chave
        print("\n🔍 Testando busca por palavra-chave...")
        search_results = api.search_products("smartphone", limit=3)

        if "data" in search_results and "searchProducts" in search_results["data"]:
            products = search_results["data"]["searchProducts"]["nodes"]
            print(f"✅ {len(products)} produtos encontrados para 'smartphone'!")

            for i, product in enumerate(products, 1):
                print(f"\n{i}. {product.get('title', 'Título não disponível')}")
                print(f"   💰 Preço: R$ {product.get('currentPrice', 'N/A')}")
                print(f"   🏪 Loja: {product.get('shopName', 'N/A')}")
        else:
            print("⚠️ Resposta inesperada na busca")
            print(f"📊 Resposta: {json.dumps(search_results, indent=2)}")

    except Exception as e:
        print(f"❌ Erro durante o teste: {e}")
        logger.error(f"Erro detalhado: {e}", exc_info=True)


if __name__ == "__main__":
    main()
