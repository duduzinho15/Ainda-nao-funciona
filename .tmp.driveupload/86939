#!/usr/bin/env python3
"""
Sistema de Banco de Dados SQL para Produtos e Hist√≥rico de Pre√ßos
Implementa armazenamento persistente de dados do sistema de afiliados
"""

import sqlite3
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import hashlib

logger = logging.getLogger("database_sql")


@dataclass
class Product:
    """Modelo de dados para produtos"""

    id: Optional[int]
    title: str
    price: str
    original_price: Optional[str]
    url: str
    affiliate_url: Optional[str]
    store: str
    source: str
    category: Optional[str]
    image_url: Optional[str]
    rating: Optional[float]
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
    is_active: bool = True


@dataclass
class PriceHistory:
    """Modelo de dados para hist√≥rico de pre√ßos"""

    id: Optional[int]
    product_id: int
    price: str
    original_price: Optional[str]
    recorded_at: datetime
    source: str


@dataclass
class AffiliateClick:
    """Modelo de dados para cliques em links de afiliado"""

    id: Optional[int]
    product_id: int
    affiliate_url: str
    store: str
    clicked_at: datetime
    user_agent: Optional[str]
    ip_address: Optional[str]


class DatabaseManager:
    """Gerenciador do banco de dados SQLite"""

    def __init__(self, db_path: str = "garimpeirogeek.db"):
        self.db_path = db_path
        self.connection = None
        self.init_database()

    def init_database(self):
        """Inicializa o banco de dados e cria as tabelas"""
        try:
            self.connection = sqlite3.connect(self.db_path)
            self.connection.row_factory = sqlite3.Row

            # Cria tabelas
            self._create_tables()

            # Cria √≠ndices para performance
            self._create_indexes()

            logger.info("Banco de dados inicializado com sucesso")

        except Exception as e:
            logger.error(f"Erro ao inicializar banco de dados: {e}")
            raise

    def _create_tables(self):
        """Cria as tabelas do banco de dados"""
        try:
            cursor = self.connection.cursor()

            # Tabela de produtos
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    price TEXT NOT NULL,
                    original_price TEXT,
                    url TEXT NOT NULL UNIQUE,
                    affiliate_url TEXT,
                    store TEXT NOT NULL,
                    source TEXT NOT NULL,
                    category TEXT,
                    image_url TEXT,
                    rating REAL,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    hash_id TEXT UNIQUE
                )
            """)

            # Tabela de hist√≥rico de pre√ßos
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS price_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    price TEXT NOT NULL,
                    original_price TEXT,
                    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    source TEXT NOT NULL,
                    FOREIGN KEY (product_id) REFERENCES products (id)
                )
            """)

            # Tabela de cliques em links de afiliado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS affiliate_clicks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    affiliate_url TEXT NOT NULL,
                    store TEXT NOT NULL,
                    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    user_agent TEXT,
                    ip_address TEXT,
                    FOREIGN KEY (product_id) REFERENCES products (id)
                )
            """)

            # Tabela de estat√≠sticas
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE UNIQUE,
                    total_products INTEGER DEFAULT 0,
                    total_affiliate_links INTEGER DEFAULT 0,
                    total_clicks INTEGER DEFAULT 0,
                    total_revenue REAL DEFAULT 0.0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            self.connection.commit()
            logger.info("Tabelas criadas com sucesso")

        except Exception as e:
            logger.error(f"Erro ao criar tabelas: {e}")
            raise

    def _create_indexes(self):
        """Cria √≠ndices para melhorar performance"""
        try:
            cursor = self.connection.cursor()

            # √çndices para produtos
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_store ON products(store)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_source ON products(source)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_category ON products(category)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_hash_id ON products(hash_id)"
            )

            # √çndices para hist√≥rico de pre√ßos
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_price_history_product_id ON price_history(product_id)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_price_history_recorded_at ON price_history(recorded_at)"
            )

            # √çndices para cliques
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_product_id ON affiliate_clicks(product_id)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_store ON affiliate_clicks(store)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_clicked_at ON affiliate_clicks(clicked_at)"
            )

            self.connection.commit()
            logger.info("√çndices criados com sucesso")

        except Exception as e:
            logger.error(f"Erro ao criar √≠ndices: {e}")

    def _generate_hash_id(self, product_data: Dict[str, Any]) -> str:
        """Gera hash √∫nico para o produto"""
        try:
            # Combina dados principais do produto
            key_data = f"{product_data.get('title', '')}|{product_data.get('price', '')}|{product_data.get('store', '')}"
            hash_object = hashlib.md5(key_data.encode())
            return hash_object.hexdigest()
        except Exception as e:
            logger.error(f"Erro ao gerar hash: {e}")
            return ""

    def add_product(self, product_data: Dict[str, Any]) -> Optional[int]:
        """Adiciona um novo produto ao banco"""
        try:
            cursor = self.connection.cursor()

            # Gera hash √∫nico
            hash_id = self._generate_hash_id(product_data)

            # Verifica se o produto j√° existe
            existing_product = self.get_product_by_hash(hash_id)
            if existing_product:
                # Atualiza produto existente
                return self._update_product(existing_product["id"], product_data)

            # Insere novo produto
            cursor.execute(
                """
                INSERT INTO products (
                    title, price, original_price, url, affiliate_url, store, source,
                    category, image_url, rating, description, hash_id
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    product_data.get("title", ""),
                    product_data.get("price", ""),
                    product_data.get("preco_original"),
                    product_data.get("url_produto", ""),
                    product_data.get("affiliate_url"),
                    product_data.get("loja", ""),
                    product_data.get("fonte", ""),
                    product_data.get("categoria"),
                    product_data.get("imagem_url"),
                    product_data.get("avaliacao"),
                    product_data.get("descricao"),
                    hash_id,
                ),
            )

            product_id = cursor.lastrowid

            # Adiciona ao hist√≥rico de pre√ßos
            self._add_price_history(product_id, product_data)

            self.connection.commit()
            logger.info(f"Produto adicionado com sucesso: ID {product_id}")
            return product_id

        except Exception as e:
            logger.error(f"Erro ao adicionar produto: {e}")
            return None

    def _update_product(self, product_id: int, product_data: Dict[str, Any]) -> int:
        """Atualiza um produto existente"""
        try:
            cursor = self.connection.cursor()

            cursor.execute(
                """
                UPDATE products SET
                    title = ?, price = ?, original_price = ?, affiliate_url = ?,
                    category = ?, image_url = ?, rating = ?, description = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """,
                (
                    product_data.get("title", ""),
                    product_data.get("price", ""),
                    product_data.get("preco_original"),
                    product_data.get("affiliate_url"),
                    product_data.get("categoria"),
                    product_data.get("imagem_url"),
                    product_data.get("avaliacao"),
                    product_data.get("descricao"),
                    product_id,
                ),
            )

            # Adiciona ao hist√≥rico de pre√ßos se o pre√ßo mudou
            self._add_price_history(product_id, product_data)

            self.connection.commit()
            logger.info(f"Produto atualizado: ID {product_id}")
            return product_id

        except Exception as e:
            logger.error(f"Erro ao atualizar produto: {e}")
            return product_id

    def _add_price_history(self, product_id: int, product_data: Dict[str, Any]):
        """Adiciona entrada ao hist√≥rico de pre√ßos"""
        try:
            cursor = self.connection.cursor()

            # Verifica se o pre√ßo mudou
            current_price = product_data.get("price", "")
            original_price = product_data.get("preco_original")
            source = product_data.get("fonte", "")

            cursor.execute(
                """
                INSERT INTO price_history (product_id, price, original_price, source)
                VALUES (?, ?, ?, ?)
            """,
                (product_id, current_price, original_price, source),
            )

        except Exception as e:
            logger.error(f"Erro ao adicionar hist√≥rico de pre√ßos: {e}")

    def get_product_by_hash(self, hash_id: str) -> Optional[Dict[str, Any]]:
        """Busca produto por hash"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT * FROM products WHERE hash_id = ?", (hash_id,))
            row = cursor.fetchone()

            if row:
                return dict(row)
            return None

        except Exception as e:
            logger.error(f"Erro ao buscar produto por hash: {e}")
            return None

    def get_products(
        self,
        limit: int = 100,
        offset: int = 0,
        store: Optional[str] = None,
        category: Optional[str] = None,
        active_only: bool = True,
    ) -> List[Dict[str, Any]]:
        """Busca produtos com filtros"""
        try:
            cursor = self.connection.cursor()

            query = "SELECT * FROM products WHERE 1=1"
            params = []

            if store:
                query += " AND store LIKE ?"
                params.append(f"%{store}%")

            if category:
                query += " AND category LIKE ?"
                params.append(f"%{category}%")

            if active_only:
                query += " AND is_active = 1"

            query += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

            cursor.execute(query, params)
            rows = cursor.fetchall()

            return [dict(row) for row in rows]

        except Exception as e:
            logger.error(f"Erro ao buscar produtos: {e}")
            return []

    def get_price_history(
        self, product_id: int, days: int = 30
    ) -> List[Dict[str, Any]]:
        """Busca hist√≥rico de pre√ßos de um produto"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            cursor.execute(
                """
                SELECT * FROM price_history 
                WHERE product_id = ? AND recorded_at >= ?
                ORDER BY recorded_at DESC
            """,
                (product_id, start_date),
            )

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            logger.error(f"Erro ao buscar hist√≥rico de pre√ßos: {e}")
            return []

    def get_lowest_price(
        self, product_id: int, days: int = 90
    ) -> Optional[Dict[str, Any]]:
        """Busca o menor pre√ßo de um produto em um per√≠odo"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            cursor.execute(
                """
                SELECT MIN(CAST(REPLACE(REPLACE(price, 'R$', ''), ',', '.') AS REAL)) as min_price,
                       recorded_at, source
                FROM price_history 
                WHERE product_id = ? AND recorded_at >= ?
                AND price != 'Pre√ßo n√£o informado'
            """,
                (product_id, start_date),
            )

            row = cursor.fetchone()
            if row and row["min_price"]:
                return {
                    "min_price": f"R$ {row['min_price']:.2f}".replace(".", ","),
                    "recorded_at": row["recorded_at"],
                    "source": row["source"],
                }
            return None

        except Exception as e:
            logger.error(f"Erro ao buscar menor pre√ßo: {e}")
            return None

    def add_affiliate_click(
        self,
        product_id: int,
        affiliate_url: str,
        store: str,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
    ) -> bool:
        """Registra clique em link de afiliado"""
        try:
            cursor = self.connection.cursor()

            cursor.execute(
                """
                INSERT INTO affiliate_clicks (product_id, affiliate_url, store, user_agent, ip_address)
                VALUES (?, ?, ?, ?, ?)
            """,
                (product_id, affiliate_url, store, user_agent, ip_address),
            )

            self.connection.commit()
            logger.info(f"Clique registrado para produto {product_id}")
            return True

        except Exception as e:
            logger.error(f"Erro ao registrar clique: {e}")
            return False

    def get_affiliate_stats(self, days: int = 30) -> Dict[str, Any]:
        """Busca estat√≠sticas de afiliados"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            # Total de produtos
            cursor.execute("SELECT COUNT(*) as total FROM products WHERE is_active = 1")
            total_products = cursor.fetchone()["total"]

            # Total de links de afiliado
            cursor.execute(
                "SELECT COUNT(*) as total FROM products WHERE affiliate_url IS NOT NULL AND is_active = 1"
            )
            total_affiliate_links = cursor.fetchone()["total"]

            # Total de cliques
            cursor.execute(
                "SELECT COUNT(*) as total FROM affiliate_clicks WHERE clicked_at >= ?",
                (start_date,),
            )
            total_clicks = cursor.fetchone()["total"]

            # Cliques por loja
            cursor.execute(
                """
                SELECT store, COUNT(*) as clicks
                FROM affiliate_clicks 
                WHERE clicked_at >= ?
                GROUP BY store
                ORDER BY clicks DESC
            """,
                (start_date,),
            )

            clicks_by_store = {row["store"]: row["clicks"] for row in cursor.fetchall()}

            # Produtos mais clicados
            cursor.execute(
                """
                SELECT p.title, p.store, COUNT(ac.id) as clicks
                FROM products p
                JOIN affiliate_clicks ac ON p.id = ac.product_id
                WHERE ac.clicked_at >= ?
                GROUP BY p.id
                ORDER BY clicks DESC
                LIMIT 10
            """,
                (start_date,),
            )

            top_products = [dict(row) for row in cursor.fetchall()]

            return {
                "total_products": total_products,
                "total_affiliate_links": total_affiliate_links,
                "total_clicks": total_clicks,
                "clicks_by_store": clicks_by_store,
                "top_products": top_products,
                "period_days": days,
            }

        except Exception as e:
            logger.error(f"Erro ao buscar estat√≠sticas: {e}")
            return {}

    def update_daily_statistics(self):
        """Atualiza estat√≠sticas di√°rias"""
        try:
            cursor = self.connection.cursor()
            today = datetime.now().date()

            # Busca estat√≠sticas do dia
            stats = self.get_affiliate_stats(days=1)

            # Insere ou atualiza estat√≠sticas do dia
            cursor.execute(
                """
                INSERT OR REPLACE INTO statistics 
                (date, total_products, total_affiliate_links, total_clicks, total_revenue)
                VALUES (?, ?, ?, ?, ?)
            """,
                (
                    today,
                    stats.get("total_products", 0),
                    stats.get("total_affiliate_links", 0),
                    stats.get("total_clicks", 0),
                    0.0,  # Revenue seria calculado separadamente
                ),
            )

            self.connection.commit()
            logger.info("Estat√≠sticas di√°rias atualizadas")

        except Exception as e:
            logger.error(f"Erro ao atualizar estat√≠sticas di√°rias: {e}")

    def cleanup_old_data(self, days: int = 90):
        """Remove dados antigos para manter performance"""
        try:
            cursor = self.connection.cursor()
            cutoff_date = datetime.now() - timedelta(days=days)

            # Remove hist√≥rico de pre√ßos antigo
            cursor.execute(
                "DELETE FROM price_history WHERE recorded_at < ?", (cutoff_date,)
            )
            price_history_deleted = cursor.rowcount

            # Remove cliques antigos
            cursor.execute(
                "DELETE FROM affiliate_clicks WHERE clicked_at < ?", (cutoff_date,)
            )
            clicks_deleted = cursor.rowcount

            # Desativa produtos antigos (n√£o remove, apenas marca como inativo)
            cursor.execute(
                """
                UPDATE products 
                SET is_active = 0 
                WHERE updated_at < ? AND is_active = 1
            """,
                (cutoff_date,),
            )
            products_deactivated = cursor.rowcount

            self.connection.commit()

            logger.info(
                f"Limpeza conclu√≠da: {price_history_deleted} pre√ßos, {clicks_deleted} cliques, {products_deactivated} produtos desativados"
            )

        except Exception as e:
            logger.error(f"Erro na limpeza de dados: {e}")

    def get_database_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas do banco de dados"""
        try:
            cursor = self.connection.cursor()

            # Contagem de registros
            cursor.execute("SELECT COUNT(*) as total FROM products")
            total_products = cursor.fetchone()["total"]

            cursor.execute("SELECT COUNT(*) as total FROM price_history")
            total_price_history = cursor.fetchone()["total"]

            cursor.execute("SELECT COUNT(*) as total FROM affiliate_clicks")
            total_clicks = cursor.fetchone()["total"]

            # Tamanho do banco
            cursor.execute(
                "SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()"
            )
            db_size = cursor.fetchone()["size"]

            return {
                "total_products": total_products,
                "total_price_history": total_price_history,
                "total_clicks": total_clicks,
                "database_size_bytes": db_size,
                "database_size_mb": round(db_size / (1024 * 1024), 2),
            }

        except Exception as e:
            logger.error(f"Erro ao buscar estat√≠sticas do banco: {e}")
            return {}

    def close(self):
        """Fecha conex√£o com o banco"""
        if self.connection:
            self.connection.close()
            logger.info("Conex√£o com banco fechada")


def main():
    """Fun√ß√£o de teste"""
    print("üóÑÔ∏è TESTANDO SISTEMA DE BANCO DE DADOS SQL")
    print("=" * 60)

    try:
        # Cria inst√¢ncia do banco
        db = DatabaseManager()

        # Produtos de teste
        test_products = [
            {
                "titulo": "Smartphone Samsung Galaxy S23",
                "preco": "R$ 2.999,00",
                "preco_original": "R$ 3.499,00",
                "url_produto": "https://www.amazon.com.br/dp/B0BSHF8V7K",
                "loja": "Amazon",
                "fonte": "Amazon",
                "categoria": "Smartphones",
                "imagem_url": "https://example.com/s23.jpg",
                "avaliacao": 4.5,
                "descricao": "Smartphone Samsung Galaxy S23 128GB",
            },
            {
                "titulo": "Notebook Gamer Acer Nitro 5",
                "preco": "R$ 4.599,00",
                "preco_original": "R$ 5.199,00",
                "url_produto": "https://www.shopee.com.br/notebook-gamer-acer-nitro-5",
                "loja": "Shopee",
                "fonte": "Shopee",
                "categoria": "Notebooks",
                "imagem_url": "https://example.com/nitro5.jpg",
                "avaliacao": 4.8,
                "descricao": "Notebook Gamer Acer Nitro 5 RTX 3050",
            },
        ]

        print("üì¶ Adicionando produtos de teste...")
        for product_data in test_products:
            product_id = db.add_product(product_data)
            if product_id:
                print(f"   ‚úÖ Produto adicionado: ID {product_id}")
            else:
                print("   ‚ùå Falha ao adicionar produto")

        print("\nüîç Buscando produtos...")
        products = db.get_products(limit=10)
        print(f"   üìä Total de produtos: {len(products)}")

        for product in products:
            print(f"   üì¶ {product['title']} - {product['store']} - {product['price']}")

        print("\nüìà Buscando estat√≠sticas...")
        stats = db.get_affiliate_stats(days=30)
        print(f"   üìä Produtos: {stats.get('total_products', 0)}")
        print(f"   üîó Links de afiliado: {stats.get('total_affiliate_links', 0)}")
        print(f"   üëÜ Cliques: {stats.get('total_clicks', 0)}")

        print("\nüóÑÔ∏è Estat√≠sticas do banco...")
        db_stats = db.get_database_stats()
        print(f"   üìä Tamanho do banco: {db_stats.get('database_size_mb', 0)} MB")
        print(f"   üì¶ Total de produtos: {db_stats.get('total_products', 0)}")
        print(f"   üìà Hist√≥rico de pre√ßos: {db_stats.get('total_price_history', 0)}")

        # Fecha conex√£o
        db.close()

        print("\n‚úÖ Teste do banco de dados conclu√≠do com sucesso!")

    except Exception as e:
        print(f"‚ùå Erro no teste: {e}")


if __name__ == "__main__":
    main()
