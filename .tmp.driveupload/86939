#!/usr/bin/env python3
"""
Sistema de Banco de Dados SQL para Produtos e Histórico de Preços
Implementa armazenamento persistente de dados do sistema de afiliados
"""

import sqlite3
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import hashlib

logger = logging.getLogger("database_sql")


@dataclass
class Product:
    """Modelo de dados para produtos"""

    id: Optional[int]
    title: str
    price: str
    original_price: Optional[str]
    url: str
    affiliate_url: Optional[str]
    store: str
    source: str
    category: Optional[str]
    image_url: Optional[str]
    rating: Optional[float]
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
    is_active: bool = True


@dataclass
class PriceHistory:
    """Modelo de dados para histórico de preços"""

    id: Optional[int]
    product_id: int
    price: str
    original_price: Optional[str]
    recorded_at: datetime
    source: str


@dataclass
class AffiliateClick:
    """Modelo de dados para cliques em links de afiliado"""

    id: Optional[int]
    product_id: int
    affiliate_url: str
    store: str
    clicked_at: datetime
    user_agent: Optional[str]
    ip_address: Optional[str]


class DatabaseManager:
    """Gerenciador do banco de dados SQLite"""

    def __init__(self, db_path: str = "garimpeirogeek.db"):
        self.db_path = db_path
        self.connection = None
        self.init_database()

    def init_database(self):
        """Inicializa o banco de dados e cria as tabelas"""
        try:
            self.connection = sqlite3.connect(self.db_path)
            self.connection.row_factory = sqlite3.Row

            # Cria tabelas
            self._create_tables()

            # Cria índices para performance
            self._create_indexes()

            logger.info("Banco de dados inicializado com sucesso")

        except Exception as e:
            logger.error(f"Erro ao inicializar banco de dados: {e}")
            raise

    def _create_tables(self):
        """Cria as tabelas do banco de dados"""
        try:
            cursor = self.connection.cursor()

            # Tabela de produtos
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    title TEXT NOT NULL,
                    price TEXT NOT NULL,
                    original_price TEXT,
                    url TEXT NOT NULL UNIQUE,
                    affiliate_url TEXT,
                    store TEXT NOT NULL,
                    source TEXT NOT NULL,
                    category TEXT,
                    image_url TEXT,
                    rating REAL,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT 1,
                    hash_id TEXT UNIQUE
                )
            """)

            # Tabela de histórico de preços
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS price_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    price TEXT NOT NULL,
                    original_price TEXT,
                    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    source TEXT NOT NULL,
                    FOREIGN KEY (product_id) REFERENCES products (id)
                )
            """)

            # Tabela de cliques em links de afiliado
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS affiliate_clicks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    product_id INTEGER NOT NULL,
                    affiliate_url TEXT NOT NULL,
                    store TEXT NOT NULL,
                    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    user_agent TEXT,
                    ip_address TEXT,
                    FOREIGN KEY (product_id) REFERENCES products (id)
                )
            """)

            # Tabela de estatísticas
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS statistics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE UNIQUE,
                    total_products INTEGER DEFAULT 0,
                    total_affiliate_links INTEGER DEFAULT 0,
                    total_clicks INTEGER DEFAULT 0,
                    total_revenue REAL DEFAULT 0.0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            self.connection.commit()
            logger.info("Tabelas criadas com sucesso")

        except Exception as e:
            logger.error(f"Erro ao criar tabelas: {e}")
            raise

    def _create_indexes(self):
        """Cria índices para melhorar performance"""
        try:
            cursor = self.connection.cursor()

            # Índices para produtos
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_store ON products(store)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_source ON products(source)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_category ON products(category)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_created_at ON products(created_at)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_products_hash_id ON products(hash_id)"
            )

            # Índices para histórico de preços
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_price_history_product_id ON price_history(product_id)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_price_history_recorded_at ON price_history(recorded_at)"
            )

            # Índices para cliques
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_product_id ON affiliate_clicks(product_id)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_store ON affiliate_clicks(store)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_affiliate_clicks_clicked_at ON affiliate_clicks(clicked_at)"
            )

            self.connection.commit()
            logger.info("Índices criados com sucesso")

        except Exception as e:
            logger.error(f"Erro ao criar índices: {e}")

    def _generate_hash_id(self, product_data: Dict[str, Any]) -> str:
        """Gera hash único para o produto"""
        try:
            # Combina dados principais do produto
            key_data = f"{product_data.get('title', '')}|{product_data.get('price', '')}|{product_data.get('store', '')}"
            hash_object = hashlib.md5(key_data.encode())
            return hash_object.hexdigest()
        except Exception as e:
            logger.error(f"Erro ao gerar hash: {e}")
            return ""

    def add_product(self, product_data: Dict[str, Any]) -> Optional[int]:
        """Adiciona um novo produto ao banco"""
        try:
            cursor = self.connection.cursor()

            # Gera hash único
            hash_id = self._generate_hash_id(product_data)

            # Verifica se o produto já existe
            existing_product = self.get_product_by_hash(hash_id)
            if existing_product:
                # Atualiza produto existente
                return self._update_product(existing_product["id"], product_data)

            # Insere novo produto
            cursor.execute(
                """
                INSERT INTO products (
                    title, price, original_price, url, affiliate_url, store, source,
                    category, image_url, rating, description, hash_id
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    product_data.get("title", ""),
                    product_data.get("price", ""),
                    product_data.get("preco_original"),
                    product_data.get("url_produto", ""),
                    product_data.get("affiliate_url"),
                    product_data.get("loja", ""),
                    product_data.get("fonte", ""),
                    product_data.get("categoria"),
                    product_data.get("imagem_url"),
                    product_data.get("avaliacao"),
                    product_data.get("descricao"),
                    hash_id,
                ),
            )

            product_id = cursor.lastrowid

            # Adiciona ao histórico de preços
            self._add_price_history(product_id, product_data)

            self.connection.commit()
            logger.info(f"Produto adicionado com sucesso: ID {product_id}")
            return product_id

        except Exception as e:
            logger.error(f"Erro ao adicionar produto: {e}")
            return None

    def _update_product(self, product_id: int, product_data: Dict[str, Any]) -> int:
        """Atualiza um produto existente"""
        try:
            cursor = self.connection.cursor()

            cursor.execute(
                """
                UPDATE products SET
                    title = ?, price = ?, original_price = ?, affiliate_url = ?,
                    category = ?, image_url = ?, rating = ?, description = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """,
                (
                    product_data.get("title", ""),
                    product_data.get("price", ""),
                    product_data.get("preco_original"),
                    product_data.get("affiliate_url"),
                    product_data.get("categoria"),
                    product_data.get("imagem_url"),
                    product_data.get("avaliacao"),
                    product_data.get("descricao"),
                    product_id,
                ),
            )

            # Adiciona ao histórico de preços se o preço mudou
            self._add_price_history(product_id, product_data)

            self.connection.commit()
            logger.info(f"Produto atualizado: ID {product_id}")
            return product_id

        except Exception as e:
            logger.error(f"Erro ao atualizar produto: {e}")
            return product_id

    def _add_price_history(self, product_id: int, product_data: Dict[str, Any]):
        """Adiciona entrada ao histórico de preços"""
        try:
            cursor = self.connection.cursor()

            # Verifica se o preço mudou
            current_price = product_data.get("price", "")
            original_price = product_data.get("preco_original")
            source = product_data.get("fonte", "")

            cursor.execute(
                """
                INSERT INTO price_history (product_id, price, original_price, source)
                VALUES (?, ?, ?, ?)
            """,
                (product_id, current_price, original_price, source),
            )

        except Exception as e:
            logger.error(f"Erro ao adicionar histórico de preços: {e}")

    def get_product_by_hash(self, hash_id: str) -> Optional[Dict[str, Any]]:
        """Busca produto por hash"""
        try:
            cursor = self.connection.cursor()
            cursor.execute("SELECT * FROM products WHERE hash_id = ?", (hash_id,))
            row = cursor.fetchone()

            if row:
                return dict(row)
            return None

        except Exception as e:
            logger.error(f"Erro ao buscar produto por hash: {e}")
            return None

    def get_products(
        self,
        limit: int = 100,
        offset: int = 0,
        store: Optional[str] = None,
        category: Optional[str] = None,
        active_only: bool = True,
    ) -> List[Dict[str, Any]]:
        """Busca produtos com filtros"""
        try:
            cursor = self.connection.cursor()

            query = "SELECT * FROM products WHERE 1=1"
            params = []

            if store:
                query += " AND store LIKE ?"
                params.append(f"%{store}%")

            if category:
                query += " AND category LIKE ?"
                params.append(f"%{category}%")

            if active_only:
                query += " AND is_active = 1"

            query += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

            cursor.execute(query, params)
            rows = cursor.fetchall()

            return [dict(row) for row in rows]

        except Exception as e:
            logger.error(f"Erro ao buscar produtos: {e}")
            return []

    def get_price_history(
        self, product_id: int, days: int = 30
    ) -> List[Dict[str, Any]]:
        """Busca histórico de preços de um produto"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            cursor.execute(
                """
                SELECT * FROM price_history 
                WHERE product_id = ? AND recorded_at >= ?
                ORDER BY recorded_at DESC
            """,
                (product_id, start_date),
            )

            rows = cursor.fetchall()
            return [dict(row) for row in rows]

        except Exception as e:
            logger.error(f"Erro ao buscar histórico de preços: {e}")
            return []

    def get_lowest_price(
        self, product_id: int, days: int = 90
    ) -> Optional[Dict[str, Any]]:
        """Busca o menor preço de um produto em um período"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            cursor.execute(
                """
                SELECT MIN(CAST(REPLACE(REPLACE(price, 'R$', ''), ',', '.') AS REAL)) as min_price,
                       recorded_at, source
                FROM price_history 
                WHERE product_id = ? AND recorded_at >= ?
                AND price != 'Preço não informado'
            """,
                (product_id, start_date),
            )

            row = cursor.fetchone()
            if row and row["min_price"]:
                return {
                    "min_price": f"R$ {row['min_price']:.2f}".replace(".", ","),
                    "recorded_at": row["recorded_at"],
                    "source": row["source"],
                }
            return None

        except Exception as e:
            logger.error(f"Erro ao buscar menor preço: {e}")
            return None

    def add_affiliate_click(
        self,
        product_id: int,
        affiliate_url: str,
        store: str,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
    ) -> bool:
        """Registra clique em link de afiliado"""
        try:
            cursor = self.connection.cursor()

            cursor.execute(
                """
                INSERT INTO affiliate_clicks (product_id, affiliate_url, store, user_agent, ip_address)
                VALUES (?, ?, ?, ?, ?)
            """,
                (product_id, affiliate_url, store, user_agent, ip_address),
            )

            self.connection.commit()
            logger.info(f"Clique registrado para produto {product_id}")
            return True

        except Exception as e:
            logger.error(f"Erro ao registrar clique: {e}")
            return False

    def get_affiliate_stats(self, days: int = 30) -> Dict[str, Any]:
        """Busca estatísticas de afiliados"""
        try:
            cursor = self.connection.cursor()

            start_date = datetime.now() - timedelta(days=days)

            # Total de produtos
            cursor.execute("SELECT COUNT(*) as total FROM products WHERE is_active = 1")
            total_products = cursor.fetchone()["total"]

            # Total de links de afiliado
            cursor.execute(
                "SELECT COUNT(*) as total FROM products WHERE affiliate_url IS NOT NULL AND is_active = 1"
            )
            total_affiliate_links = cursor.fetchone()["total"]

            # Total de cliques
            cursor.execute(
                "SELECT COUNT(*) as total FROM affiliate_clicks WHERE clicked_at >= ?",
                (start_date,),
            )
            total_clicks = cursor.fetchone()["total"]

            # Cliques por loja
            cursor.execute(
                """
                SELECT store, COUNT(*) as clicks
                FROM affiliate_clicks 
                WHERE clicked_at >= ?
                GROUP BY store
                ORDER BY clicks DESC
            """,
                (start_date,),
            )

            clicks_by_store = {row["store"]: row["clicks"] for row in cursor.fetchall()}

            # Produtos mais clicados
            cursor.execute(
                """
                SELECT p.title, p.store, COUNT(ac.id) as clicks
                FROM products p
                JOIN affiliate_clicks ac ON p.id = ac.product_id
                WHERE ac.clicked_at >= ?
                GROUP BY p.id
                ORDER BY clicks DESC
                LIMIT 10
            """,
                (start_date,),
            )

            top_products = [dict(row) for row in cursor.fetchall()]

            return {
                "total_products": total_products,
                "total_affiliate_links": total_affiliate_links,
                "total_clicks": total_clicks,
                "clicks_by_store": clicks_by_store,
                "top_products": top_products,
                "period_days": days,
            }

        except Exception as e:
            logger.error(f"Erro ao buscar estatísticas: {e}")
            return {}

    def update_daily_statistics(self):
        """Atualiza estatísticas diárias"""
        try:
            cursor = self.connection.cursor()
            today = datetime.now().date()

            # Busca estatísticas do dia
            stats = self.get_affiliate_stats(days=1)

            # Insere ou atualiza estatísticas do dia
            cursor.execute(
                """
                INSERT OR REPLACE INTO statistics 
                (date, total_products, total_affiliate_links, total_clicks, total_revenue)
                VALUES (?, ?, ?, ?, ?)
            """,
                (
                    today,
                    stats.get("total_products", 0),
                    stats.get("total_affiliate_links", 0),
                    stats.get("total_clicks", 0),
                    0.0,  # Revenue seria calculado separadamente
                ),
            )

            self.connection.commit()
            logger.info("Estatísticas diárias atualizadas")

        except Exception as e:
            logger.error(f"Erro ao atualizar estatísticas diárias: {e}")

    def cleanup_old_data(self, days: int = 90):
        """Remove dados antigos para manter performance"""
        try:
            cursor = self.connection.cursor()
            cutoff_date = datetime.now() - timedelta(days=days)

            # Remove histórico de preços antigo
            cursor.execute(
                "DELETE FROM price_history WHERE recorded_at < ?", (cutoff_date,)
            )
            price_history_deleted = cursor.rowcount

            # Remove cliques antigos
            cursor.execute(
                "DELETE FROM affiliate_clicks WHERE clicked_at < ?", (cutoff_date,)
            )
            clicks_deleted = cursor.rowcount

            # Desativa produtos antigos (não remove, apenas marca como inativo)
            cursor.execute(
                """
                UPDATE products 
                SET is_active = 0 
                WHERE updated_at < ? AND is_active = 1
            """,
                (cutoff_date,),
            )
            products_deactivated = cursor.rowcount

            self.connection.commit()

            logger.info(
                f"Limpeza concluída: {price_history_deleted} preços, {clicks_deleted} cliques, {products_deactivated} produtos desativados"
            )

        except Exception as e:
            logger.error(f"Erro na limpeza de dados: {e}")

    def get_database_stats(self) -> Dict[str, Any]:
        """Retorna estatísticas do banco de dados"""
        try:
            cursor = self.connection.cursor()

            # Contagem de registros
            cursor.execute("SELECT COUNT(*) as total FROM products")
            total_products = cursor.fetchone()["total"]

            cursor.execute("SELECT COUNT(*) as total FROM price_history")
            total_price_history = cursor.fetchone()["total"]

            cursor.execute("SELECT COUNT(*) as total FROM affiliate_clicks")
            total_clicks = cursor.fetchone()["total"]

            # Tamanho do banco
            cursor.execute(
                "SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()"
            )
            db_size = cursor.fetchone()["size"]

            return {
                "total_products": total_products,
                "total_price_history": total_price_history,
                "total_clicks": total_clicks,
                "database_size_bytes": db_size,
                "database_size_mb": round(db_size / (1024 * 1024), 2),
            }

        except Exception as e:
            logger.error(f"Erro ao buscar estatísticas do banco: {e}")
            return {}

    def close(self):
        """Fecha conexão com o banco"""
        if self.connection:
            self.connection.close()
            logger.info("Conexão com banco fechada")


def main():
    """Função de teste"""
    print("🗄️ TESTANDO SISTEMA DE BANCO DE DADOS SQL")
    print("=" * 60)

    try:
        # Cria instância do banco
        db = DatabaseManager()

        # Produtos de teste
        test_products = [
            {
                "titulo": "Smartphone Samsung Galaxy S23",
                "preco": "R$ 2.999,00",
                "preco_original": "R$ 3.499,00",
                "url_produto": "https://www.amazon.com.br/dp/B0BSHF8V7K",
                "loja": "Amazon",
                "fonte": "Amazon",
                "categoria": "Smartphones",
                "imagem_url": "https://example.com/s23.jpg",
                "avaliacao": 4.5,
                "descricao": "Smartphone Samsung Galaxy S23 128GB",
            },
            {
                "titulo": "Notebook Gamer Acer Nitro 5",
                "preco": "R$ 4.599,00",
                "preco_original": "R$ 5.199,00",
                "url_produto": "https://www.shopee.com.br/notebook-gamer-acer-nitro-5",
                "loja": "Shopee",
                "fonte": "Shopee",
                "categoria": "Notebooks",
                "imagem_url": "https://example.com/nitro5.jpg",
                "avaliacao": 4.8,
                "descricao": "Notebook Gamer Acer Nitro 5 RTX 3050",
            },
        ]

        print("📦 Adicionando produtos de teste...")
        for product_data in test_products:
            product_id = db.add_product(product_data)
            if product_id:
                print(f"   ✅ Produto adicionado: ID {product_id}")
            else:
                print("   ❌ Falha ao adicionar produto")

        print("\n🔍 Buscando produtos...")
        products = db.get_products(limit=10)
        print(f"   📊 Total de produtos: {len(products)}")

        for product in products:
            print(f"   📦 {product['title']} - {product['store']} - {product['price']}")

        print("\n📈 Buscando estatísticas...")
        stats = db.get_affiliate_stats(days=30)
        print(f"   📊 Produtos: {stats.get('total_products', 0)}")
        print(f"   🔗 Links de afiliado: {stats.get('total_affiliate_links', 0)}")
        print(f"   👆 Cliques: {stats.get('total_clicks', 0)}")

        print("\n🗄️ Estatísticas do banco...")
        db_stats = db.get_database_stats()
        print(f"   📊 Tamanho do banco: {db_stats.get('database_size_mb', 0)} MB")
        print(f"   📦 Total de produtos: {db_stats.get('total_products', 0)}")
        print(f"   📈 Histórico de preços: {db_stats.get('total_price_history', 0)}")

        # Fecha conexão
        db.close()

        print("\n✅ Teste do banco de dados concluído com sucesso!")

    except Exception as e:
        print(f"❌ Erro no teste: {e}")


if __name__ == "__main__":
    main()
