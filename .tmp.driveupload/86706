#!/usr/bin/env python3
"""
Bot do Telegram Espec√≠fico para Shopee
Implementa os 3 modelos de mensagem especificados pelo usu√°rio
"""

import asyncio
import logging
from datetime import datetime
from typing import Optional
from dataclasses import dataclass

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram.constants import ParseMode

import config
from shopee_integration_system import ShopeeAPIIntegration, SortType, ListType

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@dataclass
class ShopeeOffer:
    """Estrutura de dados para oferta da Shopee"""

    price: float
    commission: float
    commission_rate: float
    product_link: str
    offer_link: str
    rating_star: Optional[float]
    shop_name: Optional[str]
    timestamp: datetime
    page: int
    sort_type: SortType
    list_type: ListType


class ShopeeTelegramBot:
    """Bot do Telegram especializado em ofertas da Shopee"""

    def __init__(self):
        self.bot_token = config.TELEGRAM_BOT_TOKEN
        self.chat_id = config.TELEGRAM_CHAT_ID
        self.admin_id = config.ADMIN_USER_ID

        # API da Shopee
        self.shopee_api = ShopeeAPIIntegration(
            app_id="18330800803", app_secret="IOMXMSUM5KDOLSYKXQERKCU42SNMJERR"
        )

        # Configura√ß√µes
        self.min_discount_threshold = 30.0  # 30% de desconto m√≠nimo
        self.price_history_days = 180  # 6 meses para hist√≥rico
        self.offers_per_message = 3  # M√°ximo de ofertas por mensagem

        # Hist√≥rico de pre√ßos (simulado - em produ√ß√£o usar banco de dados)
        self.price_history = {}

        logger.info("üöÄ Bot da Shopee inicializado")

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start - Menu principal"""
        keyboard = [
            [InlineKeyboardButton("üõçÔ∏è Melhores Ofertas", callback_data="best_offers")],
            [InlineKeyboardButton("üí∞ Ofertas por Pre√ßo", callback_data="price_range")],
            [InlineKeyboardButton("‚≠ê Ofertas do Dia", callback_data="daily_deals")],
            [
                InlineKeyboardButton(
                    "üîç Buscar Produtos", callback_data="search_products"
                )
            ],
            [InlineKeyboardButton("üìä Estat√≠sticas", callback_data="stats")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            "üî• **Bot de Ofertas da Shopee** üî•\n\n"
            "Encontre as melhores ofertas com links de afiliado!\n"
            "Escolha uma op√ß√£o:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipula os bot√µes inline"""
        query = update.callback_query
        await query.answer()

        if query.data == "best_offers":
            await self.send_best_offers(update, context)
        elif query.data == "price_range":
            await self.send_price_range_menu(update, context)
        elif query.data == "daily_deals":
            await self.send_daily_deals(update, context)
        elif query.data == "search_products":
            await self.send_search_menu(update, context)
        elif query.data == "stats":
            await self.send_stats(update, context)
        elif query.data.startswith("price_"):
            # Formato: price_10_50 (R$ 10 a R$ 50)
            _, min_price, max_price = query.data.split("_")
            await self.send_offers_by_price_range(
                update, context, float(min_price), float(max_price)
            )

    async def send_best_offers(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Envia as melhores ofertas da Shopee"""
        try:
            # Busca ofertas ordenadas por comiss√£o
            offers = self.shopee_api.get_product_offers(
                page=0, limit=10, sort_type=SortType.COMMISSION_HIGH_LOW
            )

            if not offers:
                await update.callback_query.edit_message_text(
                    "‚ùå Nenhuma oferta encontrada no momento."
                )
                return

            # Filtra ofertas com desconto significativo
            best_offers = [offer for offer in offers if offer.commission_rate > 5.0]

            if not best_offers:
                best_offers = offers[:3]  # Usa as primeiras se n√£o houver desconto

            # Envia cada oferta com o modelo apropriado
            for i, offer in enumerate(best_offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                # Delay entre mensagens para evitar spam
                if i < len(best_offers) - 1:
                    await asyncio.sleep(1)

            # Bot√£o para mais ofertas
            keyboard = [
                [InlineKeyboardButton("üîÑ Mais Ofertas", callback_data="best_offers")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"‚úÖ **{len(best_offers)} melhores ofertas enviadas!**\n\n"
                "Quer ver mais ofertas?",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar melhores ofertas: {e}")
            await update.callback_query.edit_message_text(
                "‚ùå Erro ao buscar ofertas. Tente novamente."
            )

    async def send_price_range_menu(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Menu para escolher faixa de pre√ßo"""
        keyboard = [
            [InlineKeyboardButton("üí∞ R$ 10 - R$ 50", callback_data="price_10_50")],
            [InlineKeyboardButton("üí∞ R$ 50 - R$ 100", callback_data="price_50_100")],
            [InlineKeyboardButton("üí∞ R$ 100 - R$ 200", callback_data="price_100_200")],
            [InlineKeyboardButton("üí∞ R$ 200+", callback_data="price_200_1000")],
            [InlineKeyboardButton("üîô Voltar", callback_data="back_to_main")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.callback_query.edit_message_text(
            "üí∞ **Escolha uma faixa de pre√ßo:**\n\n"
            "Selecione o intervalo de pre√ßo desejado:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def send_offers_by_price_range(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        min_price: float,
        max_price: float,
    ):
        """Envia ofertas por faixa de pre√ßo"""
        try:
            offers = self.shopee_api.get_offers_by_price_range(
                min_price, max_price, limit=10
            )

            if not offers:
                await update.callback_query.edit_message_text(
                    f"‚ùå Nenhuma oferta encontrada entre R$ {min_price:.2f} e R$ {max_price:.2f}."
                )
                return

            # Envia as ofertas encontradas
            for i, offer in enumerate(offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            # Bot√£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "üîô Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"‚úÖ **{len(offers)} ofertas encontradas entre R$ {min_price:.2f} e R$ {max_price:.2f}!**\n\n"
                "Quer ver outras faixas de pre√ßo?",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar ofertas por faixa de pre√ßo: {e}")
            await update.callback_query.edit_message_text(
                "‚ùå Erro ao buscar ofertas. Tente novamente."
            )

    async def send_daily_deals(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Envia ofertas do dia"""
        try:
            offers = self.shopee_api.get_daily_deals(limit=5)

            if not offers:
                await update.callback_query.edit_message_text(
                    "‚ùå Nenhuma oferta do dia encontrada."
                )
                return

            # Envia as ofertas do dia
            for i, offer in enumerate(offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            # Bot√£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "üîô Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"‚úÖ **{len(offers)} ofertas do dia enviadas!**\n\n"
                "Volte mais tarde para novas ofertas!",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar ofertas do dia: {e}")
            await update.callback_query.edit_message_text(
                "‚ùå Erro ao buscar ofertas do dia. Tente novamente."
            )

    def determine_message_type(self, offer: ShopeeOffer) -> str:
        """Determina o tipo de mensagem baseado na oferta"""
        # Simula an√°lise de hist√≥rico de pre√ßos
        # Em produ√ß√£o, isso viria de um banco de dados real

        # Modelo 3: Menor Pre√ßo Hist√≥rico (se comiss√£o muito alta)
        if offer.commission_rate > 15.0:
            return "historical_low"

        # Modelo 2: Pre√ßo Baixo Recente (se comiss√£o alta)
        elif offer.commission_rate > 8.0:
            return "recent_low"

        # Modelo 1: Oferta Padr√£o (demais casos)
        else:
            return "standard"

    async def send_offer_message(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        offer: ShopeeOffer,
        message_type: str,
    ):
        """Envia mensagem de oferta com o modelo apropriado"""
        try:
            # Determina o texto baseado no tipo de mensagem
            if message_type == "historical_low":
                text = self.format_historical_low_message(offer)
            elif message_type == "recent_low":
                text = self.format_recent_low_message(offer)
            else:
                text = self.format_standard_message(offer)

            # Bot√£o para ver a oferta
            keyboard = [[InlineKeyboardButton("üõí Ver a Oferta", url=offer.offer_link)]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # Envia a mensagem
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar mensagem de oferta: {e}")

    def format_standard_message(self, offer: ShopeeOffer) -> str:
        """Modelo 1: Oferta Padr√£o (Bom Pre√ßo ou Bom Desconto)"""
        # Simula desconto baseado na comiss√£o
        discount_percentage = min(offer.commission_rate * 2, 50)  # M√°ximo 50%
        original_price = offer.price / (1 - discount_percentage / 100)

        return (
            f"üî• **Oferta Garimpada!** üî•\n\n"
            f"üíª **Produto da Shopee**\n"
            f"üí∞ De ~R$ {original_price:.2f}~ por\n"
            f"üíµ **R$ {offer.price:.2f}** ({discount_percentage:.0f}% de desconto)\n\n"
            f"üè™ Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"üí∏ Comiss√£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"‚≠ê Avalia√ß√£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"üõí **Ver a Oferta**\n"
            f"[Link de Afiliado]"
        )

    def format_recent_low_message(self, offer: ShopeeOffer) -> str:
        """Modelo 2: Pre√ßo Baixo Recente (√ìtima Oportunidade)"""
        return (
            f"üìâ **Alerta de Pre√ßo Baixo!** üìâ\n\n"
            f"üíª **Produto da Shopee**\n"
            f"‚ú® **Menor pre√ßo dos √∫ltimos 6 meses!**\n\n"
            f"üíµ **R$ {offer.price:.2f}**\n\n"
            f"üè™ Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"üí∏ Comiss√£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"‚≠ê Avalia√ß√£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"üõí **Ver a Oferta**\n"
            f"[Link de Afiliado]"
        )

    def format_historical_low_message(self, offer: ShopeeOffer) -> str:
        """Modelo 3: Menor Pre√ßo Hist√≥rico (A Oferta Imperd√≠vel)"""
        return (
            f"üî•üî• **MENOR PRE√áO DA HIST√ìRIA!** üî•üî•\n\n"
            f"üíª **Produto da Shopee**\n"
            f"üíé **Nunca esteve t√£o barato!**\n\n"
            f"üíµ **R$ {offer.price:.2f}**\n\n"
            f"üè™ Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"üí∏ Comiss√£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"‚≠ê Avalia√ß√£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"üõí **Aproveitar Agora!**\n"
            f"[Link de Afiliado]"
        )

    async def send_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Envia estat√≠sticas do bot"""
        try:
            # Busca estat√≠sticas da API da Shopee
            offers = self.shopee_api.get_product_offers(page=0, limit=100)

            if offers:
                total_offers = len(offers)
                avg_price = sum(offer.price for offer in offers) / total_offers
                avg_commission = (
                    sum(offer.commission for offer in offers) / total_offers
                )
                best_commission = max(offer.commission_rate for offer in offers)

                stats_text = (
                    f"üìä **Estat√≠sticas da Shopee**\n\n"
                    f"üõçÔ∏è Total de ofertas: **{total_offers}**\n"
                    f"üí∞ Pre√ßo m√©dio: **R$ {avg_price:.2f}**\n"
                    f"üí∏ Comiss√£o m√©dia: **R$ {avg_commission:.2f}**\n"
                    f"üèÜ Melhor comiss√£o: **{best_commission:.1f}%**\n\n"
                    f"‚è∞ √öltima atualiza√ß√£o: **{datetime.now().strftime('%H:%M')}**"
                )
            else:
                stats_text = "‚ùå Nenhuma estat√≠stica dispon√≠vel no momento."

            # Bot√£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "üîô Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                stats_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN
            )

        except Exception as e:
            logger.error(f"Erro ao enviar estat√≠sticas: {e}")
            await update.callback_query.edit_message_text(
                "‚ùå Erro ao buscar estat√≠sticas."
            )

    async def send_search_menu(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Menu de busca de produtos"""
        await update.callback_query.edit_message_text(
            "üîç **Busca de Produtos**\n\n"
            "Para buscar produtos espec√≠ficos, use:\n"
            "`/buscar [produto]`\n\n"
            "Exemplo: `/buscar smartphone`\n\n"
            "üîô Use /start para voltar ao menu principal.",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def search_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /buscar - Busca produtos espec√≠ficos"""
        if not context.args:
            await update.message.reply_text(
                "üîç **Como usar:**\n"
                "`/buscar [produto]`\n\n"
                "Exemplo: `/buscar smartphone`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return

        keyword = " ".join(context.args)
        await update.message.reply_text(f"üîç Buscando produtos com: **{keyword}**...")

        try:
            # Busca produtos na Shopee
            offers = self.shopee_api.search_products(keyword, page=0, limit=5)

            if not offers:
                await update.message.reply_text(
                    f"‚ùå Nenhum produto encontrado para: **{keyword}**"
                )
                return

            # Envia os produtos encontrados
            for i, offer in enumerate(offers[:3]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            await update.message.reply_text(
                f"‚úÖ **{len(offers)} produtos encontrados para '{keyword}'!**\n\n"
                "Use /start para ver mais op√ß√µes."
            )

        except Exception as e:
            logger.error(f"Erro na busca: {e}")
            await update.message.reply_text("‚ùå Erro na busca. Tente novamente.")

    async def oferta_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /oferta - Mostra ofertas gerais"""
        try:
            await update.message.reply_text("üîç Buscando melhores ofertas...")

            # Busca melhores ofertas
            offers = self.shopee_api.get_product_offers(
                page=0, limit=5, sort_type=SortType.COMMISSION_HIGH_LOW
            )

            if not offers:
                await update.message.reply_text(
                    "‚ùå Nenhuma oferta encontrada no momento."
                )
                return

            # Envia as ofertas
            for i, offer in enumerate(offers[:3]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            await update.message.reply_text(
                f"‚úÖ **{len(offers)} ofertas encontradas!**\n\n"
                "Use /start para ver mais op√ß√µes."
            )

        except Exception as e:
            logger.error(f"Erro ao buscar ofertas: {e}")
            await update.message.reply_text(
                "‚ùå Erro ao buscar ofertas. Tente novamente."
            )

    async def ajuda_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /ajuda - Lista todos os comandos dispon√≠veis"""
        help_text = (
            "ü§ñ **COMANDOS DISPON√çVEIS**\n\n"
            "üìã **Comandos principais:**\n"
            "‚Ä¢ `/start` - Menu principal com bot√µes\n"
            "‚Ä¢ `/oferta` - Ver melhores ofertas\n"
            "‚Ä¢ `/buscar [produto]` - Buscar produtos espec√≠ficos\n"
            "‚Ä¢ `/ajuda` - Esta mensagem de ajuda\n\n"
            "üîç **Exemplos de busca:**\n"
            "‚Ä¢ `/buscar smartphone`\n"
            "‚Ä¢ `/buscar notebook`\n"
            "‚Ä¢ `/buscar fone de ouvido`\n"
            "‚Ä¢ `/buscar mouse`\n\n"
            "üí° **Dica:** Use o menu principal (/start) para navegar facilmente!"
        )

        await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipula erros do bot"""
        logger.error(f"Erro no bot: {context.error}")
        if update and update.effective_chat:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="‚ùå Ocorreu um erro. Tente novamente ou use /start.",
            )

    def run(self):
        """Executa o bot"""
        # Cria a aplica√ß√£o
        application = Application.builder().token(self.bot_token).build()

        # Adiciona handlers
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CommandHandler("buscar", self.search_command))
        application.add_handler(CommandHandler("oferta", self.oferta_command))
        application.add_handler(CommandHandler("ajuda", self.ajuda_command))
        application.add_handler(CallbackQueryHandler(self.button_handler))

        # Adiciona error handler
        application.add_error_handler(self.error_handler)

        # Inicia o bot
        logger.info("üöÄ Bot da Shopee iniciando...")
        application.run_polling()


def main():
    """Fun√ß√£o principal"""
    print("üöÄ INICIANDO BOT DA SHOPEE")
    print("=" * 50)

    try:
        bot = ShopeeTelegramBot()
        bot.run()
    except Exception as e:
        logger.error(f"Erro ao iniciar bot: {e}")
        print(f"‚ùå Erro: {e}")


if __name__ == "__main__":
    main()
