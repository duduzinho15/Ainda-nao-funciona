#!/usr/bin/env python3
"""
Bot do Telegram EspecÃ­fico para Shopee
Implementa os 3 modelos de mensagem especificados pelo usuÃ¡rio
"""

import asyncio
import logging
from datetime import datetime
from typing import Optional
from dataclasses import dataclass

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram.constants import ParseMode

import config
from shopee_integration_system import ShopeeAPIIntegration, SortType, ListType

# ConfiguraÃ§Ã£o de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


@dataclass
class ShopeeOffer:
    """Estrutura de dados para oferta da Shopee"""

    price: float
    commission: float
    commission_rate: float
    product_link: str
    offer_link: str
    rating_star: Optional[float]
    shop_name: Optional[str]
    timestamp: datetime
    page: int
    sort_type: SortType
    list_type: ListType


class ShopeeTelegramBot:
    """Bot do Telegram especializado em ofertas da Shopee"""

    def __init__(self):
        self.bot_token = config.TELEGRAM_BOT_TOKEN
        self.chat_id = config.TELEGRAM_CHAT_ID
        self.admin_id = config.ADMIN_USER_ID

        # API da Shopee
        self.shopee_api = ShopeeAPIIntegration(
            app_id="18330800803", app_secret="IOMXMSUM5KDOLSYKXQERKCU42SNMJERR"
        )

        # ConfiguraÃ§Ãµes
        self.min_discount_threshold = 30.0  # 30% de desconto mÃ­nimo
        self.price_history_days = 180  # 6 meses para histÃ³rico
        self.offers_per_message = 3  # MÃ¡ximo de ofertas por mensagem

        # HistÃ³rico de preÃ§os (simulado - em produÃ§Ã£o usar banco de dados)
        self.price_history = {}

        logger.info("ğŸš€ Bot da Shopee inicializado")

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /start - Menu principal"""
        keyboard = [
            [InlineKeyboardButton("ğŸ›ï¸ Melhores Ofertas", callback_data="best_offers")],
            [InlineKeyboardButton("ğŸ’° Ofertas por PreÃ§o", callback_data="price_range")],
            [InlineKeyboardButton("â­ Ofertas do Dia", callback_data="daily_deals")],
            [
                InlineKeyboardButton(
                    "ğŸ” Buscar Produtos", callback_data="search_products"
                )
            ],
            [InlineKeyboardButton("ğŸ“Š EstatÃ­sticas", callback_data="stats")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            "ğŸ”¥ **Bot de Ofertas da Shopee** ğŸ”¥\n\n"
            "Encontre as melhores ofertas com links de afiliado!\n"
            "Escolha uma opÃ§Ã£o:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipula os botÃµes inline"""
        query = update.callback_query
        await query.answer()

        if query.data == "best_offers":
            await self.send_best_offers(update, context)
        elif query.data == "price_range":
            await self.send_price_range_menu(update, context)
        elif query.data == "daily_deals":
            await self.send_daily_deals(update, context)
        elif query.data == "search_products":
            await self.send_search_menu(update, context)
        elif query.data == "stats":
            await self.send_stats(update, context)
        elif query.data.startswith("price_"):
            # Formato: price_10_50 (R$ 10 a R$ 50)
            _, min_price, max_price = query.data.split("_")
            await self.send_offers_by_price_range(
                update, context, float(min_price), float(max_price)
            )

    async def send_best_offers(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Envia as melhores ofertas da Shopee"""
        try:
            # Busca ofertas ordenadas por comissÃ£o
            offers = self.shopee_api.get_product_offers(
                page=0, limit=10, sort_type=SortType.COMMISSION_HIGH_LOW
            )

            if not offers:
                await update.callback_query.edit_message_text(
                    "âŒ Nenhuma oferta encontrada no momento."
                )
                return

            # Filtra ofertas com desconto significativo
            best_offers = [offer for offer in offers if offer.commission_rate > 5.0]

            if not best_offers:
                best_offers = offers[:3]  # Usa as primeiras se nÃ£o houver desconto

            # Envia cada oferta com o modelo apropriado
            for i, offer in enumerate(best_offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                # Delay entre mensagens para evitar spam
                if i < len(best_offers) - 1:
                    await asyncio.sleep(1)

            # BotÃ£o para mais ofertas
            keyboard = [
                [InlineKeyboardButton("ğŸ”„ Mais Ofertas", callback_data="best_offers")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"âœ… **{len(best_offers)} melhores ofertas enviadas!**\n\n"
                "Quer ver mais ofertas?",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar melhores ofertas: {e}")
            await update.callback_query.edit_message_text(
                "âŒ Erro ao buscar ofertas. Tente novamente."
            )

    async def send_price_range_menu(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Menu para escolher faixa de preÃ§o"""
        keyboard = [
            [InlineKeyboardButton("ğŸ’° R$ 10 - R$ 50", callback_data="price_10_50")],
            [InlineKeyboardButton("ğŸ’° R$ 50 - R$ 100", callback_data="price_50_100")],
            [InlineKeyboardButton("ğŸ’° R$ 100 - R$ 200", callback_data="price_100_200")],
            [InlineKeyboardButton("ğŸ’° R$ 200+", callback_data="price_200_1000")],
            [InlineKeyboardButton("ğŸ”™ Voltar", callback_data="back_to_main")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.callback_query.edit_message_text(
            "ğŸ’° **Escolha uma faixa de preÃ§o:**\n\n"
            "Selecione o intervalo de preÃ§o desejado:",
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def send_offers_by_price_range(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        min_price: float,
        max_price: float,
    ):
        """Envia ofertas por faixa de preÃ§o"""
        try:
            offers = self.shopee_api.get_offers_by_price_range(
                min_price, max_price, limit=10
            )

            if not offers:
                await update.callback_query.edit_message_text(
                    f"âŒ Nenhuma oferta encontrada entre R$ {min_price:.2f} e R$ {max_price:.2f}."
                )
                return

            # Envia as ofertas encontradas
            for i, offer in enumerate(offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            # BotÃ£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ”™ Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"âœ… **{len(offers)} ofertas encontradas entre R$ {min_price:.2f} e R$ {max_price:.2f}!**\n\n"
                "Quer ver outras faixas de preÃ§o?",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar ofertas por faixa de preÃ§o: {e}")
            await update.callback_query.edit_message_text(
                "âŒ Erro ao buscar ofertas. Tente novamente."
            )

    async def send_daily_deals(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Envia ofertas do dia"""
        try:
            offers = self.shopee_api.get_daily_deals(limit=5)

            if not offers:
                await update.callback_query.edit_message_text(
                    "âŒ Nenhuma oferta do dia encontrada."
                )
                return

            # Envia as ofertas do dia
            for i, offer in enumerate(offers[: self.offers_per_message]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            # BotÃ£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ”™ Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                f"âœ… **{len(offers)} ofertas do dia enviadas!**\n\n"
                "Volte mais tarde para novas ofertas!",
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar ofertas do dia: {e}")
            await update.callback_query.edit_message_text(
                "âŒ Erro ao buscar ofertas do dia. Tente novamente."
            )

    def determine_message_type(self, offer: ShopeeOffer) -> str:
        """Determina o tipo de mensagem baseado na oferta"""
        # Simula anÃ¡lise de histÃ³rico de preÃ§os
        # Em produÃ§Ã£o, isso viria de um banco de dados real

        # Modelo 3: Menor PreÃ§o HistÃ³rico (se comissÃ£o muito alta)
        if offer.commission_rate > 15.0:
            return "historical_low"

        # Modelo 2: PreÃ§o Baixo Recente (se comissÃ£o alta)
        elif offer.commission_rate > 8.0:
            return "recent_low"

        # Modelo 1: Oferta PadrÃ£o (demais casos)
        else:
            return "standard"

    async def send_offer_message(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        offer: ShopeeOffer,
        message_type: str,
    ):
        """Envia mensagem de oferta com o modelo apropriado"""
        try:
            # Determina o texto baseado no tipo de mensagem
            if message_type == "historical_low":
                text = self.format_historical_low_message(offer)
            elif message_type == "recent_low":
                text = self.format_recent_low_message(offer)
            else:
                text = self.format_standard_message(offer)

            # BotÃ£o para ver a oferta
            keyboard = [[InlineKeyboardButton("ğŸ›’ Ver a Oferta", url=offer.offer_link)]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            # Envia a mensagem
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True,
            )

        except Exception as e:
            logger.error(f"Erro ao enviar mensagem de oferta: {e}")

    def format_standard_message(self, offer: ShopeeOffer) -> str:
        """Modelo 1: Oferta PadrÃ£o (Bom PreÃ§o ou Bom Desconto)"""
        # Simula desconto baseado na comissÃ£o
        discount_percentage = min(offer.commission_rate * 2, 50)  # MÃ¡ximo 50%
        original_price = offer.price / (1 - discount_percentage / 100)

        return (
            f"ğŸ”¥ **Oferta Garimpada!** ğŸ”¥\n\n"
            f"ğŸ’» **Produto da Shopee**\n"
            f"ğŸ’° De ~R$ {original_price:.2f}~ por\n"
            f"ğŸ’µ **R$ {offer.price:.2f}** ({discount_percentage:.0f}% de desconto)\n\n"
            f"ğŸª Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"ğŸ’¸ ComissÃ£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"â­ AvaliaÃ§Ã£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"ğŸ›’ **Ver a Oferta**\n"
            f"[Link de Afiliado]"
        )

    def format_recent_low_message(self, offer: ShopeeOffer) -> str:
        """Modelo 2: PreÃ§o Baixo Recente (Ã“tima Oportunidade)"""
        return (
            f"ğŸ“‰ **Alerta de PreÃ§o Baixo!** ğŸ“‰\n\n"
            f"ğŸ’» **Produto da Shopee**\n"
            f"âœ¨ **Menor preÃ§o dos Ãºltimos 6 meses!**\n\n"
            f"ğŸ’µ **R$ {offer.price:.2f}**\n\n"
            f"ğŸª Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"ğŸ’¸ ComissÃ£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"â­ AvaliaÃ§Ã£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"ğŸ›’ **Ver a Oferta**\n"
            f"[Link de Afiliado]"
        )

    def format_historical_low_message(self, offer: ShopeeOffer) -> str:
        """Modelo 3: Menor PreÃ§o HistÃ³rico (A Oferta ImperdÃ­vel)"""
        return (
            f"ğŸ”¥ğŸ”¥ **MENOR PREÃ‡O DA HISTÃ“RIA!** ğŸ”¥ğŸ”¥\n\n"
            f"ğŸ’» **Produto da Shopee**\n"
            f"ğŸ’ **Nunca esteve tÃ£o barato!**\n\n"
            f"ğŸ’µ **R$ {offer.price:.2f}**\n\n"
            f"ğŸª Vendido pela: **{offer.shop_name or 'Loja Parceira'}**\n"
            f"ğŸ’¸ ComissÃ£o: **R$ {offer.commission:.2f}** ({offer.commission_rate:.1f}%)\n"
            f"â­ AvaliaÃ§Ã£o: **{offer.rating_star or 'N/A'}**\n\n"
            f"ğŸ›’ **Aproveitar Agora!**\n"
            f"[Link de Afiliado]"
        )

    async def send_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Envia estatÃ­sticas do bot"""
        try:
            # Busca estatÃ­sticas da API da Shopee
            offers = self.shopee_api.get_product_offers(page=0, limit=100)

            if offers:
                total_offers = len(offers)
                avg_price = sum(offer.price for offer in offers) / total_offers
                avg_commission = (
                    sum(offer.commission for offer in offers) / total_offers
                )
                best_commission = max(offer.commission_rate for offer in offers)

                stats_text = (
                    f"ğŸ“Š **EstatÃ­sticas da Shopee**\n\n"
                    f"ğŸ›ï¸ Total de ofertas: **{total_offers}**\n"
                    f"ğŸ’° PreÃ§o mÃ©dio: **R$ {avg_price:.2f}**\n"
                    f"ğŸ’¸ ComissÃ£o mÃ©dia: **R$ {avg_commission:.2f}**\n"
                    f"ğŸ† Melhor comissÃ£o: **{best_commission:.1f}%**\n\n"
                    f"â° Ãšltima atualizaÃ§Ã£o: **{datetime.now().strftime('%H:%M')}**"
                )
            else:
                stats_text = "âŒ Nenhuma estatÃ­stica disponÃ­vel no momento."

            # BotÃ£o para voltar
            keyboard = [
                [
                    InlineKeyboardButton(
                        "ğŸ”™ Voltar ao Menu", callback_data="back_to_main"
                    )
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.callback_query.edit_message_text(
                stats_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN
            )

        except Exception as e:
            logger.error(f"Erro ao enviar estatÃ­sticas: {e}")
            await update.callback_query.edit_message_text(
                "âŒ Erro ao buscar estatÃ­sticas."
            )

    async def send_search_menu(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """Menu de busca de produtos"""
        await update.callback_query.edit_message_text(
            "ğŸ” **Busca de Produtos**\n\n"
            "Para buscar produtos especÃ­ficos, use:\n"
            "`/buscar [produto]`\n\n"
            "Exemplo: `/buscar smartphone`\n\n"
            "ğŸ”™ Use /start para voltar ao menu principal.",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def search_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /buscar - Busca produtos especÃ­ficos"""
        if not context.args:
            await update.message.reply_text(
                "ğŸ” **Como usar:**\n"
                "`/buscar [produto]`\n\n"
                "Exemplo: `/buscar smartphone`",
                parse_mode=ParseMode.MARKDOWN,
            )
            return

        keyword = " ".join(context.args)
        await update.message.reply_text(f"ğŸ” Buscando produtos com: **{keyword}**...")

        try:
            # Busca produtos na Shopee
            offers = self.shopee_api.search_products(keyword, page=0, limit=5)

            if not offers:
                await update.message.reply_text(
                    f"âŒ Nenhum produto encontrado para: **{keyword}**"
                )
                return

            # Envia os produtos encontrados
            for i, offer in enumerate(offers[:3]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            await update.message.reply_text(
                f"âœ… **{len(offers)} produtos encontrados para '{keyword}'!**\n\n"
                "Use /start para ver mais opÃ§Ãµes."
            )

        except Exception as e:
            logger.error(f"Erro na busca: {e}")
            await update.message.reply_text("âŒ Erro na busca. Tente novamente.")

    async def oferta_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /oferta - Mostra ofertas gerais"""
        try:
            await update.message.reply_text("ğŸ” Buscando melhores ofertas...")

            # Busca melhores ofertas
            offers = self.shopee_api.get_product_offers(
                page=0, limit=5, sort_type=SortType.COMMISSION_HIGH_LOW
            )

            if not offers:
                await update.message.reply_text(
                    "âŒ Nenhuma oferta encontrada no momento."
                )
                return

            # Envia as ofertas
            for i, offer in enumerate(offers[:3]):
                message_type = self.determine_message_type(offer)
                await self.send_offer_message(update, context, offer, message_type)

                if i < len(offers) - 1:
                    await asyncio.sleep(1)

            await update.message.reply_text(
                f"âœ… **{len(offers)} ofertas encontradas!**\n\n"
                "Use /start para ver mais opÃ§Ãµes."
            )

        except Exception as e:
            logger.error(f"Erro ao buscar ofertas: {e}")
            await update.message.reply_text(
                "âŒ Erro ao buscar ofertas. Tente novamente."
            )

    async def ajuda_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Comando /ajuda - Lista todos os comandos disponÃ­veis"""
        help_text = (
            "ğŸ¤– **COMANDOS DISPONÃVEIS**\n\n"
            "ğŸ“‹ **Comandos principais:**\n"
            "â€¢ `/start` - Menu principal com botÃµes\n"
            "â€¢ `/oferta` - Ver melhores ofertas\n"
            "â€¢ `/buscar [produto]` - Buscar produtos especÃ­ficos\n"
            "â€¢ `/ajuda` - Esta mensagem de ajuda\n\n"
            "ğŸ” **Exemplos de busca:**\n"
            "â€¢ `/buscar smartphone`\n"
            "â€¢ `/buscar notebook`\n"
            "â€¢ `/buscar fone de ouvido`\n"
            "â€¢ `/buscar mouse`\n\n"
            "ğŸ’¡ **Dica:** Use o menu principal (/start) para navegar facilmente!"
        )

        await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manipula erros do bot"""
        logger.error(f"Erro no bot: {context.error}")
        if update and update.effective_chat:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="âŒ Ocorreu um erro. Tente novamente ou use /start.",
            )

    def run(self):
        """Executa o bot"""
        # Cria a aplicaÃ§Ã£o
        application = Application.builder().token(self.bot_token).build()

        # Adiciona handlers
        application.add_handler(CommandHandler("start", self.start_command))
        application.add_handler(CommandHandler("buscar", self.search_command))
        application.add_handler(CommandHandler("oferta", self.oferta_command))
        application.add_handler(CommandHandler("ajuda", self.ajuda_command))
        application.add_handler(CallbackQueryHandler(self.button_handler))

        # Adiciona error handler
        application.add_error_handler(self.error_handler)

        # Inicia o bot
        logger.info("ğŸš€ Bot da Shopee iniciando...")
        application.run_polling()


def main():
    """FunÃ§Ã£o principal"""
    print("ğŸš€ INICIANDO BOT DA SHOPEE")
    print("=" * 50)

    try:
        bot = ShopeeTelegramBot()
        bot.run()
    except Exception as e:
        logger.error(f"Erro ao iniciar bot: {e}")
        print(f"âŒ Erro: {e}")


if __name__ == "__main__":
    main()
