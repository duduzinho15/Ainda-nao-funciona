import logging
import asyncio
from typing import Optional, Dict, Any


from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

import config
from database import (
    adicionar_oferta_manual,
    oferta_ja_existe_por_url,
    oferta_ja_existe_por_hash,
    extrair_dominio_loja,
)
from utils.images import fetch_bytes, fetch_og_image
from posting.message_templates import render_caption_and_buttons

# Configura√ß√£o de logging
logger = logging.getLogger(__name__)


async def _send_card(bot, chat_id: int, offer: dict):
    """
    Envia cart√£o de oferta com imagem grande via bytes ou fallback robusto

    Args:
        bot: Inst√¢ncia do bot do Telegram
        chat_id: ID do chat para enviar
        offer: Dicion√°rio com dados da oferta
    """
    try:
        # Renderiza caption e bot√µes usando templates
        caption, buttons = render_caption_and_buttons(offer)
        markup = InlineKeyboardMarkup(
            [[InlineKeyboardButton(b["text"], url=b["url"]) for b in buttons]]
        )

        # Determina URL da imagem
        img_url = offer.get("image_url") or offer.get("imagem_url")
        if not img_url:
            base_url = offer.get("affiliate_url") or offer.get("product_url")
            if base_url:
                img_url = await fetch_og_image(base_url)

        # Loga informa√ß√µes da oferta
        store = offer.get("store", "unknown")
        types = offer.get("types", [])
        image_source = "none"
        affiliate_kind = "none"

        # Log adicional para AWIN
        if "awin" in store.lower():
            from awin_api import get_awin_merchant_id

            merchant_id = get_awin_merchant_id(store.lower())
            publisher_id = (
                config.AWIN_PUBLISHER_IDS["samsung"]
                if "samsung" in store.lower()
                else config.AWIN_PUBLISHER_IDS["default"]
            )
            logger.info(
                f"üîó AWIN: store={store}, merchant_id={merchant_id}, publisher_id={publisher_id}"
            )

        if img_url:
            buf = await fetch_bytes(img_url)
            try:
                if buf:
                    image_source = (
                        "offer"
                        if offer.get("image_url") or offer.get("imagem_url")
                        else "og:image"
                    )
                    affiliate_kind = "awin" if "awin" in store.lower() else "native"

                    # Loga detalhes da publica√ß√£o
                    logger.info(
                        f"üì§ Publicando {store}: types={types}, image_source={image_source}, affiliate_kind={affiliate_kind}"
                    )

                    return await bot.send_photo(
                        chat_id=chat_id,
                        photo=buf,
                        caption=caption,
                        parse_mode=ParseMode.HTML,
                        reply_markup=markup,
                    )
                else:
                    image_source = (
                        "offer"
                        if offer.get("image_url") or offer.get("imagem_url")
                        else "og:image"
                    )
                    affiliate_kind = "awin" if "awin" in store.lower() else "native"

                    logger.info(
                        f"üì§ Publicando {store}: types={types}, image_source={image_source}, affiliate_kind={affiliate_kind}"
                    )

                    return await bot.send_photo(
                        chat_id=chat_id,
                        photo=img_url,
                        caption=caption,
                        parse_mode=ParseMode.HTML,
                        reply_markup=markup,
                    )
            except Exception as e:
                logger.warning(f"Falha ao enviar imagem ({image_source}): {e}")
                pass

        # Fallback: texto SEM preview
        image_source = "fallback:text"
        affiliate_kind = "awin" if "awin" in store.lower() else "native"

        logger.info(
            f"üì§ Publicando {store}: types={types}, image_source={image_source}, affiliate_kind={affiliate_kind}"
        )

        return await bot.send_message(
            chat_id=chat_id,
            text=caption,
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True,
            reply_markup=markup,
        )

    except Exception as e:
        logger.error(f"Erro ao enviar cart√£o: {e}")
        # Fallback final: mensagem simples
        return await bot.send_message(
            chat_id=chat_id,
            text=f"üî• Oferta: {offer.get('title', 'Oferta')}\nüí∞ Pre√ßo: {offer.get('price_formatted', '‚Äî')}",
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True,
        )


async def publicar_oferta(
    bot,
    chat_id: int,
    mensagem: str,
    url_afiliado: Optional[str] = None,
    reply_markup=None,
):
    """
    Publica uma oferta no chat especificado

    Args:
        bot: Inst√¢ncia do bot do Telegram
        chat_id: ID do chat para enviar
        mensagem: Mensagem da oferta (deve ser HTML)
        url_afiliado: URL de afiliado da oferta
        reply_markup: Teclado inline (opcional)
    """
    try:
        # Converte dados antigos para novo formato se necess√°rio
        if isinstance(mensagem, dict):
            # Formato antigo, converte para novo
            offer = {
                "title": mensagem.get("titulo", "Oferta"),
                "price_formatted": mensagem.get("preco_atual", "‚Äî"),
                "store": mensagem.get("loja", "Loja"),
                "affiliate_url": (url_afiliado or mensagem.get("url_afiliado") or ""),
                "origin": "Garimpeiro Geek",
            }
            await _send_card(bot, chat_id, offer)
        else:
            # Formato novo, usa diretamente
            offer = {
                "title": "Oferta",
                "price_formatted": "‚Äî",
                "store": "Loja",
                "affiliate_url": url_afiliado or "",
                "origin": "Garimpeiro Geek",
                "types": [],
            }
            await _send_card(bot, chat_id, offer)

        logger.info(f"‚úÖ Oferta publicada no chat {chat_id}")

    except Exception as e:
        logger.error(f"‚ùå Erro ao publicar oferta: {e}")
        # Fallback: envia mensagem simples
        try:
            await bot.send_message(
                chat_id=chat_id,
                text="‚ùå Erro ao publicar oferta. Tente novamente.",
                parse_mode=ParseMode.HTML,
            )
        except:
            pass


async def comando_oferta(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para adicionar oferta manualmente"""
    try:
        # Extrai informa√ß√µes da mensagem
        message_text = update.message.text
        user_id = update.effective_user.id

        # Verifica se √© admin
        if str(user_id) != config.ADMIN_USER_ID:
            await update.message.reply_text(
                "‚ùå Apenas administradores podem usar este comando."
            )
            return

        # Parse da mensagem (formato: /oferta <link> <titulo> <preco>)
        parts = message_text.split(maxsplit=3)
        if len(parts) < 4:
            await update.message.reply_text(
                "üìù Uso: /oferta <link> <titulo> <preco>\n"
                "Exemplo: /oferta https://amazon.com.br/produto Smartphone R$ 999,00"
            )
            return

        _, link, titulo, preco = parts

        # Verifica se a oferta j√° existe
        if oferta_ja_existe_por_url(link):
            await update.message.reply_text(
                "‚ö†Ô∏è Esta oferta j√° foi publicada anteriormente."
            )
            return

        # Gera hash da oferta para verifica√ß√£o de duplicatas
        from utils.offer_hash import offer_hash

        offer_hash_value = offer_hash(
            {
                "url_produto": link,
                "titulo": titulo,
                "preco_atual": preco,
                "loja": extrair_dominio_loja(link),
            }
        )

        # Verifica se j√° existe oferta com o mesmo hash
        if oferta_ja_existe_por_hash(offer_hash_value):
            await update.message.reply_text(
                "‚ö†Ô∏è Esta oferta j√° foi publicada anteriormente (detectada por hash)."
            )
            return

        # Cria oferta no novo formato
        offer = {
            "title": titulo,
            "price_formatted": preco,
            "store": extrair_dominio_loja(link),
            "affiliate_url": link,
            "origin": "Garimpeiro Geek",
            "types": [],
        }

        # Publica a oferta
        await _send_card(context.bot, int(config.TELEGRAM_CHAT_ID), offer)

        # Adiciona ao banco de dados
        adicionar_oferta_manual(link, titulo, preco)

        await update.message.reply_text("‚úÖ Oferta publicada com sucesso!")

    except Exception as e:
        logger.error(f"Erro no comando oferta: {e}")
        await update.message.reply_text(f"‚ùå Erro ao processar comando: {e}")


async def publicar_oferta_automatica(oferta: Dict[str, Any], context) -> bool:
    """
    Publica oferta automaticamente usando o novo sistema de templates

    Args:
        oferta: Dicion√°rio com dados da oferta
        context: Contexto do bot

    Returns:
        True se publicado com sucesso, False caso contr√°rio
    """
    try:
        # Converte dados antigos para novo formato se necess√°rio
        if "titulo" in oferta:
            # Formato antigo, converte para novo
            offer = {
                "title": oferta.get("titulo", "Oferta"),
                "price_formatted": oferta.get("preco_atual", oferta.get("preco", "‚Äî")),
                "previous_price": oferta.get("preco_original"),
                "store": oferta.get("loja", "Loja"),
                "affiliate_url": oferta.get("url_afiliado")
                or oferta.get("url_produto"),
                "image_url": oferta.get("imagem_url"),
                "origin": oferta.get("fonte", "Garimpeiro Geek"),
                "types": [],
                "features": oferta.get("caracteristicas", []),
                "desconto": oferta.get("desconto", 0),
            }

            # Adiciona tipos baseados no desconto
            if offer["desconto"] >= 50:
                offer["types"].append("flash_deal")
            elif offer["desconto"] >= 30:
                offer["types"].append("three_month_low")

        else:
            # J√° est√° no formato novo
            offer = oferta

        # Publica usando o novo sistema
        await _send_card(context.bot, int(config.TELEGRAM_CHAT_ID), offer)

        # Rate limiting entre publica√ß√µes
        if hasattr(context, "job") and context.job:
            await asyncio.sleep(config.POST_RATE_DELAY_MS / 1000)

        logger.info(
            f"‚úÖ Oferta autom√°tica publicada: {offer.get('title', 'Oferta')[:50]}..."
        )
        return True

    except Exception as e:
        logger.error(f"‚ùå Erro ao publicar oferta autom√°tica: {e}")
        return False
