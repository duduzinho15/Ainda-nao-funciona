#!/usr/bin/env python3
"""
Sistema de NotificaÃ§Ãµes AutomÃ¡ticas da Shopee
Envia ofertas automaticamente para o canal do Telegram
"""

import asyncio
import logging
import time
from datetime import datetime, timedelta
from typing import List
import schedule

from telegram import Bot
from telegram.constants import ParseMode

import config
from shopee_integration_system import ShopeeAPIIntegration, SortType

# ConfiguraÃ§Ã£o de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class ShopeeNotificationSystem:
    """Sistema de notificaÃ§Ãµes automÃ¡ticas da Shopee"""

    def __init__(self):
        self.bot_token = config.TELEGRAM_BOT_TOKEN
        self.chat_id = config.TELEGRAM_CHAT_ID
        self.admin_id = config.ADMIN_USER_ID

        # API da Shopee
        self.shopee_api = ShopeeAPIIntegration(
            app_id="18330800803", app_secret="IOMXMSUM5KDOLSYKXQERKCU42SNMJERR"
        )

        # Bot do Telegram
        self.bot = Bot(token=self.bot_token)

        # ConfiguraÃ§Ãµes
        self.check_interval_minutes = 30  # Verifica a cada 30 minutos
        self.max_offers_per_notification = 3  # MÃ¡ximo de ofertas por notificaÃ§Ã£o
        self.min_commission_rate = 5.0  # Taxa de comissÃ£o mÃ­nima para notificar
        self.min_discount_threshold = 20.0  # Desconto mÃ­nimo para notificar

        # HistÃ³rico de ofertas enviadas (para evitar duplicatas)
        self.sent_offers = set()
        self.last_check_time = None

        logger.info("ğŸš€ Sistema de NotificaÃ§Ãµes da Shopee inicializado")

    async def send_notification(self, title: str, message: str, offers: List = None):
        """Envia notificaÃ§Ã£o para o canal"""
        try:
            # Formata a mensagem
            if offers:
                full_message = f"{title}\n\n{message}\n\n"
                for i, offer in enumerate(
                    offers[: self.max_offers_per_notification], 1
                ):
                    full_message += f"{i}. ğŸ’° R$ {offer.price:.2f} - ğŸ’¸ {offer.commission_rate:.1f}%\n"
                    full_message += f"   ğŸª {offer.shop_name or 'Loja Parceira'}\n"
                    full_message += f"   ğŸ”— {offer.offer_link}\n\n"

                full_message += f"â° {datetime.now().strftime('%H:%M')} - {len(offers)} ofertas encontradas!"
            else:
                full_message = (
                    f"{title}\n\n{message}\n\nâ° {datetime.now().strftime('%H:%M')}"
                )

            # Envia para o canal
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=full_message,
                parse_mode=ParseMode.MARKDOWN,
                disable_web_page_preview=True,
            )

            logger.info(f"âœ… NotificaÃ§Ã£o enviada: {title}")

        except Exception as e:
            logger.error(f"âŒ Erro ao enviar notificaÃ§Ã£o: {e}")

    async def check_best_offers(self):
        """Verifica e notifica sobre as melhores ofertas"""
        try:
            logger.info("ğŸ” Verificando melhores ofertas...")

            # Busca ofertas ordenadas por comissÃ£o
            offers = self.shopee_api.get_product_offers(
                page=0, limit=20, sort_type=SortType.COMMISSION_HIGH_LOW
            )

            if not offers:
                logger.info("âš ï¸ Nenhuma oferta encontrada")
                return

            # Filtra ofertas com comissÃ£o alta e desconto significativo
            best_offers = []
            for offer in offers:
                # Verifica se jÃ¡ foi enviada
                offer_id = f"{offer.price}_{offer.commission_rate}_{offer.shop_name}"
                if offer_id in self.sent_offers:
                    continue

                # Verifica critÃ©rios mÃ­nimos
                if (
                    offer.commission_rate >= self.min_commission_rate
                    and offer.commission_rate > 8.0
                ):  # ComissÃ£o alta
                    best_offers.append(offer)
                    self.sent_offers.add(offer_id)

                if len(best_offers) >= self.max_offers_per_notification:
                    break

            if best_offers:
                title = "ğŸ”¥ **ALERTA DE OFERTAS EXCEPCIONAIS!** ğŸ”¥"
                message = (
                    "Encontramos ofertas com comissÃµes muito altas! Aproveite agora:"
                )

                await self.send_notification(title, message, best_offers)

                # Limpa histÃ³rico antigo (mantÃ©m apenas Ãºltimas 100 ofertas)
                if len(self.sent_offers) > 100:
                    self.sent_offers.clear()

            self.last_check_time = datetime.now()

        except Exception as e:
            logger.error(f"âŒ Erro ao verificar melhores ofertas: {e}")

    async def check_daily_deals(self):
        """Verifica e notifica sobre ofertas do dia"""
        try:
            logger.info("ğŸ” Verificando ofertas do dia...")

            # Busca ofertas do dia
            offers = self.shopee_api.get_daily_deals(limit=10)

            if not offers:
                logger.info("âš ï¸ Nenhuma oferta do dia encontrada")
                return

            # Filtra ofertas nÃ£o enviadas
            new_offers = []
            for offer in offers:
                offer_id = (
                    f"daily_{offer.price}_{offer.commission_rate}_{offer.shop_name}"
                )
                if offer_id not in self.sent_offers:
                    new_offers.append(offer)
                    self.sent_offers.add(offer_id)

                if len(new_offers) >= self.max_offers_per_notification:
                    break

            if new_offers:
                title = "â­ **OFERTAS DO DIA - SHOPEE** â­"
                message = "Novas ofertas imperdÃ­veis foram encontradas:"

                await self.send_notification(title, message, new_offers)

        except Exception as e:
            logger.error(f"âŒ Erro ao verificar ofertas do dia: {e}")

    async def check_price_drops(self):
        """Verifica e notifica sobre quedas de preÃ§o"""
        try:
            logger.info("ğŸ” Verificando quedas de preÃ§o...")

            # Busca ofertas em diferentes faixas de preÃ§o
            price_ranges = [
                (10, 50, "ğŸ’° **OFERTAS ATÃ‰ R$ 50** ğŸ’°"),
                (50, 100, "ğŸ’° **OFERTAS R$ 50 - R$ 100** ğŸ’°"),
                (100, 200, "ğŸ’° **OFERTAS R$ 100 - R$ 200** ğŸ’°"),
            ]

            for min_price, max_price, title in price_ranges:
                offers = self.shopee_api.get_offers_by_price_range(
                    min_price, max_price, limit=5
                )

                if not offers:
                    continue

                # Filtra ofertas com desconto significativo
                discounted_offers = []
                for offer in offers:
                    # Simula desconto baseado na comissÃ£o
                    discount_percentage = min(offer.commission_rate * 2, 50)

                    if discount_percentage >= self.min_discount_threshold:
                        offer_id = f"price_{min_price}_{max_price}_{offer.price}_{offer.commission_rate}"
                        if offer_id not in self.sent_offers:
                            discounted_offers.append(offer)
                            self.sent_offers.add(offer_id)

                    if len(discounted_offers) >= 2:  # MÃ¡ximo 2 por faixa de preÃ§o
                        break

                if discounted_offers:
                    message = (
                        f"Ofertas com desconto entre R$ {min_price} e R$ {max_price}:"
                    )
                    await self.send_notification(title, message, discounted_offers)

                    # Delay entre notificaÃ§Ãµes para evitar spam
                    await asyncio.sleep(2)

        except Exception as e:
            logger.error(f"âŒ Erro ao verificar quedas de preÃ§o: {e}")

    async def send_daily_summary(self):
        """Envia resumo diÃ¡rio das melhores ofertas"""
        try:
            logger.info("ğŸ“Š Preparando resumo diÃ¡rio...")

            # Busca estatÃ­sticas do dia
            offers = self.shopee_api.get_product_offers(page=0, limit=100)

            if not offers:
                return

            # Calcula estatÃ­sticas
            total_offers = len(offers)
            avg_price = sum(offer.price for offer in offers) / total_offers
            avg_commission = (
                sum(offer.commission_rate for offer in offers) / total_offers
            )
            best_commission = max(offer.commission_rate for offer in offers)

            # Top 3 ofertas do dia
            top_offers = sorted(offers, key=lambda x: x.commission_rate, reverse=True)[
                :3
            ]

            title = "ğŸ“Š **RESUMO DIÃRIO - SHOPEE** ğŸ“Š"
            message = (
                f"ğŸ“ˆ **EstatÃ­sticas do dia:**\n"
                f"ğŸ›ï¸ Total de ofertas: {total_offers}\n"
                f"ğŸ’° PreÃ§o mÃ©dio: R$ {avg_price:.2f}\n"
                f"ğŸ’¸ ComissÃ£o mÃ©dia: {avg_commission:.1f}%\n"
                f"ğŸ† Melhor comissÃ£o: {best_commission:.1f}%\n\n"
                f"ğŸ”¥ **Top 3 Ofertas do Dia:**"
            )

            await self.send_notification(title, message, top_offers)

        except Exception as e:
            logger.error(f"âŒ Erro ao enviar resumo diÃ¡rio: {e}")

    async def send_admin_status(self):
        """Envia status para o administrador"""
        try:
            current_time = datetime.now()
            uptime = (
                current_time - self.last_check_time
                if self.last_check_time
                else timedelta(0)
            )

            status_message = (
                f"ğŸ¤– **STATUS DO SISTEMA DE NOTIFICAÃ‡Ã•ES**\n\n"
                f"âœ… Sistema funcionando normalmente\n"
                f"â° Ãšltima verificaÃ§Ã£o: {self.last_check_time.strftime('%H:%M:%S') if self.last_check_time else 'Nunca'}\n"
                f"â±ï¸ Uptime: {str(uptime).split('.')[0]}\n"
                f"ğŸ“Š Ofertas enviadas hoje: {len(self.sent_offers)}\n"
                f"ğŸ” VerificaÃ§Ãµes a cada: {self.check_interval_minutes} minutos\n"
                f"ğŸ’¸ ComissÃ£o mÃ­nima: {self.min_commission_rate}%\n"
                f"ğŸ’° Desconto mÃ­nimo: {self.min_discount_threshold}%"
            )

            await self.bot.send_message(
                chat_id=self.admin_id,
                text=status_message,
                parse_mode=ParseMode.MARKDOWN,
            )

            logger.info("âœ… Status enviado para o administrador")

        except Exception as e:
            logger.error(f"âŒ Erro ao enviar status: {e}")

    def schedule_jobs(self):
        """Agenda as tarefas automÃ¡ticas"""
        # Verifica melhores ofertas a cada 30 minutos
        schedule.every(self.check_interval_minutes).minutes.do(
            lambda: asyncio.run(self.check_best_offers())
        )

        # Verifica ofertas do dia a cada 2 horas
        schedule.every(2).hours.do(lambda: asyncio.run(self.check_daily_deals()))

        # Verifica quedas de preÃ§o a cada hora
        schedule.every().hour.do(lambda: asyncio.run(self.check_price_drops()))

        # Resumo diÃ¡rio Ã s 20:00
        schedule.every().day.at("20:00").do(
            lambda: asyncio.run(self.send_daily_summary())
        )

        # Status para admin a cada 6 horas
        schedule.every(6).hours.do(lambda: asyncio.run(self.send_admin_status()))

        logger.info("ğŸ“… Tarefas agendadas com sucesso")

    async def run_initial_check(self):
        """Executa verificaÃ§Ã£o inicial"""
        logger.info("ğŸš€ Executando verificaÃ§Ã£o inicial...")

        await self.check_best_offers()
        await self.check_daily_deals()
        await self.send_admin_status()

        logger.info("âœ… VerificaÃ§Ã£o inicial concluÃ­da")

    def run(self):
        """Executa o sistema de notificaÃ§Ãµes"""
        logger.info("ğŸš€ Iniciando sistema de notificaÃ§Ãµes...")

        # Agenda as tarefas
        self.schedule_jobs()

        # Executa verificaÃ§Ã£o inicial
        asyncio.run(self.run_initial_check())

        # Loop principal
        while True:
            try:
                schedule.run_pending()
                time.sleep(60)  # Verifica a cada minuto

            except KeyboardInterrupt:
                logger.info("ğŸ›‘ Sistema interrompido pelo usuÃ¡rio")
                break
            except Exception as e:
                logger.error(f"âŒ Erro no loop principal: {e}")
                time.sleep(300)  # Espera 5 minutos em caso de erro


def main():
    """FunÃ§Ã£o principal"""
    print("ğŸš€ INICIANDO SISTEMA DE NOTIFICAÃ‡Ã•ES DA SHOPEE")
    print("=" * 60)

    try:
        notification_system = ShopeeNotificationSystem()
        notification_system.run()
    except Exception as e:
        logger.error(f"âŒ Erro ao iniciar sistema: {e}")
        print(f"âŒ Erro: {e}")


if __name__ == "__main__":
    main()
