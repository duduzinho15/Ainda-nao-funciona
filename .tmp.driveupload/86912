#!/usr/bin/env python3
"""
Sistema Integrado de Postagem Autom√°tica
Conecta o orquestrador de scrapers com o bot do Telegram
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional

# Importa√ß√µes do sistema
from intelligent_scraper_orchestrator import IntelligentScraperOrchestrator
from telegram_poster_fixed import publicar_oferta

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("auto_poster_integrated.log", encoding="utf-8"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger("auto_poster_integrated")


class AutoPosterIntegrated:
    """Sistema integrado de postagem autom√°tica de ofertas"""

    def __init__(self):
        self.orchestrator = IntelligentScraperOrchestrator()
        self.posted_products = set()  # Cache de produtos j√° postados
        self.collected_products = []  # Produtos coletados do √∫ltimo ciclo
        self.posting_interval = timedelta(minutes=30)  # Intervalo entre postagens
        self.max_posts_per_cycle = 5  # M√°ximo de posts por ciclo
        self.running = False

        # Estat√≠sticas
        self.stats = {
            "total_posts": 0,
            "successful_posts": 0,
            "failed_posts": 0,
            "last_post_time": None,
            "start_time": datetime.now(),
        }

    async def start(self):
        """Inicia o sistema de postagem autom√°tica"""
        logger.info("üöÄ Iniciando Sistema Integrado de Postagem Autom√°tica")
        self.running = True

        try:
            # Executa um ciclo inicial de scraping
            await self.run_scraping_cycle()

            # Inicia loop principal
            while self.running:
                try:
                    # Executa ciclo de scraping
                    await self.run_scraping_cycle()

                    # Aguarda pr√≥ximo ciclo
                    await asyncio.sleep(self.posting_interval.total_seconds())

                except KeyboardInterrupt:
                    logger.info("üëã Encerrando sistema...")
                    self.running = False
                    break
                except Exception as e:
                    logger.error(f"‚ùå Erro no ciclo principal: {e}")
                    await asyncio.sleep(
                        60
                    )  # Aguarda 1 minuto antes de tentar novamente

        except Exception as e:
            logger.error(f"‚ùå Erro fatal no sistema: {e}")
            self.running = False

    async def run_scraping_cycle(self):
        """Executa um ciclo completo de scraping e postagem"""
        logger.info("üîÑ Iniciando ciclo de scraping e postagem")

        try:
            # Coleta produtos executando os scrapers
            self.collected_products = await self.collect_products_from_orchestrator()

            # Filtra produtos para postagem
            products_to_post = self.filter_products_for_posting(self.collected_products)

            # Posta ofertas
            await self.post_offers(products_to_post)

            # Atualiza estat√≠sticas
            self.update_stats()

            logger.info("‚úÖ Ciclo de scraping e postagem conclu√≠do")

        except Exception as e:
            logger.error(f"‚ùå Erro no ciclo de scraping e postagem: {e}")

    async def collect_products_from_orchestrator(self) -> List[Dict[str, Any]]:
        """Coleta produtos executando os scrapers diretamente"""
        try:
            all_products = []

            # Executa cada scraper habilitado e coleta produtos
            for scraper_id, scraper_config in self.orchestrator.scrapers.items():
                if scraper_config.enabled:
                    try:
                        logger.info(f"üì¶ Executando scraper: {scraper_config.name}")

                        # Executa o scraper
                        products = await self.orchestrator.run_scraper_function(
                            scraper_config.function_name
                        )

                        if products:
                            # Adiciona informa√ß√µes de fonte aos produtos
                            for product in products:
                                product["fonte"] = scraper_config.name
                                product["loja"] = product.get(
                                    "loja", "Loja n√£o informada"
                                )

                            # Filtra produtos do Buscap√© (usado apenas para hist√≥rico de pre√ßos)
                            # Remove acentos para compara√ß√£o
                            import unicodedata

                            scraper_name_normalized = "".join(
                                c
                                for c in unicodedata.normalize(
                                    "NFD", scraper_config.name.lower()
                                )
                                if not unicodedata.combining(c)
                            )

                            if "buscape" not in scraper_name_normalized:
                                all_products.extend(products)
                                logger.info(
                                    f"‚úÖ {scraper_config.name}: {len(products)} produtos coletados"
                                )
                            else:
                                logger.info(
                                    f"üìä {scraper_config.name}: {len(products)} produtos coletados (apenas para hist√≥rico de pre√ßos)"
                                )
                        else:
                            logger.warning(
                                f"‚ö†Ô∏è {scraper_config.name}: Nenhum produto coletado"
                            )

                    except Exception as e:
                        logger.error(f"‚ùå Erro ao executar {scraper_config.name}: {e}")
                        continue

                    # Aguarda um pouco entre scrapers para n√£o sobrecarregar
                    await asyncio.sleep(2)

            logger.info(
                f"üìä Total de produtos coletados para postagem: {len(all_products)}"
            )
            return all_products

        except Exception as e:
            logger.error(f"‚ùå Erro ao coletar produtos: {e}")
            return []

    def filter_products_for_posting(
        self, products: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Filtra produtos para postagem baseado em crit√©rios"""
        filtered_products = []

        for product in products:
            # Verifica se j√° foi postado
            product_id = self.generate_product_id(product)
            if product_id in self.posted_products:
                continue

            # Verifica se tem informa√ß√µes m√≠nimas
            if not self.is_valid_product(product):
                continue

            # Verifica se √© produto geek/tech (filtro b√°sico)
            if not self.is_geek_product(product):
                continue

            # Para scrapers agregadores (Promobit, Pelando, MeuPC.net),
            # filtra apenas produtos de lojas com afilia√ß√£o
            source = product.get("fonte", "").lower()
            if source in ["promobit", "pelando", "meupc.net"]:
                if not self.is_affiliated_store(product):
                    logger.debug(
                        f"Produto de {source} ignorado - loja sem afilia√ß√£o: {product.get('loja', 'N/A')}"
                    )
                    continue

            filtered_products.append(product)

        # Ordena por relev√¢ncia (pre√ßo, avalia√ß√£o, etc.)
        filtered_products.sort(
            key=lambda p: self.calculate_relevance_score(p), reverse=True
        )

        # Limita quantidade de produtos para postar
        filtered_products = filtered_products[: self.max_posts_per_cycle]

        logger.info(f"üéØ {len(filtered_products)} produtos filtrados para postagem")
        return filtered_products

    def is_valid_product(self, product: Dict[str, Any]) -> bool:
        """Verifica se um produto tem informa√ß√µes v√°lidas para postagem"""
        required_fields = ["titulo", "preco", "url_produto"]

        for field in required_fields:
            if not product.get(field):
                return False

        # Verifica se o t√≠tulo tem tamanho m√≠nimo
        if len(str(product.get("titulo", ""))) < 10:
            return False

        # Verifica se o pre√ßo √© v√°lido
        price = str(product.get("preco", ""))
        if not price or price == "Pre√ßo n√£o informado":
            return False

        return True

    def is_geek_product(self, product: Dict[str, Any]) -> bool:
        """Verifica se um produto √© considerado geek/tech"""
        title = str(product.get("titulo", "")).lower()

        # Palavras-chave geek/tech
        geek_keywords = [
            "smartphone",
            "celular",
            "iphone",
            "samsung",
            "xiaomi",
            "notebook",
            "laptop",
            "pc",
            "computador",
            "gamer",
            "console",
            "ps5",
            "xbox",
            "nintendo",
            "switch",
            "tv",
            "smart tv",
            "4k",
            "oled",
            "qled",
            "tablet",
            "ipad",
            "android",
            "headphone",
            "fone",
            "airpods",
            "bluetooth",
            "smartwatch",
            "rel√≥gio",
            "fitness",
            "c√¢mera",
            "gopro",
            "canon",
            "nikon",
            "drone",
            "quadric√≥ptero",
            "gaming",
            "mouse",
            "teclado",
            "headset",
            "monitor",
            "led",
            "curvo",
            "impressora",
            "3d",
            "laser",
            "robo",
            "autom√°tico",
            "inteligente",
        ]

        # Verifica se cont√©m palavras-chave geek
        for keyword in geek_keywords:
            if keyword in title:
                return True

        return False

    def calculate_relevance_score(self, product: Dict[str, Any]) -> float:
        """Calcula score de relev√¢ncia para um produto"""
        score = 0.0

        # Score base
        score += 10.0

        # B√¥nus por pre√ßo com desconto
        if product.get("preco_original"):
            score += 5.0

        # B√¥nus por avalia√ß√£o
        if product.get("avaliacao"):
            try:
                rating = float(product["avaliacao"])
                score += rating * 2.0
            except:
                pass

        # B√¥nus por loja conhecida
        known_stores = ["amazon", "shopee", "aliexpress", "magalu", "mercadolivre"]
        store = str(product.get("loja", "")).lower()
        if any(known_store in store for known_store in known_stores):
            score += 3.0

        # B√¥nus por imagem
        if product.get("imagem_url"):
            score += 2.0

        return score

    def generate_product_id(self, product: Dict[str, Any]) -> str:
        """Gera ID √∫nico para um produto"""
        title = str(product.get("titulo", ""))
        price = str(product.get("preco", ""))
        store = str(product.get("loja", ""))

        # Cria hash simples
        combined = f"{title}|{price}|{store}"
        return str(hash(combined))

    async def post_offers(self, products: List[Dict[str, Any]]):
        """Posta ofertas no Telegram"""
        if not products:
            logger.info("üì≠ Nenhum produto para postar")
            return

        logger.info(f"üì§ Iniciando postagem de {len(products)} ofertas")

        for i, product in enumerate(products):
            try:
                # Gera mensagem formatada
                message = self.format_offer_message(product)

                # Prepara dados para postagem
                image_url = product.get("imagem_url")
                affiliate_url = self.generate_affiliate_url(product)

                # Posta no Telegram
                success = await publicar_oferta(
                    mensagem=message, imagem_url=image_url, url_afiliado=affiliate_url
                )

                if success:
                    # Marca como postado
                    product_id = self.generate_product_id(product)
                    self.posted_products.add(product_id)

                    # Atualiza estat√≠sticas
                    self.stats["successful_posts"] += 1
                    self.stats["last_post_time"] = datetime.now()

                    logger.info(
                        f"‚úÖ Oferta {i + 1}/{len(products)} postada com sucesso: {product['titulo'][:50]}..."
                    )
                else:
                    self.stats["failed_posts"] += 1
                    logger.error(f"‚ùå Falha ao postar oferta {i + 1}/{len(products)}")

                # Delay entre postagens
                await asyncio.sleep(10)

            except Exception as e:
                logger.error(f"‚ùå Erro ao postar oferta {i + 1}/{len(products)}: {e}")
                self.stats["failed_posts"] += 1
                continue

        self.stats["total_posts"] += len(products)
        logger.info(f"üìä Postagem conclu√≠da: {len(products)} ofertas processadas")

    def format_offer_message(self, product: Dict[str, Any]) -> str:
        """Formata mensagem da oferta para o Telegram"""
        title = product.get("titulo", "Produto sem t√≠tulo")
        price = product.get("preco", "Pre√ßo n√£o informado")
        original_price = product.get("preco_original")
        store = product.get("loja", "Loja n√£o informada")
        source = product.get("fonte", "Fonte n√£o informada")

        # Formata pre√ßo
        price_text = f"üí∞ *{price}*"
        if original_price:
            price_text += f" ~~{original_price}~~"

        # Formata t√≠tulo
        title_text = f"üéØ *{title}*"

        # Formata loja e fonte
        store_text = f"üè™ *{store}*"
        source_text = f"üì° Fonte: {source}"

        # Monta mensagem
        message = f"{title_text}\n\n{price_text}\n{store_text}\n{source_text}"

        return message

    def generate_affiliate_url(self, product: Dict[str, Any]) -> Optional[str]:
        """Gera URL de afiliado para o produto"""
        try:
            # Extrai informa√ß√µes do produto
            original_url = product.get("url_produto", "")
            source = product.get("fonte", "").lower()
            store = product.get("loja", "").lower()

            if not original_url:
                logger.warning(
                    f"Produto sem URL: {product.get('titulo', 'Sem t√≠tulo')}"
                )
                return None

            # Gera link de afiliado baseado na fonte/loja
            if "amazon" in source or "amazon" in store:
                return self._generate_amazon_affiliate_url(original_url)
            elif "aliexpress" in source or "aliexpress" in store:
                return self._generate_aliexpress_affiliate_url(original_url)
            elif "shopee" in source or "shopee" in store:
                return self._generate_shopee_affiliate_url(original_url)
            elif (
                "mercado livre" in source
                or "mercado livre" in store
                or "mercadolivre" in store
            ):
                return self._generate_mercadolivre_affiliate_url(original_url)
            elif any(
                awin_store in store
                for awin_store in ["kabum", "dell", "lenovo", "acer", "asus", "samsung"]
            ):
                return self._generate_awin_affiliate_url(original_url, store)
            else:
                # Para outras lojas, retorna URL original
                logger.info(f"Loja n√£o suportada para afiliados: {store}")
                return original_url

        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado: {e}")
            return product.get("url_produto")

    def _generate_amazon_affiliate_url(self, original_url: str) -> str:
        """Gera URL de afiliado para produtos da Amazon"""
        try:
            import config

            # Verifica se as credenciais da Amazon est√£o configuradas
            if (
                not hasattr(config, "AMAZON_ASSOCIATE_TAG")
                or not config.AMAZON_ASSOCIATE_TAG
            ):
                logger.warning("AMAZON_ASSOCIATE_TAG n√£o configurado")
                return original_url

            # Extrai ASIN da URL da Amazon
            if "/dp/" in original_url:
                asin = original_url.split("/dp/")[1].split("/")[0].split("?")[0]
                affiliate_url = f"https://www.amazon.com.br/dp/{asin}?tag={config.AMAZON_ASSOCIATE_TAG}"
                logger.info(f"Link de afiliado Amazon gerado para ASIN: {asin}")
                return affiliate_url
            elif "/gp/product/" in original_url:
                asin = original_url.split("/gp/product/")[1].split("/")[0].split("?")[0]
                affiliate_url = f"https://www.amazon.com.br/dp/{asin}?tag={config.AMAZON_ASSOCIATE_TAG}"
                logger.info(f"Link de afiliado Amazon gerado para ASIN: {asin}")
                return affiliate_url
            else:
                # Se n√£o conseguir extrair ASIN, adiciona tag de afiliado √† URL original
                separator = "&" if "?" in original_url else "?"
                affiliate_url = (
                    f"{original_url}{separator}tag={config.AMAZON_ASSOCIATE_TAG}"
                )
                logger.info("Link de afiliado Amazon gerado (URL modificada)")
                return affiliate_url

        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado Amazon: {e}")
            return original_url

    def _generate_aliexpress_affiliate_url(self, original_url: str) -> str:
        """Gera URL de afiliado para produtos do AliExpress"""
        try:
            import config

            # Verifica se as credenciais do AliExpress est√£o configuradas
            if (
                not hasattr(config, "ALIEXPRESS_TRACKING_ID")
                or not config.ALIEXPRESS_TRACKING_ID
            ):
                logger.warning("ALIEXPRESS_TRACKING_ID n√£o configurado")
                return original_url

            # Adiciona par√¢metros de afiliado √† URL do AliExpress
            separator = "&" if "?" in original_url else "?"
            affiliate_url = f"{original_url}{separator}src=affiliate&tracking_id={config.ALIEXPRESS_TRACKING_ID}"
            logger.info("Link de afiliado AliExpress gerado")
            return affiliate_url

        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado AliExpress: {e}")
            return original_url

    def _generate_shopee_affiliate_url(self, original_url: str) -> str:
        """Gera URL de afiliado para produtos da Shopee"""
        try:
            import config

            # Verifica se as credenciais da Shopee est√£o configuradas
            if not hasattr(config, "SHOPEE_PARTNER_ID") or not config.SHOPEE_PARTNER_ID:
                logger.warning("SHOPEE_PARTNER_ID n√£o configurado")
                return original_url

            # Adiciona par√¢metros de afiliado √† URL da Shopee
            separator = "&" if "?" in original_url else "?"
            affiliate_url = (
                f"{original_url}{separator}affiliate_id={config.SHOPEE_PARTNER_ID}"
            )
            logger.info("Link de afiliado Shopee gerado")
            return affiliate_url

        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado Shopee: {e}")
            return original_url

    def _generate_mercadolivre_affiliate_url(self, original_url: str) -> str:
        """Gera URL de afiliado para produtos do Mercado Livre"""
        try:
            # Importa e usa o sistema de afiliados do Mercado Livre
            from mercado_livre_affiliate import MercadoLivreAffiliate

            ml_affiliate = MercadoLivreAffiliate()
            affiliate_url = ml_affiliate.generate_affiliate_url(original_url)

            if affiliate_url and affiliate_url != original_url:
                logger.info("Link de afiliado Mercado Livre gerado com sucesso")
                return affiliate_url
            else:
                logger.warning("Falha ao gerar link de afiliado Mercado Livre")
                return original_url

        except ImportError:
            logger.warning("Sistema de afiliados Mercado Livre n√£o dispon√≠vel")
            return original_url
        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado Mercado Livre: {e}")
            return original_url

    def _generate_awin_affiliate_url(self, original_url: str, store: str) -> str:
        """Gera URL de afiliado para produtos de lojas parceiras da Awin"""
        try:
            import config

            # Verifica se as credenciais da Awin est√£o configuradas
            if not hasattr(config, "AWIN_PUBLISHER_ID") or not config.AWIN_PUBLISHER_ID:
                logger.warning("AWIN_PUBLISHER_ID n√£o configurado")
                return original_url

            # Mapeia lojas para IDs da Awin (ser√° atualizado dinamicamente)
            store_mapping = {
                "kabum": "kabum",
                "dell": "dell",
                "lenovo": "lenovo",
                "acer": "acer",
                "asus": "asus",
                "samsung": "samsung",
                "trocafy": "trocafy",
                "casa bahia": "casa_bahia",
            }

            store_key = None
            for key, value in store_mapping.items():
                if key in store.lower():
                    store_key = value
                    break

            if store_key:
                # Adiciona par√¢metros de afiliado da Awin
                separator = "&" if "?" in original_url else "?"
                affiliate_url = f"{original_url}{separator}awin=1&pub={config.AWIN_PUBLISHER_ID}&store={store_key}"
                logger.info(f"Link de afiliado Awin gerado para {store}")
                return affiliate_url
            else:
                logger.warning(f"Loja {store} n√£o mapeada para Awin")
                return original_url

        except Exception as e:
            logger.error(f"Erro ao gerar link de afiliado Awin: {e}")
            return original_url

    def is_affiliated_store(self, product: Dict[str, Any]) -> bool:
        """Verifica se o produto √© de uma loja com afilia√ß√£o"""
        store = product.get("loja", "").lower()

        # Lojas com afilia√ß√£o confirmada
        affiliated_stores = [
            "amazon",
            "aliexpress",
            "shopee",
            "mercado livre",
            "mercadolivre",
            "magazine luiza",
            "magalu",
            "kabum",
            "dell",
            "lenovo",
            "acer",
            "asus",
            "samsung",
            "trocafy",
            "casa bahia",
        ]

        # Verifica se a loja est√° na lista de afiliados
        for affiliated_store in affiliated_stores:
            if affiliated_store in store:
                return True

        return False

    def update_stats(self):
        """Atualiza estat√≠sticas do sistema"""
        if self.stats["start_time"]:
            uptime = datetime.now() - self.stats["start_time"]
            self.stats["uptime"] = str(uptime).split(".")[0]

    def get_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas do sistema"""
        stats = self.stats.copy()

        # Adiciona estat√≠sticas do orquestrador
        orchestrator_stats = self.orchestrator.get_detailed_stats()
        stats["orchestrator"] = orchestrator_stats

        # Adiciona estat√≠sticas de produtos postados
        stats["posted_products_count"] = len(self.posted_products)

        return stats

    def print_status(self):
        """Imprime status atual do sistema"""
        print("\n" + "=" * 60)
        print("ü§ñ SISTEMA INTEGRADO DE POSTAGEM AUTOM√ÅTICA")
        print("=" * 60)

        # Status geral
        print(f"üîÑ Status: {'üü¢ Executando' if self.running else 'üî¥ Parado'}")
        if self.stats["start_time"]:
            print(
                f"‚è∞ Iniciado em: {self.stats['start_time'].strftime('%d/%m/%Y %H:%M:%S')}"
            )
            if "uptime" in self.stats:
                print(f"‚è±Ô∏è  Uptime: {self.stats['uptime']}")

        # Estat√≠sticas de postagem
        print(f"üìä Total de posts: {self.stats['total_posts']}")
        print(f"‚úÖ Sucessos: {self.stats['successful_posts']}")
        print(f"‚ùå Falhas: {self.stats['failed_posts']}")
        print(f"üíæ Produtos em cache: {len(self.posted_products)}")

        if self.stats["last_post_time"]:
            print(
                f"üìÖ √öltimo post: {self.stats['last_post_time'].strftime('%d/%m/%Y %H:%M:%S')}"
            )

        # Configura√ß√µes
        print(f"‚è∞ Intervalo de postagem: {self.posting_interval}")
        print(f"üìù M√°ximo por ciclo: {self.max_posts_per_cycle}")

        print("=" * 60)


async def main():
    """Fun√ß√£o principal"""
    print("üöÄ INICIANDO SISTEMA INTEGRADO DE POSTAGEM AUTOM√ÅTICA")
    print("=" * 60)

    # Cria sistema
    auto_poster = AutoPosterIntegrated()

    # Mostra status inicial
    auto_poster.print_status()

    try:
        # Inicia sistema
        await auto_poster.start()

    except KeyboardInterrupt:
        print("\nüëã Encerrando sistema...")
        auto_poster.running = False

        # Mostra estat√≠sticas finais
        print("\nüìä Estat√≠sticas Finais:")
        final_stats = auto_poster.get_stats()
        for key, value in final_stats.items():
            if isinstance(value, dict):
                print(f"   {key}:")
                for sub_key, sub_value in value.items():
                    print(f"     {sub_key}: {sub_value}")
            else:
                print(f"   {key}: {value}")

    print("\n‚úÖ Sistema encerrado com sucesso!")


if __name__ == "__main__":
    asyncio.run(main())
