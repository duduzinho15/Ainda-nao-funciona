"""
Sistema de Feedback e Sugest√µes - Sistema Garimpeiro Geek
"""

import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any
from pathlib import Path
import sqlite3
import hashlib
import uuid

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class FeedbackSystem:
    """Sistema de feedback e sugest√µes para usu√°rios"""

    def __init__(self):
        self.feedback_db = Path("feedback/feedback.db")
        self.feedback_db.parent.mkdir(parents=True, exist_ok=True)

        # Inicializa banco de dados
        self._init_database()

        # Configura√ß√µes
        self.config = self._load_config()

        # Categorias de feedback
        self.feedback_categories = [
            "feature_request",  # Solicita√ß√£o de funcionalidade
            "bug_report",  # Relat√≥rio de bug
            "improvement",  # Melhoria
            "performance",  # Performance
            "ui_ux",  # Interface/Experi√™ncia
            "documentation",  # Documenta√ß√£o
            "integration",  # Integra√ß√£o
            "other",  # Outros
        ]

        # Status do feedback
        self.feedback_statuses = [
            "pending",  # Pendente
            "under_review",  # Em an√°lise
            "approved",  # Aprovado
            "in_development",  # Em desenvolvimento
            "completed",  # Conclu√≠do
            "rejected",  # Rejeitado
            "duplicate",  # Duplicado
        ]

        # Prioridades
        self.priorities = [
            "low",  # Baixa
            "medium",  # M√©dia
            "high",  # Alta
            "critical",  # Cr√≠tica
        ]

    def _load_config(self) -> Dict[str, Any]:
        """Carrega configura√ß√£o do sistema"""
        config_path = Path("feedback/feedback_config.json")
        if config_path.exists():
            try:
                with open(config_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Falha ao carregar configura√ß√£o: {e}")

        # Configura√ß√£o padr√£o
        return {
            "max_feedback_per_user": 10,
            "auto_approval_threshold": 5,  # Votos para aprova√ß√£o autom√°tica
            "feedback_expiry_days": 365,  # Dias para expirar feedback antigo
            "notify_on_status_change": True,
            "allow_anonymous_feedback": True,
            "moderation_enabled": True,
            "categories": self.feedback_categories,
            "statuses": self.feedback_statuses,
            "priorities": self.priorities,
        }

    def _init_database(self):
        """Inicializa banco de dados"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Tabela de feedback
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS feedback (
                    id TEXT PRIMARY KEY,
                    user_id TEXT,
                    username TEXT,
                    category TEXT NOT NULL,
                    title TEXT NOT NULL,
                    description TEXT NOT NULL,
                    priority TEXT DEFAULT 'medium',
                    status TEXT DEFAULT 'pending',
                    votes INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    assigned_to TEXT,
                    estimated_effort TEXT,
                    tags TEXT,
                    attachments TEXT
                )
            """)

            # Tabela de votos
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS votes (
                    id TEXT PRIMARY KEY,
                    feedback_id TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    vote_type TEXT DEFAULT 'upvote',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (feedback_id) REFERENCES feedback (id),
                    UNIQUE(feedback_id, user_id)
                )
            """)

            # Tabela de coment√°rios
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS comments (
                    id TEXT PRIMARY KEY,
                    feedback_id TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    username TEXT NOT NULL,
                    content TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (feedback_id) REFERENCES feedback (id)
                )
            """)

            # Tabela de hist√≥rico de status
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS status_history (
                    id TEXT PRIMARY KEY,
                    feedback_id TEXT NOT NULL,
                    old_status TEXT,
                    new_status TEXT NOT NULL,
                    changed_by TEXT NOT NULL,
                    reason TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (feedback_id) REFERENCES feedback (id)
                )
            """)

            # Tabela de usu√°rios
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id TEXT PRIMARY KEY,
                    username TEXT UNIQUE NOT NULL,
                    email TEXT,
                    role TEXT DEFAULT 'user',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    feedback_count INTEGER DEFAULT 0,
                    reputation INTEGER DEFAULT 0
                )
            """)

            # √çndices para performance
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_feedback_category ON feedback (category)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_feedback_status ON feedback (status)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_feedback_priority ON feedback (priority)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_feedback_created ON feedback (created_at)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_votes_feedback ON votes (feedback_id)"
            )
            cursor.execute(
                "CREATE INDEX IF NOT EXISTS idx_comments_feedback ON comments (feedback_id)"
            )

            conn.commit()
            conn.close()

            logger.info("‚úÖ Banco de dados de feedback inicializado")

        except Exception as e:
            logger.error(f"Falha ao inicializar banco de dados: {e}")

    def submit_feedback(
        self,
        user_id: str,
        username: str,
        category: str,
        title: str,
        description: str,
        priority: str = "medium",
        tags: List[str] = None,
        attachments: List[str] = None,
    ) -> Dict[str, Any]:
        """Submete novo feedback"""
        try:
            # Valida√ß√µes
            if category not in self.feedback_categories:
                return {"success": False, "error": "Categoria inv√°lida"}

            if priority not in self.priorities:
                return {"success": False, "error": "Prioridade inv√°lida"}

            if len(title.strip()) < 5:
                return {
                    "success": False,
                    "error": "T√≠tulo muito curto (m√≠nimo 5 caracteres)",
                }

            if len(description.strip()) < 20:
                return {
                    "success": False,
                    "error": "Descri√ß√£o muito curta (m√≠nimo 20 caracteres)",
                }

            # Verifica limite de feedback por usu√°rio
            if not self._check_user_feedback_limit(user_id):
                return {"success": False, "error": "Limite de feedback atingido"}

            # Gera ID √∫nico
            feedback_id = str(uuid.uuid4())

            # Prepara dados
            feedback_data = {
                "id": feedback_id,
                "user_id": user_id,
                "username": username,
                "category": category,
                "title": title.strip(),
                "description": description.strip(),
                "priority": priority,
                "status": "pending",
                "votes": 0,
                "tags": json.dumps(tags or []),
                "attachments": json.dumps(attachments or []),
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
            }

            # Salva no banco
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            cursor.execute(
                """
                INSERT INTO feedback 
                (id, user_id, username, category, title, description, priority, 
                 status, votes, tags, attachments, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    feedback_data["id"],
                    feedback_data["user_id"],
                    feedback_data["username"],
                    feedback_data["category"],
                    feedback_data["title"],
                    feedback_data["description"],
                    feedback_data["priority"],
                    feedback_data["status"],
                    feedback_data["votes"],
                    feedback_data["tags"],
                    feedback_data["attachments"],
                    feedback_data["created_at"],
                    feedback_data["updated_at"],
                ),
            )

            # Atualiza contador do usu√°rio
            cursor.execute(
                """
                UPDATE users SET feedback_count = feedback_count + 1 
                WHERE id = ?
            """,
                (user_id,),
            )

            # Cria usu√°rio se n√£o existir
            cursor.execute(
                """
                INSERT OR IGNORE INTO users (id, username, created_at)
                VALUES (?, ?, ?)
            """,
                (user_id, username, datetime.now().isoformat()),
            )

            conn.commit()
            conn.close()

            logger.info(f"‚úÖ Feedback submetido: {title} por {username}")

            return {
                "success": True,
                "feedback_id": feedback_id,
                "message": "Feedback submetido com sucesso!",
            }

        except Exception as e:
            logger.error(f"Falha ao submeter feedback: {e}")
            return {"success": False, "error": str(e)}

    def _check_user_feedback_limit(self, user_id: str) -> bool:
        """Verifica se usu√°rio atingiu limite de feedback"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            cursor.execute(
                """
                SELECT COUNT(*) FROM feedback 
                WHERE user_id = ? AND created_at > ?
            """,
                (user_id, (datetime.now() - timedelta(days=30)).isoformat()),
            )

            count = cursor.fetchone()[0]
            conn.close()

            return count < self.config["max_feedback_per_user"]

        except Exception as e:
            logger.error(f"Falha ao verificar limite: {e}")
            return False

    def vote_feedback(
        self, feedback_id: str, user_id: str, vote_type: str = "upvote"
    ) -> Dict[str, Any]:
        """Vota em um feedback"""
        try:
            if vote_type not in ["upvote", "downvote"]:
                return {"success": False, "error": "Tipo de voto inv√°lido"}

            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Verifica se j√° votou
            cursor.execute(
                """
                SELECT id, vote_type FROM votes 
                WHERE feedback_id = ? AND user_id = ?
            """,
                (feedback_id, user_id),
            )

            existing_vote = cursor.fetchone()

            if existing_vote:
                # Atualiza voto existente
                if existing_vote[1] == vote_type:
                    # Remove voto se for o mesmo tipo
                    cursor.execute(
                        "DELETE FROM votes WHERE id = ?", (existing_vote[0],)
                    )
                    vote_change = -1 if vote_type == "upvote" else 1
                else:
                    # Muda tipo de voto
                    cursor.execute(
                        """
                        UPDATE votes SET vote_type = ? WHERE id = ?
                    """,
                        (vote_type, existing_vote[0]),
                    )
                    vote_change = 2 if vote_type == "upvote" else -2
            else:
                # Novo voto
                vote_id = str(uuid.uuid4())
                cursor.execute(
                    """
                    INSERT INTO votes (id, feedback_id, user_id, vote_type)
                    VALUES (?, ?, ?, ?)
                """,
                    (vote_id, feedback_id, user_id, vote_type),
                )
                vote_change = 1 if vote_type == "upvote" else -1

            # Atualiza contador de votos
            cursor.execute(
                """
                UPDATE feedback SET votes = votes + ? WHERE id = ?
            """,
                (vote_change, feedback_id),
            )

            # Verifica se atingiu threshold para aprova√ß√£o autom√°tica
            if self.config["auto_approval_threshold"] > 0:
                cursor.execute(
                    "SELECT votes, status FROM feedback WHERE id = ?", (feedback_id,)
                )
                votes, status = cursor.fetchone()

                if (
                    votes >= self.config["auto_approval_threshold"]
                    and status == "pending"
                ):
                    self._change_feedback_status(
                        feedback_id,
                        "approved",
                        user_id,
                        "Aprovado automaticamente por votos",
                    )

            conn.commit()
            conn.close()

            logger.info(f"‚úÖ Voto registrado: {vote_type} em {feedback_id}")

            return {
                "success": True,
                "message": "Voto registrado com sucesso!",
                "vote_change": vote_change,
            }

        except Exception as e:
            logger.error(f"Falha ao registrar voto: {e}")
            return {"success": False, "error": str(e)}

    def add_comment(
        self, feedback_id: str, user_id: str, username: str, content: str
    ) -> Dict[str, Any]:
        """Adiciona coment√°rio a um feedback"""
        try:
            if len(content.strip()) < 5:
                return {
                    "success": False,
                    "error": "Coment√°rio muito curto (m√≠nimo 5 caracteres)",
                }

            comment_id = str(uuid.uuid4())

            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            cursor.execute(
                """
                INSERT INTO comments (id, feedback_id, user_id, username, content)
                VALUES (?, ?, ?, ?, ?)
            """,
                (comment_id, feedback_id, user_id, username, content.strip()),
            )

            # Atualiza timestamp do feedback
            cursor.execute(
                """
                UPDATE feedback SET updated_at = ? WHERE id = ?
            """,
                (datetime.now().isoformat(), feedback_id),
            )

            conn.commit()
            conn.close()

            logger.info(f"‚úÖ Coment√°rio adicionado por {username}")

            return {
                "success": True,
                "comment_id": comment_id,
                "message": "Coment√°rio adicionado com sucesso!",
            }

        except Exception as e:
            logger.error(f"Falha ao adicionar coment√°rio: {e}")
            return {"success": False, "error": str(e)}

    def change_feedback_status(
        self, feedback_id: str, new_status: str, changed_by: str, reason: str = None
    ) -> Dict[str, Any]:
        """Muda status de um feedback"""
        try:
            if new_status not in self.feedback_statuses:
                return {"success": False, "error": "Status inv√°lido"}

            return self._change_feedback_status(
                feedback_id, new_status, changed_by, reason
            )

        except Exception as e:
            logger.error(f"Falha ao mudar status: {e}")
            return {"success": False, "error": str(e)}

    def _change_feedback_status(
        self, feedback_id: str, new_status: str, changed_by: str, reason: str = None
    ) -> Dict[str, Any]:
        """Muda status internamente"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Obt√©m status atual
            cursor.execute("SELECT status FROM feedback WHERE id = ?", (feedback_id,))
            result = cursor.fetchone()

            if not result:
                conn.close()
                return {"success": False, "error": "Feedback n√£o encontrado"}

            old_status = result[0]

            # Atualiza status
            cursor.execute(
                """
                UPDATE feedback SET status = ?, updated_at = ? WHERE id = ?
            """,
                (new_status, datetime.now().isoformat(), feedback_id),
            )

            # Registra no hist√≥rico
            history_id = str(uuid.uuid4())
            cursor.execute(
                """
                INSERT INTO status_history (id, feedback_id, old_status, new_status, changed_by, reason)
                VALUES (?, ?, ?, ?, ?, ?)
            """,
                (
                    history_id,
                    feedback_id,
                    old_status,
                    new_status,
                    changed_by,
                    reason or "",
                ),
            )

            conn.commit()
            conn.close()

            logger.info(f"‚úÖ Status alterado: {old_status} -> {new_status}")

            return {
                "success": True,
                "message": f"Status alterado para {new_status}",
                "old_status": old_status,
                "new_status": new_status,
            }

        except Exception as e:
            logger.error(f"Falha ao alterar status: {e}")
            return {"success": False, "error": str(e)}

    def get_feedback(
        self,
        feedback_id: str = None,
        category: str = None,
        status: str = None,
        priority: str = None,
        user_id: str = None,
        limit: int = 50,
        offset: int = 0,
    ) -> Dict[str, Any]:
        """Obt√©m feedback com filtros"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Constr√≥i query
            query = "SELECT * FROM feedback WHERE 1=1"
            params = []

            if feedback_id:
                query += " AND id = ?"
                params.append(feedback_id)

            if category:
                query += " AND category = ?"
                params.append(category)

            if status:
                query += " AND status = ?"
                params.append(status)

            if priority:
                query += " AND priority = ?"
                params.append(priority)

            if user_id:
                query += " AND user_id = ?"
                params.append(user_id)

            query += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
            params.extend([limit, offset])

            cursor.execute(query, params)
            rows = cursor.fetchall()

            # Converte para dicion√°rios
            feedback_list = []
            for row in rows:
                feedback = {
                    "id": row[0],
                    "user_id": row[1],
                    "username": row[2],
                    "category": row[3],
                    "title": row[4],
                    "description": row[5],
                    "priority": row[6],
                    "status": row[7],
                    "votes": row[8],
                    "created_at": row[9],
                    "updated_at": row[10],
                    "assigned_to": row[11],
                    "estimated_effort": row[12],
                    "tags": json.loads(row[13]) if row[13] else [],
                    "attachments": json.loads(row[14]) if row[14] else [],
                }

                # Adiciona coment√°rios se solicitado
                if feedback_id:
                    feedback["comments"] = self._get_feedback_comments(feedback_id)
                    feedback["status_history"] = self._get_status_history(feedback_id)

                feedback_list.append(feedback)

            conn.close()

            return {"success": True, "data": feedback_list, "count": len(feedback_list)}

        except Exception as e:
            logger.error(f"Falha ao obter feedback: {e}")
            return {"success": False, "error": str(e)}

    def _get_feedback_comments(self, feedback_id: str) -> List[Dict[str, Any]]:
        """Obt√©m coment√°rios de um feedback"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            cursor.execute(
                """
                SELECT * FROM comments WHERE feedback_id = ? ORDER BY created_at ASC
            """,
                (feedback_id,),
            )

            rows = cursor.fetchall()
            conn.close()

            comments = []
            for row in rows:
                comments.append(
                    {
                        "id": row[0],
                        "feedback_id": row[1],
                        "user_id": row[2],
                        "username": row[3],
                        "content": row[4],
                        "created_at": row[5],
                        "updated_at": row[6],
                    }
                )

            return comments

        except Exception as e:
            logger.error(f"Falha ao obter coment√°rios: {e}")
            return []

    def _get_status_history(self, feedback_id: str) -> List[Dict[str, Any]]:
        """Obt√©m hist√≥rico de status de um feedback"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            cursor.execute(
                """
                SELECT * FROM status_history WHERE feedback_id = ? ORDER BY created_at ASC
            """,
                (feedback_id,),
            )

            rows = cursor.fetchall()
            conn.close()

            history = []
            for row in rows:
                history.append(
                    {
                        "id": row[0],
                        "feedback_id": row[1],
                        "old_status": row[2],
                        "new_status": row[3],
                        "changed_by": row[4],
                        "reason": row[5],
                        "created_at": row[6],
                    }
                )

            return history

        except Exception as e:
            logger.error(f"Falha ao obter hist√≥rico: {e}")
            return []

    def get_feedback_stats(self) -> Dict[str, Any]:
        """Obt√©m estat√≠sticas do sistema de feedback"""
        try:
            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Total de feedback
            cursor.execute("SELECT COUNT(*) FROM feedback")
            total_feedback = cursor.fetchone()[0]

            # Por categoria
            cursor.execute("""
                SELECT category, COUNT(*) FROM feedback 
                GROUP BY category ORDER BY COUNT(*) DESC
            """)
            category_stats = dict(cursor.fetchall())

            # Por status
            cursor.execute("""
                SELECT status, COUNT(*) FROM feedback 
                GROUP BY status ORDER BY COUNT(*) DESC
            """)
            status_stats = dict(cursor.fetchall())

            # Por prioridade
            cursor.execute("""
                SELECT priority, COUNT(*) FROM feedback 
                GROUP BY priority ORDER BY COUNT(*) DESC
            """)
            priority_stats = dict(cursor.fetchall())

            # Total de votos
            cursor.execute("SELECT SUM(votes) FROM feedback")
            total_votes = cursor.fetchone()[0] or 0

            # Total de coment√°rios
            cursor.execute("SELECT COUNT(*) FROM comments")
            total_comments = cursor.fetchone()[0]

            # Usu√°rios mais ativos
            cursor.execute("""
                SELECT username, feedback_count FROM users 
                ORDER BY feedback_count DESC LIMIT 10
            """)
            top_users = [
                {"username": row[0], "count": row[1]} for row in cursor.fetchall()
            ]

            # Feedback mais votado
            cursor.execute("""
                SELECT title, votes, category FROM feedback 
                ORDER BY votes DESC LIMIT 5
            """)
            top_feedback = [
                {"title": row[0], "votes": row[1], "category": row[2]}
                for row in cursor.fetchall()
            ]

            conn.close()

            return {
                "success": True,
                "stats": {
                    "total_feedback": total_feedback,
                    "total_votes": total_votes,
                    "total_comments": total_comments,
                    "category_stats": category_stats,
                    "status_stats": status_stats,
                    "priority_stats": priority_stats,
                    "top_users": top_users,
                    "top_feedback": top_feedback,
                },
            }

        except Exception as e:
            logger.error(f"Falha ao obter estat√≠sticas: {e}")
            return {"success": False, "error": str(e)}

    def search_feedback(
        self, query: str, category: str = None, status: str = None, limit: int = 20
    ) -> Dict[str, Any]:
        """Pesquisa feedback por texto"""
        try:
            if len(query.strip()) < 3:
                return {
                    "success": False,
                    "error": "Query muito curta (m√≠nimo 3 caracteres)",
                }

            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Constr√≥i query de pesquisa
            search_query = """
                SELECT * FROM feedback 
                WHERE (title LIKE ? OR description LIKE ?)
            """
            params = [f"%{query}%", f"%{query}%"]

            if category:
                search_query += " AND category = ?"
                params.append(category)

            if status:
                search_query += " AND status = ?"
                params.append(status)

            search_query += " ORDER BY votes DESC, created_at DESC LIMIT ?"
            params.append(limit)

            cursor.execute(search_query, params)
            rows = cursor.fetchall()

            conn.close()

            # Converte resultados
            results = []
            for row in rows:
                results.append(
                    {
                        "id": row[0],
                        "user_id": row[1],
                        "username": row[2],
                        "category": row[3],
                        "title": row[4],
                        "description": row[5],
                        "priority": row[6],
                        "status": row[7],
                        "votes": row[8],
                        "created_at": row[9],
                        "tags": json.loads(row[13]) if row[13] else [],
                    }
                )

            return {
                "success": True,
                "data": results,
                "count": len(results),
                "query": query,
            }

        except Exception as e:
            logger.error(f"Falha na pesquisa: {e}")
            return {"success": False, "error": str(e)}

    def cleanup_old_feedback(self) -> Dict[str, Any]:
        """Remove feedback antigo"""
        try:
            cutoff_date = datetime.now() - timedelta(
                days=self.config["feedback_expiry_days"]
            )

            conn = sqlite3.connect(self.feedback_db)
            cursor = conn.cursor()

            # Conta feedback antigo
            cursor.execute(
                """
                SELECT COUNT(*) FROM feedback 
                WHERE created_at < ? AND status IN ('completed', 'rejected')
            """,
                (cutoff_date.isoformat(),),
            )

            old_count = cursor.fetchone()[0]

            if old_count > 0:
                # Remove feedback antigo
                cursor.execute(
                    """
                    DELETE FROM feedback 
                    WHERE created_at < ? AND status IN ('completed', 'rejected')
                """,
                    (cutoff_date.isoformat(),),
                )

                # Remove coment√°rios √≥rf√£os
                cursor.execute("""
                    DELETE FROM comments WHERE feedback_id NOT IN 
                    (SELECT id FROM feedback)
                """)

                # Remove votos √≥rf√£os
                cursor.execute("""
                    DELETE FROM votes WHERE feedback_id NOT IN 
                    (SELECT id FROM feedback)
                """)

                # Remove hist√≥rico √≥rf√£o
                cursor.execute("""
                    DELETE FROM status_history WHERE feedback_id NOT IN 
                    (SELECT id FROM feedback)
                """)

                conn.commit()
                logger.info(f"‚úÖ {old_count} feedbacks antigos removidos")

            conn.close()

            return {
                "success": True,
                "removed_count": old_count,
                "message": f"{old_count} feedbacks antigos removidos",
            }

        except Exception as e:
            logger.error(f"Falha na limpeza: {e}")
            return {"success": False, "error": str(e)}


def main():
    """Fun√ß√£o principal para teste"""
    print("üìù Sistema de Feedback - Garimpeiro Geek")
    print("=" * 50)

    feedback_system = FeedbackSystem()

    try:
        while True:
            print("\nüìã Menu de Feedback:")
            print("   1. üìù Submeter feedback")
            print("   2. üëç Votar em feedback")
            print("   3. üí¨ Adicionar coment√°rio")
            print("   4. üìä Ver estat√≠sticas")
            print("   5. üîç Pesquisar feedback")
            print("   6. üßπ Limpar feedback antigo")
            print("   7. ‚ùå Sair")

            choice = input("\n‚ùì Escolha uma op√ß√£o (1-7): ")

            if choice == "1":
                print("\nüìù Submetendo feedback...")

                username = input("Seu nome: ")
                user_id = hashlib.md5(username.encode()).hexdigest()[:8]

                print("\nüìã Categorias dispon√≠veis:")
                for i, cat in enumerate(feedback_system.feedback_categories):
                    print(f"   {i + 1}. {cat}")

                category_choice = (
                    int(
                        input(
                            f"\n‚ùì Escolha categoria (1-{len(feedback_system.feedback_categories)}): "
                        )
                    )
                    - 1
                )
                category = feedback_system.feedback_categories[category_choice]

                title = input("T√≠tulo: ")
                description = input("Descri√ß√£o: ")

                print("\nüìã Prioridades dispon√≠veis:")
                for i, pri in enumerate(feedback_system.priorities):
                    print(f"   {i + 1}. {pri}")

                priority_choice = (
                    int(
                        input(
                            f"\n‚ùì Escolha prioridade (1-{len(feedback_system.priorities)}): "
                        )
                    )
                    - 1
                )
                priority = feedback_system.priorities[priority_choice]

                tags_input = input("Tags (separadas por v√≠rgula): ")
                tags = [tag.strip() for tag in tags_input.split(",") if tag.strip()]

                result = feedback_system.submit_feedback(
                    user_id, username, category, title, description, priority, tags
                )

                if result["success"]:
                    print(f"‚úÖ {result['message']}")
                    print(f"üìù ID: {result['feedback_id']}")
                else:
                    print(f"‚ùå {result['error']}")

            elif choice == "2":
                print("\nüëç Votando em feedback...")

                feedback_id = input("ID do feedback: ")
                user_id = input("Seu ID: ")

                print("Tipos de voto: upvote, downvote")
                vote_type = input("Tipo de voto: ")

                result = feedback_system.vote_feedback(feedback_id, user_id, vote_type)

                if result["success"]:
                    print(f"‚úÖ {result['message']}")
                else:
                    print(f"‚ùå {result['error']}")

            elif choice == "3":
                print("\nüí¨ Adicionando coment√°rio...")

                feedback_id = input("ID do feedback: ")
                user_id = input("Seu ID: ")
                username = input("Seu nome: ")
                content = input("Coment√°rio: ")

                result = feedback_system.add_comment(
                    feedback_id, user_id, username, content
                )

                if result["success"]:
                    print(f"‚úÖ {result['message']}")
                else:
                    print(f"‚ùå {result['error']}")

            elif choice == "4":
                print("\nüìä Estat√≠sticas do sistema...")

                stats = feedback_system.get_feedback_stats()

                if stats["success"]:
                    data = stats["stats"]
                    print("\nüìà Estat√≠sticas Gerais:")
                    print(f"   Total de feedback: {data['total_feedback']}")
                    print(f"   Total de votos: {data['total_votes']}")
                    print(f"   Total de coment√°rios: {data['total_comments']}")

                    print("\nüìã Por Categoria:")
                    for cat, count in data["category_stats"].items():
                        print(f"   {cat}: {count}")

                    print("\nüìä Por Status:")
                    for status, count in data["status_stats"].items():
                        print(f"   {status}: {count}")

                    print("\nüèÜ Usu√°rios Mais Ativos:")
                    for user in data["top_users"][:5]:
                        print(f"   {user['username']}: {user['count']} feedbacks")

                else:
                    print(f"‚ùå {stats['error']}")

            elif choice == "5":
                print("\nüîç Pesquisando feedback...")

                query = input("Termo de pesquisa: ")
                result = feedback_system.search_feedback(query)

                if result["success"]:
                    print(f"\nüîç Resultados para '{query}':")
                    print(f"   Encontrados: {result['count']}")

                    for i, feedback in enumerate(result["data"][:5]):
                        print(f"\n   {i + 1}. {feedback['title']}")
                        print(f"      Categoria: {feedback['category']}")
                        print(f"      Status: {feedback['status']}")
                        print(f"      Votos: {feedback['votes']}")
                        print(f"      Por: {feedback['username']}")
                else:
                    print(f"‚ùå {result['error']}")

            elif choice == "6":
                print("\nüßπ Limpando feedback antigo...")

                result = feedback_system.cleanup_old_feedback()

                if result["success"]:
                    print(f"‚úÖ {result['message']}")
                else:
                    print(f"‚ùå {result['error']}")

            elif choice == "7":
                print("üëã Saindo do sistema de feedback...")
                break

            else:
                print("‚ùå Op√ß√£o inv√°lida")

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è Interrompido pelo usu√°rio")

    print("‚úÖ Sistema de feedback finalizado")


if __name__ == "__main__":
    main()
