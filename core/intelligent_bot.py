"""
Bot inteligente com capacidades de NLP para o Garimpeiro Geek.
Implementa processamento de linguagem natural para entender inten√ß√µes do usu√°rio.
"""

import logging
import re
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import asyncio

# Imports locais
try:
    from .database import get_session, Offer
    from .recommendation_engine import get_recommendations
except ImportError:
    # Para teste direto
    from database import get_session, Offer
    from recommendation_engine import get_recommendations

logger = logging.getLogger(__name__)

class IntentType(Enum):
    """Tipos de inten√ß√£o do usu√°rio."""
    SEARCH_PRODUCTS = "search_products"
    GET_RECOMMENDATIONS = "get_recommendations"
    SET_PRICE_ALERT = "set_price_alert"
    GET_MARKET_INSIGHTS = "get_market_insights"
    SET_PREFERENCES = "set_preferences"
    GET_HELP = "get_help"
    UNKNOWN = "unknown"

class CommandType(Enum):
    """Tipos de comando."""
    SEARCH = "search"
    RECOMMEND = "recommend"
    ALERT = "alert"
    INSIGHTS = "insights"
    PREFERENCES = "preferences"
    HELP = "help"

@dataclass
class UserIntent:
    """Representa a inten√ß√£o detectada do usu√°rio."""
    intent: IntentType
    confidence: float
    entities: Dict[str, List[str]]
    raw_text: str

class NLPProcessor:
    """Processador de linguagem natural para detectar inten√ß√µes."""
    
    def __init__(self):
        # Padr√µes para detec√ß√£o de inten√ß√µes
        self.patterns = {
            IntentType.SEARCH_PRODUCTS: [
                r"quero\s+(?:um|uma|uns|umas)?\s+([^,]+)",
                r"procuro\s+(?:um|uma|uns|umas)?\s+([^,]+)",
                r"busco\s+(?:um|uma|uns|umas)?\s+([^,]+)",
                r"preciso\s+(?:de\s+)?(?:um|uma|uns|umas)?\s+([^,]+)",
                r"([^,]+)\s+(?:barato|barata|econ√¥mico|econ√¥mica)",
                r"([^,]+)\s+(?:com\s+)?(?:desconto|promo√ß√£o|oferta)",
            ],
            IntentType.GET_RECOMMENDATIONS: [
                r"(?:me\s+)?recomenda(?:r|ndo)?\s+([^,]+)",
                r"(?:quero\s+)?(?:sugest√µes|recomenda√ß√µes)\s+(?:de|para)\s+([^,]+)",
                r"(?:me\s+)?sugira\s+([^,]+)",
                r"(?:quero\s+)?(?:ideias|op√ß√µes)\s+(?:de|para)\s+([^,]+)",
            ],
            IntentType.SET_PRICE_ALERT: [
                r"(?:quero\s+)?(?:monitorar|acompanhar)\s+(?:pre√ßos\s+)?(?:de\s+)?([^,]+)",
                r"(?:me\s+)?avise\s+(?:quando|se)\s+(?:o\s+)?(?:pre√ßo\s+)?(?:de\s+)?([^,]+)",
                r"(?:quero\s+)?(?:alerta|notifica√ß√£o)\s+(?:de\s+)?(?:pre√ßo\s+)?(?:para\s+)?([^,]+)",
            ],
            IntentType.GET_MARKET_INSIGHTS: [
                r"(?:como\s+)?(?:est√°\s+)?(?:o\s+)?(?:mercado|pre√ßos)\s+(?:de\s+)?([^,]+)",
                r"(?:quero\s+)?(?:saber|conhecer)\s+(?:sobre\s+)?(?:o\s+)?(?:mercado\s+)?(?:de\s+)?([^,]+)",
                r"(?:me\s+)?(?:informe|diga)\s+(?:sobre\s+)?(?:o\s+)?(?:mercado\s+)?(?:de\s+)?([^,]+)",
            ],
            IntentType.SET_PREFERENCES: [
                r"(?:quero\s+)?(?:definir|configurar|ajustar)\s+(?:minhas\s+)?(?:prefer√™ncias|configura√ß√µes)",
                r"(?:meus\s+)?(?:gostos|interesses|prefer√™ncias)",
                r"(?:quero\s+)?(?:personalizar|customizar)\s+(?:minhas\s+)?(?:recomenda√ß√µes)",
            ],
            IntentType.GET_HELP: [
                r"(?:preciso\s+)?(?:de\s+)?(?:ajuda|socorro)",
                r"(?:como\s+)?(?:funciona|uso|fa√ßo)",
                r"(?:quais\s+)?(?:s√£o\s+)?(?:os\s+)?(?:comandos|op√ß√µes)",
                r"(?:me\s+)?(?:explique|ensine|mostre)",
            ]
        }
        
        # Categorias conhecidas
        self.categories = [
            "notebook", "laptop", "computador", "pc", "desktop",
            "smartphone", "celular", "telefone", "iphone", "android",
            "monitor", "tela", "display", "tv", "televis√£o",
            "fone", "headphone", "headset", "earphone", "airpods",
            "mouse", "teclado", "keyboard", "webcam", "c√¢mera",
            "gaming", "jogos", "console", "playstation", "xbox",
            "eletr√¥nicos", "tecnologia", "gadgets", "acess√≥rios"
        ]
        
        # Lojas conhecidas
        self.stores = [
            "amazon", "mercadolivre", "magalu", "americanas", "submarino",
            "kabum", "terabyteshop", "pichau", "casas bahia", "extra",
            "ricardo eletro", "fast shop", "saraiva", "livraria cultura"
        ]
        
        # Marcas conhecidas
        self.brands = [
            "apple", "samsung", "lg", "sony", "asus", "acer", "lenovo",
            "dell", "hp", "msi", "gigabyte", "corsair", "logitech",
            "razer", "steelseries", "hyperx", "jbl", "bose", "sennheiser"
        ]
    
    def detect_intent(self, text: str) -> UserIntent:
        """
        Detecta a inten√ß√£o do usu√°rio baseado no texto.
        
        Args:
            text: Texto do usu√°rio
            
        Returns:
            UserIntent: Inten√ß√£o detectada
        """
        text = text.lower().strip()
        
        # Detectar inten√ß√£o principal
        best_intent = IntentType.UNKNOWN
        best_confidence = 0.0
        best_entities = {}
        
        for intent_type, patterns in self.patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, text, re.IGNORECASE)
                if matches:
                    confidence = self._calculate_confidence(text, pattern, matches)
                    if confidence > best_confidence:
                        best_confidence = confidence
                        best_intent = intent_type
                        best_entities = self._extract_entities(text, matches)
        
        # Se n√£o encontrou padr√£o espec√≠fico, tentar inferir
        if best_intent == IntentType.UNKNOWN:
            best_intent, best_confidence = self._infer_intent(text)
            best_entities = self._extract_entities(text, [])
        
        return UserIntent(
            intent=best_intent,
            confidence=best_confidence,
            entities=best_entities,
            raw_text=text
        )
    
    def _calculate_confidence(self, text: str, pattern: str, matches: List[str]) -> float:
        """Calcula a confian√ßa da detec√ß√£o."""
        # Base: 0.5
        confidence = 0.5
        
        # B√¥nus por ter palavras-chave espec√≠ficas
        if any(word in text for word in ["quero", "preciso", "procuro", "busco"]):
            confidence += 0.2
        
        # B√¥nus por ter entidades espec√≠ficas
        if any(cat in text for cat in self.categories):
            confidence += 0.2
        
        # B√¥nus por ter lojas ou marcas
        if any(store in text for store in self.stores):
            confidence += 0.1
        
        if any(brand in text for brand in self.brands):
            confidence += 0.1
        
        # Limitar a 1.0
        return min(confidence, 1.0)
    
    def _extract_entities(self, text: str, matches: List[str]) -> Dict[str, List[str]]:
        """Extrai entidades do texto."""
        entities = {}
        
        # Categorias
        found_categories = []
        for category in self.categories:
            if category in text:
                found_categories.append(category)
        if found_categories:
            entities['category'] = found_categories
        
        # Lojas
        found_stores = []
        for store in self.stores:
            if store in text:
                found_stores.append(store)
        if found_stores:
            entities['store'] = found_stores
        
        # Marcas
        found_brands = []
        for brand in self.brands:
            if brand in text:
                found_brands.append(brand)
        if found_brands:
            entities['brand'] = found_brands
        
        # Produtos espec√≠ficos das matches
        if matches:
            entities['product'] = [match.strip() for match in matches if match.strip()]
        
        return entities
    
    def _infer_intent(self, text: str) -> Tuple[IntentType, float]:
        """Infer√™ncia de inten√ß√£o quando n√£o h√° padr√£o espec√≠fico."""
        # Palavras que sugerem busca
        search_words = ["produto", "item", "coisa", "objeto", "artigo"]
        if any(word in text for word in search_words):
            return IntentType.SEARCH_PRODUCTS, 0.3
        
        # Palavras que sugerem ajuda
        help_words = ["ajuda", "socorro", "problema", "d√∫vida", "quest√£o"]
        if any(word in text for word in help_words):
            return IntentType.GET_HELP, 0.4
        
        # Padr√£o: busca gen√©rica
        return IntentType.SEARCH_PRODUCTS, 0.2

class IntelligentBot:
    """Bot inteligente principal."""
    
    def __init__(self):
        self.nlp_processor = NLPProcessor()
        logger.info("ü§ñ Bot inteligente inicializado")
    
    async def handle_natural_language(self, message: str, user_id: int) -> str:
        """
        Processa mensagem em linguagem natural e responde.
        
        Args:
            message: Mensagem do usu√°rio
            user_id: ID do usu√°rio
            
        Returns:
            str: Resposta do bot
        """
        try:
            # Detectar inten√ß√£o
            intent = self.nlp_processor.detect_intent(message)
            
            # Processar baseado na inten√ß√£o
            if intent.intent == IntentType.SEARCH_PRODUCTS:
                return await self._handle_product_search(intent, user_id)
            
            elif intent.intent == IntentType.GET_RECOMMENDATIONS:
                return await self._handle_recommendations(intent, user_id)
            
            elif intent.intent == IntentType.SET_PRICE_ALERT:
                return await self._handle_price_alert(intent, user_id)
            
            elif intent.intent == IntentType.GET_MARKET_INSIGHTS:
                return await self._handle_market_insights(intent, user_id)
            
            elif intent.intent == IntentType.SET_PREFERENCES:
                return await self._handle_preferences(intent, user_id)
            
            elif intent.intent == IntentType.GET_HELP:
                return await self._handle_help(intent, user_id)
            
            else:
                return await self._handle_unknown(intent, user_id)
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao processar mensagem: {e}")
            return "Desculpe, tive um problema ao processar sua mensagem. Pode tentar novamente?"
    
    async def _handle_product_search(self, intent: UserIntent, user_id: int) -> str:
        """Processa busca de produtos."""
        try:
            # Buscar produtos
            products = await self._search_products_for_suggestion(intent.raw_text, intent)
            
            if not products:
                return "N√£o encontrei produtos que correspondam √† sua busca. Pode tentar com outras palavras?"
            
            # Formatar resposta
            response = "üîç Encontrei estes produtos para voc√™:\n\n"
            
            for i, product in enumerate(products[:5], 1):
                price = f"R$ {product['price']:.2f}" if product['price'] else "Pre√ßo n√£o dispon√≠vel"
                discount = f" ({product['score']:.0f}% OFF)" if product['score'] > 0 else ""
                
                response += f"{i}. **{product['title']}**\n"
                response += f"   üí∞ {price}{discount}\n"
                response += f"   üè™ {product['store']}\n"
                response += f"   üìÇ {product['category']}\n\n"
            
            if len(products) > 5:
                response += f"_... e mais {len(products) - 5} produtos encontrados._"
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro na busca de produtos: {e}")
            return "Desculpe, tive um problema ao buscar produtos. Pode tentar novamente?"
    
    async def _handle_recommendations(self, intent: UserIntent, user_id: int) -> str:
        """Processa pedidos de recomenda√ß√µes."""
        try:
            # Obter recomenda√ß√µes
            recommendations = get_recommendations(user_id=user_id, limit=5)
            
            if not recommendations:
                return "Ainda n√£o tenho recomenda√ß√µes personalizadas para voc√™. Continue usando o sistema para que eu aprenda seus gostos!"
            
            # Formatar resposta
            response = "üéØ Aqui est√£o minhas recomenda√ß√µes para voc√™:\n\n"
            
            for i, rec in enumerate(recommendations, 1):
                response += f"{i}. **{rec['title']}**\n"
                response += f"   üí∞ R$ {rec['price']:.2f}\n"
                response += f"   üè™ {rec['store']}\n"
                response += f"   ‚≠ê Score: {rec['score']:.1f}\n\n"
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro nas recomenda√ß√µes: {e}")
            return "Desculpe, tive um problema ao gerar recomenda√ß√µes. Pode tentar novamente?"
    
    async def _handle_price_alert(self, intent: UserIntent, user_id: int) -> str:
        """Processa configura√ß√£o de alertas de pre√ßo."""
        try:
            # Extrair produto do intent
            product = intent.entities.get('product', ['produto'])[0]
            
            # TODO: Implementar sistema de alertas
            response = f"üîî Entendi! Voc√™ quer monitorar pre√ßos de **{product}**.\n\n"
            response += "Esta funcionalidade ser√° implementada em breve. "
            response += "Por enquanto, voc√™ pode usar a busca de produtos para acompanhar pre√ßos manualmente."
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro no alerta de pre√ßo: {e}")
            return "Desculpe, tive um problema ao configurar o alerta. Pode tentar novamente?"
    
    async def _handle_market_insights(self, intent: UserIntent, user_id: int) -> str:
        """Processa pedidos de insights de mercado."""
        try:
            # Extrair categoria do intent
            category = intent.entities.get('category', ['eletr√¥nicos'])[0]
            
            # TODO: Implementar an√°lise de mercado
            response = f"üìä Voc√™ quer saber sobre o mercado de **{category}**!\n\n"
            response += "Esta funcionalidade ser√° implementada em breve. "
            response += "Por enquanto, voc√™ pode usar a busca de produtos para ver as ofertas atuais."
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro nos insights de mercado: {e}")
            return "Desculpe, tive um problema ao gerar insights. Pode tentar novamente?"
    
    async def _handle_preferences(self, intent: UserIntent, user_id: int) -> str:
        """Processa configura√ß√£o de prefer√™ncias."""
        try:
            response = "‚öôÔ∏è Configura√ß√£o de prefer√™ncias!\n\n"
            response += "Para personalizar suas recomenda√ß√µes, voc√™ pode:\n"
            response += "‚Ä¢ Usar comandos espec√≠ficos como '/preferences'\n"
            response += "‚Ä¢ Responder perguntas sobre seus interesses\n"
            response += "‚Ä¢ Ajustar configura√ß√µes no dashboard\n\n"
            response += "Esta funcionalidade ser√° implementada em breve!"
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro nas prefer√™ncias: {e}")
            return "Desculpe, tive um problema com as prefer√™ncias. Pode tentar novamente?"
    
    async def _handle_help(self, intent: UserIntent, user_id: int) -> str:
        """Processa pedidos de ajuda."""
        try:
            response = "ü§ñ **Como posso te ajudar?**\n\n"
            response += "**üîç Buscar produtos:**\n"
            response += "‚Ä¢ 'Quero um notebook barato'\n"
            response += "‚Ä¢ 'Procuro smartphone com desconto'\n"
            response += "‚Ä¢ 'Preciso de monitor gaming'\n\n"
            
            response += "**üéØ Recomenda√ß√µes:**\n"
            response += "‚Ä¢ 'Me recomenda produtos de gaming'\n"
            response += "‚Ä¢ 'Sugest√µes para eletr√¥nicos'\n\n"
            
            response += "**üîî Alertas de pre√ßo:**\n"
            response += "‚Ä¢ 'Quero monitorar pre√ßos de smartphones'\n"
            response += "‚Ä¢ 'Me avise quando o pre√ßo baixar'\n\n"
            
            response += "**üìä Insights de mercado:**\n"
            response += "‚Ä¢ 'Como est√° o mercado de notebooks?'\n"
            response += "‚Ä¢ 'Quero saber sobre pre√ßos de eletr√¥nicos'\n\n"
            
            response += "**‚öôÔ∏è Prefer√™ncias:**\n"
            response += "‚Ä¢ 'Quero personalizar minhas recomenda√ß√µes'\n"
            response += "‚Ä¢ 'Configurar meus interesses'\n\n"
            
            response += "üí° **Dica:** Quanto mais espec√≠fico voc√™ for, melhor posso te ajudar!"
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro na ajuda: {e}")
            return "Desculpe, tive um problema ao mostrar a ajuda. Pode tentar novamente?"
    
    async def _handle_unknown(self, intent: UserIntent, user_id: int) -> str:
        """Processa inten√ß√µes desconhecidas."""
        try:
            response = "ü§î N√£o entendi exatamente o que voc√™ quer.\n\n"
            response += "Voc√™ pode:\n"
            response += "‚Ä¢ Tentar ser mais espec√≠fico\n"
            response += "‚Ä¢ Usar frases como 'quero um notebook' ou 'me recomenda produtos'\n"
            response += "‚Ä¢ Digitar '/help' para ver todas as op√ß√µes\n\n"
            response += "üí° **Exemplos que funcionam bem:**\n"
            response += "‚Ä¢ 'Quero um notebook barato'\n"
            response += "‚Ä¢ 'Me recomenda produtos de gaming'\n"
            response += "‚Ä¢ 'Como est√° o mercado de eletr√¥nicos?'"
            
            return response
            
        except Exception as e:
            logger.error(f"‚ùå Erro no tratamento de inten√ß√£o desconhecida: {e}")
            return "Desculpe, tive um problema. Pode tentar novamente ou digitar '/help'?"

    async def suggest_products(self, user_query: str, user_id: int) -> List[Dict]:
        """
        Sugere produtos baseado na consulta do usu√°rio.
        
        Args:
            user_query: Consulta do usu√°rio
            user_id: ID do usu√°rio
            
        Returns:
            List[Dict]: Lista de produtos sugeridos
        """
        try:
            # Detectar inten√ß√£o
            intent = self.nlp_processor.detect_intent(user_query)
            
            # Se for busca de produtos, usar busca
            if intent.intent == IntentType.SEARCH_PRODUCTS:
                return await self._search_products_for_suggestion(user_query, intent)
            
            # Se for recomenda√ß√µes, usar engine de ML
            elif intent.intent == IntentType.GET_RECOMMENDATIONS:
                category = intent.entities.get('category', [None])[0]
                return get_recommendations(user_id=user_id, limit=10, category=category)
            
            # Caso padr√£o: buscar produtos relevantes
            else:
                return await self._search_products_for_suggestion(user_query, intent)
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao sugerir produtos: {e}")
            return []
    
    async def _search_products_for_suggestion(self, query: str, intent: UserIntent) -> List[Dict]:
        """Busca produtos para sugest√£o."""
        try:
            with get_session() as session:
                # Construir query
                db_query = session.query(Offer).filter(Offer.is_active == True)
                
                # Filtrar por categoria se especificada
                if intent.entities.get('category'):
                    category = intent.entities.get('category')[0]
                    db_query = db_query.filter(Offer.category.ilike(f'%{category}%'))
                
                # Filtrar por loja se especificada
                if intent.entities.get('store'):
                    store = intent.entities.get('store')[0]
                    db_query = db_query.filter(Offer.store.ilike(f'%{store}%'))
                
                # Filtrar por marca se especificada
                if intent.entities.get('brand'):
                    brand = intent.entities.get('brand')[0]
                    db_query = db_query.filter(Offer.brand.ilike(f'%{brand}%'))
                
                # Buscar produtos
                offers = db_query.order_by(
                    Offer.discount_percentage.desc(),
                    Offer.created_at.desc()
                ).limit(10).all()
                
                # Converter para formato padr√£o
                suggestions = []
                for offer in offers:
                    suggestions.append({
                        'id': offer.id,
                        'title': offer.title,
                        'category': offer.category,
                        'store': offer.store,
                        'price': offer.price,
                        'original_price': offer.original_price,
                        'score': offer.discount_percentage or 0,
                        'type': 'search_result'
                    })
                
                return suggestions
                
        except Exception as e:
            logger.error(f"‚ùå Erro na busca para sugest√£o: {e}")
            return []


# Inst√¢ncia global
intelligent_bot = IntelligentBot()

# Fun√ß√µes de conveni√™ncia
async def handle_natural_language(message: str, user_id: int) -> str:
    """Processa linguagem natural e responde."""
    return await intelligent_bot.handle_natural_language(message, user_id)

async def suggest_products(user_query: str, user_id: int) -> List[Dict]:
    """Sugere produtos baseado na consulta."""
    return await intelligent_bot.suggest_products(user_query, user_id)


if __name__ == "__main__":
    print("üß™ Testando Bot Inteligente")
    print("=" * 50)
    
    # Testar detec√ß√£o de inten√ß√£o
    nlp = NLPProcessor()
    
    test_messages = [
        "Quero um notebook barato",
        "Me recomenda produtos de gaming",
        "Como est√° o mercado de eletr√¥nicos?",
        "Quero monitorar pre√ßos de smartphones"
    ]
    
    for message in test_messages:
        intent = nlp.detect_intent(message)
        print(f"'{message}' -> {intent.intent.value} (confian√ßa: {intent.confidence:.2f})")
        if intent.entities:
            print(f"  Entidades: {intent.entities}")
    
    print("\n‚úÖ Teste do bot inteligente conclu√≠do!")
